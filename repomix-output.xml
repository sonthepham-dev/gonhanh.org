This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
core/
  src/
    data/
      chars.rs
      constants.rs
      keys.rs
      mod.rs
      vowel.rs
    engine/
      buffer.rs
      mod.rs
      shortcut.rs
      syllable.rs
      transform.rs
      validation.rs
    input/
      mod.rs
      telex.rs
      vni.rs
    updater/
      mod.rs
    lib.rs
    utils.rs
  tests/
    common/
      mod.rs
    engine_test.rs
    integration_test.rs
    paragraph_test.rs
    typing_test.rs
    unit_test.rs
  Cargo.toml
platforms/
  linux/
    .keep
  macos/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
        icon_1024.png
        icon_128.png
        icon_16.png
        icon_256.png
        icon_32.png
        icon_512.png
        icon_64.png
      AppLogo.imageset/
        AppLogo.png
        AppLogo@2x.png
        Contents.json
      Contents.json
    dmg-resources/
      background.png
      background.tiff
      background@2x.png
    GoNhanh.xcodeproj/
      xcshareddata/
        xcschemes/
          GoNhanh.xcscheme
      project.pbxproj
    Tests/
      LaunchAtLoginTests.swift
    AboutView.swift
    App.swift
    AppMetadata.swift
    GoNhanh.entitlements
    Info.plist
    LaunchAtLogin.swift
    MenuBar.swift
    OnboardingView.swift
    RustBridge.swift
    SettingsView.swift
    UpdateChecker.swift
    UpdateManager.swift
    UpdateView.swift
  windows/
    GoNhanh/
      Core/
        AppMetadata.cs
        KeyboardHook.cs
        KeyCodes.cs
        RustBridge.cs
        TextSender.cs
      Native/
        .gitkeep
      Resources/
        Icons/
          .gitkeep
      Services/
        SettingsService.cs
      Views/
        AboutWindow.xaml
        AboutWindow.xaml.cs
        OnboardingWindow.xaml
        OnboardingWindow.xaml.cs
        TrayIcon.cs
      App.xaml
      App.xaml.cs
      GoNhanh.csproj
    README.md
scripts/
  build-core-windows.ps1
  build-core.sh
  build-macos-swift.sh
  build-macos.sh
  build-windows.sh
  create-dmg-background.sh
  create-dmg.sh
  generate-release-notes.sh
  setup-windows.ps1
  setup.sh
.gitattributes
.gitignore
.repomixignore
CONTRIBUTING.md
LICENSE
Makefile
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="core/src/data/chars.rs">
//! Vietnamese Unicode Character System
//!
//! Provides character conversion between base vowels + modifiers + marks
//! and composed Vietnamese Unicode characters.
//!
//! ## Design Principles
//! - Single lookup table for all vowel combinations (12 bases √ó 6 marks = 72)
//! - Uses Rust's built-in `to_uppercase()` for case conversion
//! - No hardcoded case-by-case matching
//!
//! ## Character Components
//! - Base vowel: a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y
//! - Mark (d·∫•u thanh): none, s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng
//! - Case: lowercase, uppercase

use super::keys;

/// Tone modifiers (d·∫•u ph·ª•) - changes base vowel form
pub mod tone {
    pub const NONE: u8 = 0;
    pub const CIRCUMFLEX: u8 = 1; // ^ (m≈©): a‚Üí√¢, e‚Üí√™, o‚Üí√¥
    pub const HORN: u8 = 2; // ∆°, ∆∞ or breve ƒÉ
}

/// Marks (d·∫•u thanh) - Vietnamese tone marks
pub mod mark {
    pub const NONE: u8 = 0;
    pub const SAC: u8 = 1; // s·∫Øc (√°)
    pub const HUYEN: u8 = 2; // huy·ªÅn (√†)
    pub const HOI: u8 = 3; // h·ªèi (·∫£)
    pub const NGA: u8 = 4; // ng√£ (√£)
    pub const NANG: u8 = 5; // n·∫∑ng (·∫°)
}

/// Vietnamese vowel lookup table
/// Each entry: (base_char, [s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng])
const VOWEL_TABLE: [(char, [char; 5]); 12] = [
    ('a', ['√°', '√†', '·∫£', '√£', '·∫°']),
    ('ƒÉ', ['·∫Ø', '·∫±', '·∫≥', '·∫µ', '·∫∑']),
    ('√¢', ['·∫•', '·∫ß', '·∫©', '·∫´', '·∫≠']),
    ('e', ['√©', '√®', '·∫ª', '·∫Ω', '·∫π']),
    ('√™', ['·∫ø', '·ªÅ', '·ªÉ', '·ªÖ', '·ªá']),
    ('i', ['√≠', '√¨', '·ªâ', 'ƒ©', '·ªã']),
    ('o', ['√≥', '√≤', '·ªè', '√µ', '·ªç']),
    ('√¥', ['·ªë', '·ªì', '·ªï', '·ªó', '·ªô']),
    ('∆°', ['·ªõ', '·ªù', '·ªü', '·ª°', '·ª£']),
    ('u', ['√∫', '√π', '·ªß', '≈©', '·ª•']),
    ('∆∞', ['·ª©', '·ª´', '·ª≠', '·ªØ', '·ª±']),
    ('y', ['√Ω', '·ª≥', '·ª∑', '·ªπ', '·ªµ']),
];

/// Get base character from key + tone modifier
///
/// # Arguments
/// * `key` - Virtual keycode (a, e, i, o, u, y)
/// * `tone` - Tone modifier: 0=none, 1=circumflex(^), 2=horn/breve
///
/// # Returns
/// Base vowel character: a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y
fn get_base_char(key: u16, t: u8) -> Option<char> {
    match key {
        keys::A => Some(match t {
            tone::CIRCUMFLEX => '√¢',
            tone::HORN => 'ƒÉ', // breve for 'a'
            _ => 'a',
        }),
        keys::E => Some(match t {
            tone::CIRCUMFLEX => '√™',
            _ => 'e',
        }),
        keys::I => Some('i'),
        keys::O => Some(match t {
            tone::CIRCUMFLEX => '√¥',
            tone::HORN => '∆°',
            _ => 'o',
        }),
        keys::U => Some(match t {
            tone::HORN => '∆∞',
            _ => 'u',
        }),
        keys::Y => Some('y'),
        _ => None,
    }
}

/// Apply mark to base vowel character
///
/// Uses lookup table to find the marked variant.
///
/// # Arguments
/// * `base` - Base vowel character (a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y)
/// * `mark` - Mark: 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
fn apply_mark(base: char, m: u8) -> char {
    if m == mark::NONE || m > mark::NANG {
        return base;
    }

    VOWEL_TABLE
        .iter()
        .find(|(b, _)| *b == base)
        .map(|(_, marks)| marks[(m - 1) as usize])
        .unwrap_or(base)
}

/// Convert to uppercase using Rust's Unicode-aware method
///
/// This handles all Vietnamese characters correctly without
/// explicit character mapping.
fn to_upper(ch: char) -> char {
    ch.to_uppercase().next().unwrap_or(ch)
}

/// Convert key + modifiers to Vietnamese character
///
/// # Arguments
/// * `key` - Virtual keycode
/// * `caps` - Uppercase flag
/// * `tone` - Tone modifier: 0=none, 1=circumflex(^), 2=horn/breve
/// * `mark` - Mark: 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
pub fn to_char(key: u16, caps: bool, tone: u8, mark: u8) -> Option<char> {
    // Handle D specially (not a vowel but needs conversion)
    if key == keys::D {
        return Some(if caps { 'D' } else { 'd' });
    }

    let base = get_base_char(key, tone)?;
    let marked = apply_mark(base, mark);
    Some(if caps { to_upper(marked) } else { marked })
}

/// Get ƒë/ƒê character
pub fn get_d(caps: bool) -> char {
    if caps {
        'ƒê'
    } else {
        'ƒë'
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_vowels() {
        // Basic vowels without modifiers
        assert_eq!(to_char(keys::A, false, 0, 0), Some('a'));
        assert_eq!(to_char(keys::E, false, 0, 0), Some('e'));
        assert_eq!(to_char(keys::I, false, 0, 0), Some('i'));
        assert_eq!(to_char(keys::O, false, 0, 0), Some('o'));
        assert_eq!(to_char(keys::U, false, 0, 0), Some('u'));
        assert_eq!(to_char(keys::Y, false, 0, 0), Some('y'));
    }

    #[test]
    fn test_tone_modifiers() {
        // Circumflex (^)
        assert_eq!(to_char(keys::A, false, 1, 0), Some('√¢'));
        assert_eq!(to_char(keys::E, false, 1, 0), Some('√™'));
        assert_eq!(to_char(keys::O, false, 1, 0), Some('√¥'));

        // Horn/Breve
        assert_eq!(to_char(keys::A, false, 2, 0), Some('ƒÉ'));
        assert_eq!(to_char(keys::O, false, 2, 0), Some('∆°'));
        assert_eq!(to_char(keys::U, false, 2, 0), Some('∆∞'));
    }

    #[test]
    fn test_marks() {
        // All 5 marks on 'a'
        assert_eq!(to_char(keys::A, false, 0, 1), Some('√°')); // s·∫Øc
        assert_eq!(to_char(keys::A, false, 0, 2), Some('√†')); // huy·ªÅn
        assert_eq!(to_char(keys::A, false, 0, 3), Some('·∫£')); // h·ªèi
        assert_eq!(to_char(keys::A, false, 0, 4), Some('√£')); // ng√£
        assert_eq!(to_char(keys::A, false, 0, 5), Some('·∫°')); // n·∫∑ng
    }

    #[test]
    fn test_combined_tone_and_mark() {
        // √¢ + s·∫Øc = ·∫•
        assert_eq!(to_char(keys::A, false, 1, 1), Some('·∫•'));
        // ∆° + huy·ªÅn = ·ªù
        assert_eq!(to_char(keys::O, false, 2, 2), Some('·ªù'));
        // ∆∞ + n·∫∑ng = ·ª±
        assert_eq!(to_char(keys::U, false, 2, 5), Some('·ª±'));
    }

    #[test]
    fn test_uppercase() {
        assert_eq!(to_char(keys::A, true, 0, 0), Some('A'));
        assert_eq!(to_char(keys::A, true, 0, 1), Some('√Å'));
        assert_eq!(to_char(keys::A, true, 1, 1), Some('·∫§'));
        assert_eq!(to_char(keys::O, true, 2, 2), Some('·ªú'));
        assert_eq!(to_char(keys::U, true, 2, 5), Some('·ª∞'));
    }

    #[test]
    fn test_d() {
        assert_eq!(get_d(false), 'ƒë');
        assert_eq!(get_d(true), 'ƒê');
    }
}
</file>

<file path="core/src/data/vowel.rs">
//! Vietnamese Vowel System
//!
//! Implements phonological classification of Vietnamese vowels based on:
//! - docs/vietnamese-language-system.md
//! - https://vi.wikipedia.org/wiki/Quy_t·∫Øc_ƒë·∫∑t_d·∫•u_thanh_c·ªßa_ch·ªØ_Qu·ªëc_ng·ªØ
//!
//! ## Vowel Classification
//!
//! Vietnamese has 12 vowels with 3 modifier types:
//! - Simple: a, e, i, o, u, y
//! - Circumflex (^): √¢, √™, √¥
//! - Horn (m√≥c): ∆°, ∆∞
//! - Breve (trƒÉng): ƒÉ
//!
//! ## Phonological Roles
//!
//! In Vietnamese syllable structure (C)(G)V(C):
//! - **Medial (√¢m ƒë·ªám)**: o, u when followed by main vowel (oa, oe, uy, ua, u√™)
//! - **Main (√¢m ch√≠nh)**: The primary vowel carrying tone
//! - **Glide (b√°n nguy√™n √¢m)**: i/y, u/o at syllable end (ai, ao, iu, oi)

use super::keys;

/// Vowel modifier type (d·∫•u ph·ª•)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Modifier {
    None = 0,       // a, e, i, o, u, y
    Circumflex = 1, // √¢, √™, √¥ (^)
    Horn = 2,       // ∆°, ∆∞ (m√≥c) / ƒÉ (trƒÉng)
}

/// Phonological role in syllable
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Role {
    Main,   // Primary vowel (carries tone)
    Medial, // Glide before main vowel (o in oa, u in uy)
    Final,  // Glide at syllable end (i in ai, u in au)
}

/// Vowel information
#[derive(Clone, Copy, Debug)]
pub struct Vowel {
    pub key: u16,
    pub modifier: Modifier,
    pub pos: usize,
}

impl Vowel {
    pub fn new(key: u16, modifier: Modifier, pos: usize) -> Self {
        Self { key, modifier, pos }
    }

    /// Check if this vowel has a diacritic modifier (^, ∆°, ∆∞, ƒÉ)
    pub fn has_diacritic(&self) -> bool {
        self.modifier != Modifier::None
    }
}

/// Vietnamese vowel phonology analyzer
pub struct Phonology;

impl Phonology {
    /// Find the position where tone mark should be placed
    ///
    /// ## Vietnamese Tone Placement Rules
    ///
    /// Based on docs/vietnamese-language-system.md section 7:
    ///
    /// 1. **Single vowel**: Mark directly on it
    ///
    /// 2. **Two vowels with final consonant**: Mark on 2nd vowel
    ///    - to√°n, ho√†n, ti·∫øn, mu·ªën, bi·ªÉn
    ///
    /// 3. **Two vowels open syllable**:
    ///    - Medial + Main (oa, oe, uy, qua, u√™): Mark on 2nd (main)
    ///    - Main + Glide (ai, ao, au, oi, ui): Mark on 1st (main)
    ///    - Compound (∆∞∆°, u√¥, i√™): Mark on 2nd (main has diacritic)
    ///    - ∆∞a pattern: Mark on 1st (∆∞ has diacritic, a is simple)
    ///    - ua without q: Mark on 1st (u is main, e.g., m√πa)
    ///
    /// 4. **Three+ vowels**: Mark on middle vowel
    ///    - ∆∞∆°i, oai, u√¥i: Mark on middle
    ///
    /// 5. **Diacritic priority**: When vowel has diacritic (ƒÉ, √¢, √™, √¥, ∆°, ∆∞),
    ///    it often receives the mark
    ///
    /// ## Parameters
    /// - `has_qu_initial`: true if 'q' precedes 'u' (e.g., "qua" vs "mua")
    pub fn find_tone_position(
        vowels: &[Vowel],
        has_final_consonant: bool,
        modern: bool,
        has_qu_initial: bool,
    ) -> usize {
        let n = vowels.len();
        if n == 0 {
            return 0;
        }
        if n == 1 {
            return vowels[0].pos;
        }

        // Two vowels
        if n == 2 {
            let v1 = &vowels[0];
            let v2 = &vowels[1];

            // With final consonant: always mark on 2nd vowel
            if has_final_consonant {
                return v2.pos;
            }

            // ∆∞a pattern: ∆∞ has diacritic, a doesn't ‚Üí mark on ∆∞
            // This must be checked BEFORE compound vowels because ∆∞a is not ∆∞∆°
            // General rule: if 1st has diacritic and 2nd doesn't, mark on 1st
            // Note: when 1st has diacritic, it's no longer a simple medial pair
            // e.g., "ua" (qua) is medial pair, but "∆∞a" (s·ª©a) is not
            if v1.has_diacritic() && !v2.has_diacritic() {
                return v1.pos;
            }

            // Compound vowels ∆∞∆°, u√¥, i√™: mark on 2nd (has diacritic)
            if Self::is_compound_vowel(v1.key, v2.key) {
                return v2.pos;
            }

            // 2nd has diacritic ‚Üí mark on 2nd
            if v2.has_diacritic() {
                return v2.pos;
            }

            // Medial pairs (oa, oe, uy, u√™, and ua with q): mark on 2nd (main vowel)
            if Self::is_medial_pair(v1.key, v2.key, has_qu_initial) {
                return if modern { v2.pos } else { v1.pos };
            }

            // ua without q (mua): u is main vowel, a is glide ‚Üí mark on u
            if v1.key == keys::U && v2.key == keys::A && !has_qu_initial {
                return v1.pos;
            }

            // Main + glide (ai, ao, au, oi, ui): mark on 1st (main vowel)
            if Self::is_main_glide_pair(v1.key, v2.key) {
                return v1.pos;
            }

            // Default: mark on 2nd
            return v2.pos;
        }

        // Three+ vowels
        if n == 3 {
            let k0 = vowels[0].key;
            let k1 = vowels[1].key;
            let k2 = vowels[2].key;

            // Priority 1: Middle vowel with diacritic
            // ∆∞∆°i (m∆∞·ªùi): ∆∞ and ∆° both have diacritic, mark on ∆° (middle)
            if vowels[1].has_diacritic() {
                return vowels[1].pos;
            }

            // Priority 2: Last vowel with diacritic (and middle doesn't)
            // uy√™ (khuy√™n): mark on √™ (has diacritic)
            if vowels[2].has_diacritic() {
                return vowels[2].pos;
            }

            // Priority 3: ∆∞∆°i, u√¥i patterns: mark on middle
            if k0 == keys::U && k1 == keys::O {
                return vowels[1].pos;
            }

            // Priority 4: oai, oay patterns: mark on middle (a)
            if k0 == keys::O && k1 == keys::A {
                return vowels[1].pos;
            }

            // Priority 5: uy√™ pattern (no diacritic on √™ yet): mark on √™ (last)
            if k0 == keys::U && k1 == keys::Y && k2 == keys::E {
                return vowels[2].pos;
            }
        }

        // For 4+ vowels: find middle vowel with diacritic first
        let mid = n / 2;
        if vowels[mid].has_diacritic() {
            return vowels[mid].pos;
        }

        // Then any vowel with diacritic
        for v in vowels {
            if v.has_diacritic() {
                return v.pos;
            }
        }

        // Default: middle vowel
        vowels[mid].pos
    }

    /// Determine the role of each vowel in a syllable
    #[allow(dead_code)]
    pub fn classify_roles(
        vowels: &[Vowel],
        has_final_consonant: bool,
        has_qu_initial: bool,
    ) -> Vec<(usize, Role)> {
        let n = vowels.len();
        if n == 0 {
            return vec![];
        }
        if n == 1 {
            return vec![(vowels[0].pos, Role::Main)];
        }

        let mut roles = vec![Role::Main; n];

        if n == 2 {
            let (k1, k2) = (vowels[0].key, vowels[1].key);

            if Self::is_medial_pair(k1, k2, has_qu_initial)
                || Self::is_compound_vowel(k1, k2)
                || has_final_consonant
            {
                roles[0] = Role::Medial;
                roles[1] = Role::Main;
            } else if Self::is_main_glide_pair(k1, k2)
                || (vowels[0].has_diacritic() && !vowels[1].has_diacritic())
            {
                // ∆∞a pattern: ∆∞ is main
                roles[0] = Role::Main;
                roles[1] = Role::Final;
            }
        } else {
            // Three+ vowels
            roles[0] = Role::Medial;
            if !has_final_consonant {
                roles[n - 1] = Role::Final;
            }

            // Find main vowel
            let main_idx = n / 2;
            roles[main_idx] = Role::Main;
        }

        vowels.iter().zip(roles).map(|(v, r)| (v.pos, r)).collect()
    }

    /// Check if v1+v2 forms a medial+main pair (√¢m ƒë·ªám + √¢m ch√≠nh)
    ///
    /// Medial pairs: oa, oe, u√™, uy, and ua (only when preceded by 'q')
    /// These are when the first vowel acts as a glide before the main vowel
    ///
    /// Note: "ua" is special:
    /// - "qua" ‚Üí qu√° (u is medial, mark on a)
    /// - "mua" ‚Üí m√πa (u is main vowel, mark on u)
    fn is_medial_pair(v1: u16, v2: u16, has_qu_initial: bool) -> bool {
        // ua is only medial when preceded by 'q'
        if v1 == keys::U && v2 == keys::A {
            return has_qu_initial;
        }

        matches!(
            (v1, v2),
            (keys::O, keys::A) | // oa
            (keys::O, keys::E) | // oe
            (keys::U, keys::E) | // u√™
            (keys::U, keys::Y) // uy
        )
    }

    /// Check if v1+v2 forms a main+glide pair (√¢m ch√≠nh + b√°n nguy√™n √¢m)
    ///
    /// Final glide pairs: ai, ay, ao, au, oi, √¥i, ∆°i, ui, ∆∞i, √™u, iu, etc.
    fn is_main_glide_pair(v1: u16, v2: u16) -> bool {
        // Second vowel must be a glide (i, y, o, u)
        let is_glide = matches!(v2, keys::I | keys::Y | keys::O | keys::U);
        if !is_glide {
            return false;
        }

        // Not a medial or compound pattern
        // Note: for is_main_glide_pair, we pass false for has_qu_initial since
        // this check is about the pair pattern, not the specific context
        !Self::is_medial_pair(v1, v2, false) && !Self::is_compound_vowel(v1, v2)
    }

    /// Check if v1+v2 forms a compound vowel (∆∞∆°, u√¥, i√™)
    ///
    /// These are diphthongs where second vowel (with diacritic) carries the tone
    fn is_compound_vowel(v1: u16, v2: u16) -> bool {
        matches!(
            (v1, v2),
            (keys::U, keys::O) | // ∆∞∆°, u√¥
            (keys::I, keys::E) // i√™
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn v(key: u16, modifier: Modifier, pos: usize) -> Vowel {
        Vowel::new(key, modifier, pos)
    }

    #[test]
    fn test_single_vowel() {
        let vowels = vec![v(keys::A, Modifier::None, 0)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }

    #[test]
    fn test_medial_pairs() {
        // oa ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::O, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // uy ‚Üí mark on y (pos 1)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::Y, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_ua_patterns() {
        // ua without q (mua) ‚Üí mark on u (pos 0)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );

        // ua with q (qua) ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(Phonology::find_tone_position(&vowels, false, true, true), 1);
    }

    #[test]
    fn test_main_glide_pairs() {
        // ai ‚Üí mark on a (pos 0)
        let vowels = vec![v(keys::A, Modifier::None, 0), v(keys::I, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );

        // ao ‚Üí mark on a (pos 0)
        let vowels = vec![v(keys::A, Modifier::None, 0), v(keys::O, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }

    #[test]
    fn test_with_final_consonant() {
        // oan ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::O, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(Phonology::find_tone_position(&vowels, true, true, false), 1);
    }

    #[test]
    fn test_compound_vowels() {
        // ∆∞∆° ‚Üí mark on ∆° (pos 1)
        let vowels = vec![v(keys::U, Modifier::Horn, 0), v(keys::O, Modifier::Horn, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // i√™ ‚Üí mark on √™ (pos 1)
        let vowels = vec![
            v(keys::I, Modifier::None, 0),
            v(keys::E, Modifier::Circumflex, 1),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_three_vowels() {
        // ∆∞∆°i ‚Üí mark on ∆° (pos 1, middle with diacritic)
        let vowels = vec![
            v(keys::U, Modifier::Horn, 0),
            v(keys::O, Modifier::Horn, 1),
            v(keys::I, Modifier::None, 2),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // oai ‚Üí mark on a (pos 1, middle)
        let vowels = vec![
            v(keys::O, Modifier::None, 0),
            v(keys::A, Modifier::None, 1),
            v(keys::I, Modifier::None, 2),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_diacritic_priority() {
        // ∆∞a ‚Üí mark on ∆∞ (pos 0, has diacritic)
        let vowels = vec![v(keys::U, Modifier::Horn, 0), v(keys::A, Modifier::None, 1)];
        // ∆∞a is NOT a compound vowel (compound is ∆∞∆°, not ∆∞a)
        // ∆∞ has diacritic, a doesn't ‚Üí mark on ∆∞
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }
}
</file>

<file path="platforms/macos/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "icon_16.png",
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "filename" : "icon_32.png",
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "filename" : "icon_32.png",
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "filename" : "icon_64.png",
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "filename" : "icon_128.png",
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "filename" : "icon_256.png",
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "filename" : "icon_256.png",
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "filename" : "icon_512.png",
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "filename" : "icon_512.png",
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "filename" : "icon_1024.png",
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="platforms/macos/Assets.xcassets/AppLogo.imageset/Contents.json">
{
  "images" : [
    {
      "filename" : "AppLogo.png",
      "idiom" : "mac",
      "scale" : "1x"
    },
    {
      "filename" : "AppLogo@2x.png",
      "idiom" : "mac",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="platforms/macos/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="platforms/macos/GoNhanh.xcodeproj/xcshareddata/xcschemes/GoNhanh.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1500"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "A1000006000000000000001"
               BuildableName = "GoNhanh.app"
               BlueprintName = "GoNhanh"
               ReferencedContainer = "container:GoNhanh.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "A1000006000000000000001"
            BuildableName = "GoNhanh.app"
            BlueprintName = "GoNhanh"
            ReferencedContainer = "container:GoNhanh.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "A1000006000000000000001"
            BuildableName = "GoNhanh.app"
            BlueprintName = "GoNhanh"
            ReferencedContainer = "container:GoNhanh.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="platforms/macos/App.swift">
import SwiftUI

@main
struct GoNhanhApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        Settings {
            EmptyView()
        }
    }
}

class AppDelegate: NSObject, NSApplicationDelegate {
    var menuBar: MenuBarController?

    func applicationDidFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.accessory)
        menuBar = MenuBarController()
    }

    func applicationWillTerminate(_ notification: Notification) {
        KeyboardHookManager.shared.stop()
    }
}
</file>

<file path="platforms/macos/GoNhanh.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <false/>
    <key>com.apple.security.automation.apple-events</key>
    <true/>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
    <key>com.apple.security.get-task-allow</key>
    <true/>
</dict>
</plist>
</file>

<file path="platforms/macos/SettingsView.swift">
import SwiftUI

// SettingsView removed - settings are managed via menu bar
// This file kept for Xcode project compatibility

struct SettingsView: View {
    var body: some View {
        EmptyView()
    }
}
</file>

<file path="scripts/build-core.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

echo "ü¶Ä Building Rust core..."

cd "$(dirname "$0")/../core"

# Build for macOS (universal binary)
echo "Building for aarch64-apple-darwin..."
cargo build --release --target aarch64-apple-darwin

echo "Building for x86_64-apple-darwin..."
cargo build --release --target x86_64-apple-darwin

# Create universal binary
echo "Creating universal binary..."
lipo -create \
    target/aarch64-apple-darwin/release/libgonhanh_core.a \
    target/x86_64-apple-darwin/release/libgonhanh_core.a \
    -output ../platforms/macos/libgonhanh_core.a

echo "‚úÖ Rust core built successfully!"
echo "üì¶ Output: platforms/macos/libgonhanh_core.a"
</file>

<file path="scripts/build-macos-swift.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

echo "üçé Building macOS app with swiftc..."

# Build core first
./scripts/build-core.sh

cd "$(dirname "$0")/../platforms/macos"

# Create build directory
mkdir -p build/Release

# Compile Swift files
echo "Compiling Swift sources..."
swiftc \
    -o build/Release/GoNhanh \
    -sdk $(xcrun --show-sdk-path) \
    -target arm64-apple-macos13.0 \
    -F /System/Library/Frameworks \
    -framework Foundation \
    -framework AppKit \
    -framework SwiftUI \
    -L . \
    -lgonhanh_core \
    -Xlinker -rpath -Xlinker @executable_path \
    App.swift MenuBar.swift SettingsView.swift RustBridge.swift

echo "‚úÖ macOS app built successfully!"
echo "üì¶ Binary: platforms/macos/build/Release/GoNhanh"
echo ""
echo "To create .app bundle, run: make bundle"
</file>

<file path="scripts/setup.sh">
#!/bin/bash
set -e

echo "üöÄ Setting up GoNhanh development environment..."

# Source rustup if available
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Check Rust
if ! command -v cargo &> /dev/null; then
    echo "‚ùå Rust not found. Please install: https://rustup.rs"
    exit 1
fi
echo "‚úÖ Rust found: $(rustc --version)"
echo "üìç Cargo location: $(which cargo)"

# Install Rust targets for macOS
echo "üì¶ Installing Rust targets..."
rustup target add aarch64-apple-darwin
rustup target add x86_64-apple-darwin

# Check Xcode (macOS only)
if [[ "$OSTYPE" == "darwin"* ]]; then
    if ! command -v xcodebuild &> /dev/null; then
        echo "‚ö†Ô∏è  Xcode not found. Please install from App Store."
    else
        echo "‚úÖ Xcode found: $(xcodebuild -version | head -n 1)"
    fi
fi

# Make scripts executable
chmod +x scripts/*.sh

echo ""
echo "‚úÖ Setup complete!"
echo ""
echo "Next steps:"
echo "  1. Build Rust core:  ./scripts/build-core.sh"
echo "  2. Create Xcode project in platforms/macos/"
echo "  3. Build macOS app:  ./scripts/build-macos.sh"
echo ""
echo "Documentation: docs/development.md"
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".repomixignore">
docs/*
plans/*
assets/*
dist/*
coverage/*
build/*
ios/*
android/*
tests/*
__tests__/*
__pycache__/*
node_modules/*

.opencode/*
.claude/*
.serena/*
.pnpm-store/*
.github/*
.dart_tool/*
.idea/*
.husky/*
.venv/*
</file>

<file path="core/src/data/keys.rs">
//! macOS virtual keycodes

// Letters
pub const A: u16 = 0;
pub const S: u16 = 1;
pub const D: u16 = 2;
pub const F: u16 = 3;
pub const H: u16 = 4;
pub const G: u16 = 5;
pub const Z: u16 = 6;
pub const X: u16 = 7;
pub const C: u16 = 8;
pub const V: u16 = 9;
pub const B: u16 = 11;
pub const Q: u16 = 12;
pub const W: u16 = 13;
pub const E: u16 = 14;
pub const R: u16 = 15;
pub const Y: u16 = 16;
pub const T: u16 = 17;
pub const O: u16 = 31;
pub const U: u16 = 32;
pub const I: u16 = 34;
pub const P: u16 = 35;
pub const L: u16 = 37;
pub const J: u16 = 38;
pub const K: u16 = 40;
pub const N: u16 = 45;
pub const M: u16 = 46;

// Numbers
pub const N1: u16 = 18;
pub const N2: u16 = 19;
pub const N3: u16 = 20;
pub const N4: u16 = 21;
pub const N5: u16 = 23;
pub const N6: u16 = 22;
pub const N7: u16 = 26;
pub const N8: u16 = 28;
pub const N9: u16 = 25;
pub const N0: u16 = 29;

// Special
pub const SPACE: u16 = 49;
pub const DELETE: u16 = 51;
pub const TAB: u16 = 48;
pub const RETURN: u16 = 36;
pub const ENTER: u16 = 76;
pub const ESC: u16 = 53;
pub const LEFT: u16 = 123;
pub const RIGHT: u16 = 124;
pub const DOWN: u16 = 125;
pub const UP: u16 = 126;

// Punctuation
pub const DOT: u16 = 47;
pub const COMMA: u16 = 43;
pub const SLASH: u16 = 44;
pub const SEMICOLON: u16 = 41;
pub const QUOTE: u16 = 39;
pub const LBRACKET: u16 = 33;
pub const RBRACKET: u16 = 30;
pub const BACKSLASH: u16 = 42;
pub const MINUS: u16 = 27;
pub const EQUAL: u16 = 24;
pub const BACKQUOTE: u16 = 50;

/// Check if key breaks word (space, punctuation, arrows, etc.)
pub fn is_break(key: u16) -> bool {
    matches!(
        key,
        SPACE
            | TAB
            | RETURN
            | ENTER
            | ESC
            | LEFT
            | RIGHT
            | UP
            | DOWN
            | DOT
            | COMMA
            | SLASH
            | SEMICOLON
            | QUOTE
            | LBRACKET
            | RBRACKET
            | BACKSLASH
            | MINUS
            | EQUAL
            | BACKQUOTE
    )
}

/// Check if key is a vowel (a, e, i, o, u, y)
pub fn is_vowel(key: u16) -> bool {
    matches!(key, A | E | I | O | U | Y)
}

/// Check if key is a letter
pub fn is_letter(key: u16) -> bool {
    matches!(
        key,
        A | B
            | C
            | D
            | E
            | F
            | G
            | H
            | I
            | J
            | K
            | L
            | M
            | N
            | O
            | P
            | Q
            | R
            | S
            | T
            | U
            | V
            | W
            | X
            | Y
            | Z
    )
}

/// Check if key is a consonant
pub fn is_consonant(key: u16) -> bool {
    is_letter(key) && !is_vowel(key)
}

/// Check if key is a number (0-9)
pub fn is_number(key: u16) -> bool {
    matches!(key, N0 | N1 | N2 | N3 | N4 | N5 | N6 | N7 | N8 | N9)
}
</file>

<file path="core/src/data/mod.rs">
//! Vietnamese Language Data Modules
//!
//! This module contains all linguistic data for Vietnamese input:
//! - `keys`: Virtual keycode definitions (platform-specific)
//! - `chars`: Unicode character conversion (includes tone/mark constants)
//! - `vowel`: Vietnamese vowel phonology system

pub mod chars;
pub mod constants;
pub mod keys;
pub mod vowel;

pub use chars::{get_d, mark, to_char, tone};
pub use constants::*;
pub use keys::{is_break, is_letter, is_vowel};
pub use vowel::{Modifier, Phonology, Role, Vowel};
</file>

<file path="core/src/updater/mod.rs">
//! Auto-update module for GoNhanh
//!
//! Provides version comparison utilities that can be used across all platforms.
//! HTTP calls are handled by the platform layer (Swift/C#/GTK) for flexibility.

/// Semantic version representation
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Version {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
}

impl Version {
    /// Parse a version string like "1.2.3" or "v1.2.3"
    pub fn parse(s: &str) -> Option<Version> {
        let s = s.trim().strip_prefix('v').unwrap_or(s);
        let parts: Vec<&str> = s.split('.').collect();

        if parts.len() < 2 {
            return None;
        }

        let major = parts[0].parse().ok()?;
        let minor = parts[1].parse().ok()?;
        let patch = parts.get(2).and_then(|p| p.parse().ok()).unwrap_or(0);

        Some(Version {
            major,
            minor,
            patch,
        })
    }

    /// Compare two versions
    /// Returns: -1 if self < other, 0 if equal, 1 if self > other
    pub fn compare(&self, other: &Version) -> i32 {
        if self.major != other.major {
            return if self.major < other.major { -1 } else { 1 };
        }
        if self.minor != other.minor {
            return if self.minor < other.minor { -1 } else { 1 };
        }
        if self.patch != other.patch {
            return if self.patch < other.patch { -1 } else { 1 };
        }
        0
    }

    /// Check if update is available (other > self)
    pub fn has_update(&self, other: &Version) -> bool {
        self.compare(other) < 0
    }
}

impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}.{}.{}", self.major, self.minor, self.patch)
    }
}

// ============================================================
// FFI Interface for Version Comparison
// ============================================================

/// Compare two version strings
/// Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2, -99 if parse error
///
/// # Safety
/// Callers must ensure v1 and v2 are valid null-terminated C strings or null pointers.
#[no_mangle]
#[allow(clippy::not_unsafe_ptr_arg_deref)]
pub extern "C" fn version_compare(v1: *const i8, v2: *const i8) -> i32 {
    let v1_str = unsafe {
        if v1.is_null() {
            return -99;
        }
        match std::ffi::CStr::from_ptr(v1).to_str() {
            Ok(s) => s,
            Err(_) => return -99,
        }
    };

    let v2_str = unsafe {
        if v2.is_null() {
            return -99;
        }
        match std::ffi::CStr::from_ptr(v2).to_str() {
            Ok(s) => s,
            Err(_) => return -99,
        }
    };

    let ver1 = match Version::parse(v1_str) {
        Some(v) => v,
        None => return -99,
    };

    let ver2 = match Version::parse(v2_str) {
        Some(v) => v,
        None => return -99,
    };

    ver1.compare(&ver2)
}

/// Check if an update is available
/// Returns: 1 if v2 > v1 (update available), 0 if not, -99 if parse error
#[no_mangle]
pub extern "C" fn version_has_update(current: *const i8, latest: *const i8) -> i32 {
    let result = version_compare(current, latest);
    if result == -99 {
        return -99;
    }
    if result < 0 {
        1
    } else {
        0
    }
}

// ============================================================
// Tests
// ============================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_parse() {
        assert_eq!(
            Version::parse("1.2.3"),
            Some(Version {
                major: 1,
                minor: 2,
                patch: 3
            })
        );
        assert_eq!(
            Version::parse("v1.2.3"),
            Some(Version {
                major: 1,
                minor: 2,
                patch: 3
            })
        );
        assert_eq!(
            Version::parse("1.0"),
            Some(Version {
                major: 1,
                minor: 0,
                patch: 0
            })
        );
        assert_eq!(Version::parse("invalid"), None);
    }

    #[test]
    fn test_version_compare() {
        let v1 = Version::parse("1.0.0").unwrap();
        let v2 = Version::parse("1.0.1").unwrap();
        let v3 = Version::parse("1.1.0").unwrap();
        let v4 = Version::parse("2.0.0").unwrap();

        assert_eq!(v1.compare(&v1), 0);
        assert_eq!(v1.compare(&v2), -1);
        assert_eq!(v2.compare(&v1), 1);
        assert_eq!(v1.compare(&v3), -1);
        assert_eq!(v1.compare(&v4), -1);
    }

    #[test]
    fn test_has_update() {
        let current = Version::parse("1.0.9").unwrap();
        let latest = Version::parse("1.0.10").unwrap();
        assert!(current.has_update(&latest));

        let same = Version::parse("1.0.9").unwrap();
        assert!(!current.has_update(&same));
    }

    #[test]
    fn test_ffi_version_compare() {
        use std::ffi::CString;

        let v1 = CString::new("1.0.0").unwrap();
        let v2 = CString::new("1.0.1").unwrap();

        assert_eq!(version_compare(v1.as_ptr(), v2.as_ptr()), -1);
        assert_eq!(version_compare(v2.as_ptr(), v1.as_ptr()), 1);
        assert_eq!(version_compare(v1.as_ptr(), v1.as_ptr()), 0);
    }

    #[test]
    fn test_ffi_has_update() {
        use std::ffi::CString;

        let current = CString::new("1.0.9").unwrap();
        let latest = CString::new("1.0.10").unwrap();

        assert_eq!(version_has_update(current.as_ptr(), latest.as_ptr()), 1);
        assert_eq!(version_has_update(latest.as_ptr(), current.as_ptr()), 0);
    }
}
</file>

<file path="core/tests/engine_test.rs">
//! Engine Tests - Syllable parsing, validation, and transformation

mod common;
use common::{telex, vni};
use gonhanh_core::engine::Engine;

// ============================================================
// SYLLABLE PARSING TESTS
// ============================================================

/// Test syllable parsing via engine behavior
/// These test Vietnamese syllable structure recognition

#[test]
fn syllable_simple_cv() {
    // Simple consonant + vowel
    telex(&[
        ("ba", "ba"),
        ("ca", "ca"),
        ("da", "da"),
        ("ma", "ma"),
        ("na", "na"),
    ]);
}

#[test]
fn syllable_cvc() {
    // Consonant + vowel + consonant
    telex(&[
        ("ban", "ban"),
        ("cam", "cam"),
        ("dat", "dat"),
        ("mac", "mac"),
        ("nap", "nap"),
    ]);
}

#[test]
fn syllable_double_initial() {
    // Double consonant initials
    telex(&[
        ("cha", "cha"),
        ("ghi", "ghi"),
        ("kha", "kha"),
        ("nga", "nga"),
        ("nha", "nha"),
        ("pha", "pha"),
        ("tha", "tha"),
        ("tra", "tra"),
    ]);
}

#[test]
fn syllable_triple_initial() {
    // Triple consonant initial (ngh)
    telex(&[("nghe", "nghe"), ("nghi", "nghi"), ("nghieng", "nghieng")]);
}

#[test]
fn syllable_gi_initial() {
    // gi + vowel = gi is initial
    telex(&[("gia", "gia"), ("giau", "giau"), ("gieo", "gieo")]);
}

#[test]
fn syllable_qu_initial() {
    // qu + vowel = qu is initial
    telex(&[("qua", "qua"), ("quan", "quan"), ("quoc", "quoc")]);
}

#[test]
fn syllable_vowel_only() {
    // Vowel-only syllables
    telex(&[
        ("a", "a"),
        ("e", "e"),
        ("i", "i"),
        ("o", "o"),
        ("u", "u"),
        ("y", "y"),
    ]);
}

#[test]
fn syllable_glide_oa() {
    // o as glide before a
    telex(&[("hoa", "hoa"), ("khoa", "khoa"), ("toa", "toa")]);
}

// ============================================================
// VALIDATION TESTS
// ============================================================

#[test]
fn validation_valid_simple() {
    // Valid simple words should transform
    telex(&[("bas", "b√°"), ("caf", "c√†"), ("dar", "d·∫£")]);
}

#[test]
fn validation_valid_complex() {
    // Valid complex words
    telex(&[
        ("nghieengs", "nghi·∫øng"),
        ("truowngf", "tr∆∞·ªùng"),
        ("nguowif", "ng∆∞·ªùi"),
    ]);
}

#[test]
fn validation_spelling_k_before_eiy() {
    // k must be used before e, i, y
    telex(&[("kes", "k√©"), ("kis", "k√≠"), ("kys", "k√Ω")]);
}

#[test]
fn validation_spelling_c_before_aou() {
    // c must be used before a, o, u
    telex(&[("cas", "c√°"), ("cos", "c√≥"), ("cus", "c√∫")]);
}

#[test]
fn validation_spelling_gh_before_eiy() {
    // gh must be used before e, i
    telex(&[("ghes", "gh√©"), ("ghis", "gh√≠")]);
}

#[test]
fn validation_spelling_ngh_before_eiy() {
    // ngh must be used before e, i
    telex(&[("nghes", "ngh√©"), ("nghis", "ngh√≠")]);
}

// ============================================================
// TONE MODIFIER TESTS (V2 Pattern-based)
// ============================================================

#[test]
fn tone_circumflex_aa() {
    telex(&[
        ("aa", "√¢"),
        ("aas", "·∫•"),
        ("aaf", "·∫ß"),
        ("aar", "·∫©"),
        ("aax", "·∫´"),
        ("aaj", "·∫≠"),
    ]);
}

#[test]
fn tone_circumflex_ee() {
    telex(&[
        ("ee", "√™"),
        ("ees", "·∫ø"),
        ("eef", "·ªÅ"),
        ("eer", "·ªÉ"),
        ("eex", "·ªÖ"),
        ("eej", "·ªá"),
    ]);
}

#[test]
fn tone_circumflex_oo() {
    telex(&[
        ("oo", "√¥"),
        ("oos", "·ªë"),
        ("oof", "·ªì"),
        ("oor", "·ªï"),
        ("oox", "·ªó"),
        ("ooj", "·ªô"),
    ]);
}

#[test]
fn tone_circumflex_delayed() {
    // Delayed circumflex: vowel + consonant + same_vowel ‚Üí circumflex + consonant
    telex(&[("oio", "√¥i"), ("aia", "√¢i"), ("aua", "√¢u"), ("eie", "√™i")]);
}

#[test]
fn tone_horn_ow() {
    telex(&[
        ("ow", "∆°"),
        ("ows", "·ªõ"),
        ("owf", "·ªù"),
        ("owr", "·ªü"),
        ("owx", "·ª°"),
        ("owj", "·ª£"),
    ]);
}

#[test]
fn tone_horn_uw() {
    telex(&[
        ("uw", "∆∞"),
        ("uws", "·ª©"),
        ("uwf", "·ª´"),
        ("uwr", "·ª≠"),
        ("uwx", "·ªØ"),
        ("uwj", "·ª±"),
    ]);
}

#[test]
fn tone_breve_aw() {
    telex(&[
        ("aw", "ƒÉ"),
        ("aws", "·∫Ø"),
        ("awf", "·∫±"),
        ("awr", "·∫≥"),
        ("awx", "·∫µ"),
        ("awj", "·∫∑"),
    ]);
}

#[test]
fn tone_uo_compound() {
    // ∆∞∆° compound - both get horn
    telex(&[
        ("dduowc", "ƒë∆∞∆°c"), // dd for ƒë
        ("uow", "∆∞∆°"),
        ("muown", "m∆∞∆°n"),
    ]);
}

// ============================================================
// MARK MODIFIER TESTS
// ============================================================

#[test]
fn mark_sac() {
    telex(&[
        ("as", "√°"),
        ("es", "√©"),
        ("is", "√≠"),
        ("os", "√≥"),
        ("us", "√∫"),
        ("ys", "√Ω"),
    ]);
}

#[test]
fn mark_huyen() {
    telex(&[
        ("af", "√†"),
        ("ef", "√®"),
        ("if", "√¨"),
        ("of", "√≤"),
        ("uf", "√π"),
        ("yf", "·ª≥"),
    ]);
}

#[test]
fn mark_hoi() {
    telex(&[
        ("ar", "·∫£"),
        ("er", "·∫ª"),
        ("ir", "·ªâ"),
        ("or", "·ªè"),
        ("ur", "·ªß"),
        ("yr", "·ª∑"),
    ]);
}

#[test]
fn mark_nga() {
    telex(&[
        ("ax", "√£"),
        ("ex", "·∫Ω"),
        ("ix", "ƒ©"),
        ("ox", "√µ"),
        ("ux", "≈©"),
        ("yx", "·ªπ"),
    ]);
}

#[test]
fn mark_nang() {
    telex(&[
        ("aj", "·∫°"),
        ("ej", "·∫π"),
        ("ij", "·ªã"),
        ("oj", "·ªç"),
        ("uj", "·ª•"),
        ("yj", "·ªµ"),
    ]);
}

// ============================================================
// STROKE TRANSFORMATION (d ‚Üí ƒë)
// ============================================================

#[test]
fn stroke_dd() {
    telex(&[("dd", "ƒë"), ("dda", "ƒëa"), ("ddi", "ƒëi"), ("ddo", "ƒëo")]);
}

#[test]
fn stroke_delayed() {
    // Delayed stroke: d + vowel + d ‚Üí ƒë + vowel
    telex(&[("dod", "ƒëo"), ("dad", "ƒëa"), ("did", "ƒëi"), ("dud", "ƒëu")]);
}

#[test]
fn stroke_in_word() {
    telex(&[
        ("ddas", "ƒë√°"),
        ("ddef", "ƒë√®"),
        ("ddif", "ƒë√¨"),
        ("ddos", "ƒë√≥"),
    ]);
}

// ============================================================
// REVERT BEHAVIOR TESTS
// ============================================================

#[test]
fn revert_tone_double_key() {
    // aaa ‚Üí aa (revert √¢ back to aa)
    telex(&[("aaa", "aa"), ("eee", "ee"), ("ooo", "oo")]);
}

#[test]
fn revert_mark_double_key() {
    // ass ‚Üí as (revert √° back to as)
    telex(&[
        ("ass", "as"),
        ("aff", "af"),
        ("arr", "ar"),
        ("axx", "ax"),
        ("ajj", "aj"),
    ]);
}

#[test]
fn revert_stroke_double_key() {
    // ddd ‚Üí ƒëd (ƒë + d because third d is just added)
    // Note: This is correct behavior - dd makes ƒë, third d just adds d
    telex(&[("ddd", "ƒëd")]);
}

#[test]
fn triple_same_key() {
    // aaaa ‚Üí a√¢
    let mut e = Engine::new();
    let result = common::type_word(&mut e, "aaaa");
    assert_eq!(result, "a√¢");
}

// ============================================================
// VNI EQUIVALENTS
// ============================================================

#[test]
fn vni_tone_circumflex() {
    vni(&[("a6", "√¢"), ("e6", "√™"), ("o6", "√¥")]);
}

#[test]
fn vni_tone_horn() {
    vni(&[("o7", "∆°"), ("u7", "∆∞")]);
}

#[test]
fn vni_tone_breve() {
    vni(&[("a8", "ƒÉ")]);
}

#[test]
fn vni_marks() {
    vni(&[
        ("a1", "√°"),
        ("a2", "√†"),
        ("a3", "·∫£"),
        ("a4", "√£"),
        ("a5", "·∫°"),
    ]);
}

#[test]
fn vni_stroke() {
    vni(&[("d9", "ƒë"), ("d9a", "ƒëa")]);
}

// ============================================================
// EDGE CASES & REGRESSION TESTS
// ============================================================

#[test]
fn edge_gi_with_mark() {
    // gi + au + mark = gi√†u
    telex(&[("giauf", "gi√†u"), ("giaus", "gi√°u")]);
}

#[test]
fn edge_qu_with_mark() {
    // qu + a + mark
    telex(&[
        ("quas", "qu√°"),
        ("quaf", "qu√†"),
        ("quoocs", "qu·ªëc"), // Need oo for √¥
    ]);
}

#[test]
fn edge_mixed_modifiers() {
    // Tone + mark combinations
    telex(&[
        ("aas", "·∫•"), // √¢ + s·∫Øc
        ("ees", "·∫ø"), // √™ + s·∫Øc
        ("oos", "·ªë"), // √¥ + s·∫Øc
        ("ows", "·ªõ"), // ∆° + s·∫Øc
        ("uws", "·ª©"), // ∆∞ + s·∫Øc
        ("aws", "·∫Ø"), // ƒÉ + s·∫Øc
    ]);
}

#[test]
fn edge_long_words() {
    telex(&[
        ("nghieengs", "nghi·∫øng"),
        ("khuyeenx", "khuy·ªÖn"),
        ("nguowif", "ng∆∞·ªùi"),
        ("truowngf", "tr∆∞·ªùng"),
    ]);
}

#[test]
fn edge_invalid_not_transformed() {
    // Invalid Vietnamese should not be transformed
    // These words don't follow Vietnamese phonology rules
    // and should be passed through
    let mut e = Engine::new();

    // "http" has no vowel - should pass through
    let result = common::type_word(&mut e, "https");
    // Note: 's' at the end might trigger mark, but 'http' part stays
    assert!(result.contains("http"));
}
</file>

<file path="core/tests/typing_test.rs">
//! Typing Tests - Real-world typing scenarios, sentences, behaviors

mod common;
use common::{telex, vni};

// ============================================================
// BACKSPACE & CORRECTIONS
// ============================================================

const TELEX_BACKSPACE: &[(&str, &str)] = &[
    ("vieet<s", "vi·∫ø"),
    ("chaof<o", "ch√†o"),
    ("toi<as", "to√°"),
    ("a<b", "b"),
    ("ab<<cd", "cd"),
    ("abcd<<<", "a"),
    ("vieets<<<ng", "vng"),
];

const VNI_BACKSPACE: &[(&str, &str)] = &[("a1<a2", "√†"), ("o6<o7", "∆°")];

// ============================================================
// TYPOS & WRONG ORDER
// ============================================================

const TELEX_TYPOS: &[(&str, &str)] = &[
    // Wrong order - mark before vowel
    ("sa", "sa"),
    ("as", "√°"),
    // Double mark ‚Üí revert
    ("ass", "as"),
    ("aff", "af"),
    ("arr", "ar"),
    // Double tone ‚Üí revert
    ("aaa", "aa"),
    ("ooo", "oo"),
    ("aww", "aw"),
    // Change mark mid-word
    ("asf", "√†"),
    ("afs", "√°"),
    // Tone then mark
    ("aas", "·∫•"),
    ("ees", "·∫ø"),
    ("oos", "·ªë"),
    // Mark then tone
    ("asa", "·∫•"),
    ("oso", "·ªë"),
];

// ============================================================
// RAPID TYPING PATTERNS
// ============================================================

const TELEX_RAPID: &[(&str, &str)] = &[
    ("ngoafif", "ngo√†i"),
    ("nguwowif", "ng∆∞·ªùi"),
    // Common words typed fast
    ("truwowngf", "tr∆∞·ªùng"),
    ("dduwowcj", "ƒë∆∞·ª£c"),
    ("suwowngs", "s∆∞·ªõng"),
    ("buwowms", "b∆∞·ªõm"),
    ("vieetj", "vi·ªát"),
    ("tieengs", "ti·∫øng"),
    ("muoons", "mu·ªën"),
    ("cuoocj", "cu·ªôc"),
    ("thuoocj", "thu·ªôc"),
];

const VNI_RAPID: &[(&str, &str)] = &[("ngu7o72i2", "ng∆∞·ªùi"), ("to6i1", "t·ªëi")];

// ============================================================
// CAPITALIZATION
// ============================================================

const TELEX_CAPS: &[(&str, &str)] = &[
    ("viEets", "vi·∫æt"),
    ("VIEETJ", "VI·ªÜT"),
    ("VIEETS", "VI·∫æT"),
    ("DDUWOWNGF", "ƒê∆Ø·ªúNG"),
    ("DDUWOWCJ", "ƒê∆Ø·ª¢C"),
    ("TRUWOWNGF", "TR∆Ø·ªúNG"),
    ("NGUWOWIF", "NG∆Ø·ªúI"),
];

const VNI_CAPS: &[(&str, &str)] = &[
    ("VIE65T", "VI·ªÜT"),
    ("D9U7O7NG2", "ƒê∆Ø·ªúNG"),
    ("D9U7O7C5", "ƒê∆Ø·ª¢C"),
    ("TRU7O7NG2", "TR∆Ø·ªúNG"),
];

// ============================================================
// GREETINGS
// ============================================================

const TELEX_GREETINGS: &[(&str, &str)] = &[
    ("xin chaof", "xin ch√†o"),
    ("tamj bieetj", "t·∫°m bi·ªát"),
    ("camr own", "c·∫£m ∆°n"),
    ("xin looxix", "xin l·ªói"),
];

const VNI_GREETINGS: &[(&str, &str)] = &[
    ("xin cha2o", "xin ch√†o"),
    ("ta5m bie65t", "t·∫°m bi·ªát"),
    ("ca3m o7n", "c·∫£m ∆°n"),
];

// ============================================================
// PROVERBS (T·ª§C NG·ªÆ)
// ============================================================

const TELEX_PROVERBS: &[(&str, &str)] = &[
    ("hocj mootj bieets muwowif", "h·ªçc m·ªôt bi·∫øt m∆∞·ªùi"),
    (
        "ddi mootj ngayf ddangf hocj mootj sangf khoon",
        "ƒëi m·ªôt ng√†y ƒë√†ng h·ªçc m·ªôt s√†ng kh√¥n",
    ),
    ("toots goox hown ddepj nguwowif", "t·ªët g·ªó h∆°n ƒë·∫πp ng∆∞·ªùi"),
    ("uoongs nuwowcs nhows nguoonf", "u·ªëng n∆∞·ªõc nh·ªõ ngu·ªìn"),
    ("nuwowcs chayr ddas monf", "n∆∞·ªõc ch·∫£y ƒë√° m√≤n"),
];

const VNI_PROVERBS: &[(&str, &str)] = &[
    ("ho5c mo65t bie61t mu7o7i2", "h·ªçc m·ªôt bi·∫øt m∆∞·ªùi"),
    ("uo61ng nu7o71c nho71 nguo62n", "u·ªëng n∆∞·ªõc nh·ªõ ngu·ªìn"),
    ("to61t go64 ho7n d9e5p ngu7o7i2", "t·ªët g·ªó h∆°n ƒë·∫πp ng∆∞·ªùi"),
    ("nu7o71c cha3y d9a1 mo2n", "n∆∞·ªõc ch·∫£y ƒë√° m√≤n"),
];

// ============================================================
// IDIOMS (TH√ÄNH NG·ªÆ)
// ============================================================

const TELEX_IDIOMS: &[(&str, &str)] = &[
    ("an cuw lacj nghieepj", "an c∆∞ l·∫°c nghi·ªáp"),
    ("ddoongf taam hieepj luwcj", "ƒë·ªìng t√¢m hi·ªáp l·ª±c"),
    ("thowif gian laf tieenf bacj", "th·ªùi gian l√† ti·ªÅn b·∫°c"),
];

// ============================================================
// DAILY CONVERSATIONS
// ============================================================

const TELEX_DAILY: &[(&str, &str)] = &[
    (
        "hoom nay thowif tieets thees naof",
        "h√¥m nay th·ªùi ti·∫øt th·∫ø n√†o",
    ),
    ("banj ddi ddaau vaayj", "b·∫°n ƒëi ƒë√¢u v·∫≠y"),
    ("tooi ddang ddi lafm", "t√¥i ƒëang ƒëi l√†m"),
    ("mootj ly caf phee nhes", "m·ªôt ly c√† ph√™ nh√©"),
    ("bao nhieeu tieenf", "bao nhi√™u ti·ªÅn"),
];

const VNI_DAILY: &[(&str, &str)] = &[
    (
        "ho6m nay tho7i2 tie61t the61 na2o",
        "h√¥m nay th·ªùi ti·∫øt th·∫ø n√†o",
    ),
    ("ba5n d9i d9a6u va65y", "b·∫°n ƒëi ƒë√¢u v·∫≠y"),
    ("bao nhie6u tie62n", "bao nhi√™u ti·ªÅn"),
];

// ============================================================
// FOOD
// ============================================================

const TELEX_FOOD: &[(&str, &str)] = &[
    ("cho tooi xem thuwcj ddown", "cho t√¥i xem th·ª±c ƒë∆°n"),
    (
        "tooi muoons goij mootj phaanf phowr",
        "t√¥i mu·ªën g·ªçi m·ªôt ph·∫ßn ph·ªü",
    ),
    ("ddoof awn raats ngon", "ƒë·ªì ƒÉn r·∫•t ngon"),
    ("tinhs tieenf nhes", "t√≠nh ti·ªÅn nh√©"),
];

// ============================================================
// EXPRESSIONS
// ============================================================

const TELEX_EXPRESSIONS: &[(&str, &str)] = &[
    ("khoong sao", "kh√¥ng sao"),
    ("dduwowcj roofif", "ƒë∆∞·ª£c r·ªìi"),
    ("binhf thuwowngf", "b√¨nh th∆∞·ªùng"),
    ("sao cungx dduwowcj", "sao c≈©ng ƒë∆∞·ª£c"),
    ("tuyeetj vowif", "tuy·ªát v·ªùi"),
    ("ddepj quas", "ƒë·∫πp qu√°"),
];

// ============================================================
// POETRY (TRUY·ªÜN KI·ªÄU)
// ============================================================

const TELEX_POETRY: &[(&str, &str)] = &[
    (
        "trawm nawm trong coix nguwowif ta",
        "trƒÉm nƒÉm trong c√µi ng∆∞·ªùi ta",
    ),
    (
        "chuwx taif chuwx meenhj kheos laf ghets nhau",
        "ch·ªØ t√†i ch·ªØ m·ªánh kh√©o l√† gh√©t nhau",
    ),
];

// ============================================================
// LONG SENTENCES
// ============================================================

const TELEX_LONG: &[(&str, &str)] = &[
    (
        "vieetj nam laf mootj quoocs gia nawmf owr ddoong nam as",
        "vi·ªát nam l√† m·ªôt qu·ªëc gia n·∫±m ·ªü ƒë√¥ng nam √°",
    ),
    (
        "thur ddoo cura vieetj nam laf thanhf phoos haf nooij",
        "th·ªß ƒë√¥ c·ªßa vi·ªát nam l√† th√†nh ph·ªë h√† n·ªôi",
    ),
];

const VNI_LONG: &[(&str, &str)] = &[
    (
        "vie65t nam la2 mo65t quo61c gia na82m o73 d9o6ng nam a1",
        "vi·ªát nam l√† m·ªôt qu·ªëc gia n·∫±m ·ªü ƒë√¥ng nam √°",
    ),
    (
        "thu3 d9o6 cu3a vie65t nam la2 tha2nh pho61 ha2 no65i",
        "th·ªß ƒë√¥ c·ªßa vi·ªát nam l√† th√†nh ph·ªë h√† n·ªôi",
    ),
];

// ============================================================
// MIXED CASE SENTENCES
// ============================================================

const TELEX_MIXED_CASE: &[(&str, &str)] = &[
    ("Xin chaof", "Xin ch√†o"),
    ("Vieetj Nam", "Vi·ªát Nam"),
    ("VIEETJ NAM", "VI·ªÜT NAM"),
    ("Thanhf phoos Hoof Chis Minh", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
];

const VNI_MIXED_CASE: &[(&str, &str)] = &[
    ("Xin cha2o", "Xin ch√†o"),
    ("Vie65t Nam", "Vi·ªát Nam"),
    ("Tha2nh pho61 Ho62 Chi1 Minh", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
];

// ============================================================
// COMMON ISSUES - Real bugs found in production
// ============================================================

const TELEX_COMMON_ISSUES: &[(&str, &str)] = &[
    // Issue 2.1: D√≠nh ch·ªØ (aa -> a√¢ instead of √¢)
    ("aa", "√¢"),
    ("ee", "√™"),
    ("oo", "√¥"),
    ("dd", "ƒë"),
    ("DD", "ƒê"),
    // Issue 2.4: L·∫∑p ch·ªØ (ƒë∆∞·ª£c -> ƒëƒë∆∞·ª£c)
    ("dduwowcj", "ƒë∆∞·ª£c"),
    ("ddif", "ƒë√¨"),
    ("ddi", "ƒëi"),
    ("ddang", "ƒëang"),
    ("ddaauf", "ƒë·∫ßu"),
    // Issue 2.4: M·∫•t d·∫•u (tr∆∞·ªùng -> tr∆∞∆°ng)
    ("truwowngf", "tr∆∞·ªùng"),
    ("dduwowngf", "ƒë∆∞·ªùng"),
    ("nguwowif", "ng∆∞·ªùi"),
    ("muwowif", "m∆∞·ªùi"),
    // Letter vs modifier ambiguity
    ("sa", "sa"),
    ("as", "√°"),
    ("sas", "s√°"),
    ("sass", "sas"),
    ("fa", "fa"),
    ("af", "√†"),
    // Long compound words
    ("nghieeng", "nghi√™ng"),
    ("khuyeens", "khuy·∫øn"),
    ("nguoongf", "ngu·ªìng"),
];

const VNI_COMMON_ISSUES: &[(&str, &str)] = &[
    // Not sticky
    ("a6", "√¢"),
    ("e6", "√™"),
    ("o6", "√¥"),
    ("d9", "ƒë"),
    ("D9", "ƒê"),
    // No double ƒë
    ("d9u7o7c5", "ƒë∆∞·ª£c"),
    ("d9i", "ƒëi"),
    ("d9ang", "ƒëang"),
    // Preserve tone mark
    ("tru7o7ng2", "tr∆∞·ªùng"),
    ("d9u7o7ng2", "ƒë∆∞·ªùng"),
    ("ngu7o7i2", "ng∆∞·ªùi"),
    // Real words with ∆∞∆°
    ("nu7o7c1", "n∆∞·ªõc"),
    ("bu7o7m1", "b∆∞·ªõm"),
    ("su7o7ng1", "s∆∞·ªõng"),
    ("lu7o7ng2", "l∆∞·ªùng"),
    ("thu7o7ng2", "th∆∞·ªùng"),
    ("hu7o7ng1", "h∆∞·ªõng"),
    ("vu7o7n2", "v∆∞·ªùn"),
    // Real words with ua vs qua
    ("mua2", "m√πa"),
    ("chua1", "ch√∫a"),
    ("rua2", "r√πa"),
    ("lua1", "l√∫a"),
    ("su7a4", "s·ªØa"),
    ("qua1", "qu√°"),
    ("qua3", "qu·∫£"),
    ("qua2", "qu√†"),
    // Real words with i√™
    ("vie65t", "vi·ªát"),
    ("tie61ng", "ti·∫øng"),
    ("bie63n", "bi·ªÉn"),
    ("mie61ng", "mi·∫øng"),
    ("die64n", "di·ªÖn"),
    ("kie63m", "ki·ªÉm"),
    ("tie62n", "ti·ªÅn"),
    ("hie63u", "hi·ªÉu"),
    // Mixed common words
    ("co1", "c√≥"),
    ("kho6ng", "kh√¥ng"),
    ("la2", "l√†"),
    ("d9i", "ƒëi"),
    ("ve62", "v·ªÅ"),
    ("a8n", "ƒÉn"),
    ("o6ng1", "·ªëng"),
    ("ba2n", "b√†n"),
    ("nha2", "nh√†"),
    ("hoc5", "h·ªçc"),
];

// ============================================================
// MARK REPOSITIONING - Complex diacritic interactions
// ============================================================

const VNI_MARK_REPOSITION: &[(&str, &str)] = &[
    // ua patterns
    ("ua27", "·ª´a"),
    ("ua2", "√πa"),
    ("ua7", "∆∞a"),
    // oa patterns
    ("oa26", "o·∫ß"),
    ("o6a2", "·ªìa"),
    ("oa2", "o√†"),
    // uo compound with marks
    ("uo71", "∆∞·ªõ"),
    ("uo72", "∆∞·ªù"),
    ("uo73", "∆∞·ªü"),
    ("uo74", "∆∞·ª°"),
    ("uo75", "∆∞·ª£"),
    ("uo17", "∆∞·ªõ"),
    ("uo27", "∆∞·ªù"),
    ("u7o71", "∆∞·ªõ"),
    ("u7o72", "∆∞·ªù"),
    // ua vs qua
    ("ua1", "√∫a"),
    ("ua2", "√πa"),
    ("qua1", "qu√°"),
    ("qua2", "qu√†"),
    ("u7a1", "·ª©a"),
    ("u7a2", "·ª´a"),
    ("ua17", "·ª©a"),
    ("ua27", "·ª´a"),
];

const TELEX_MARK_REPOSITION: &[(&str, &str)] = &[
    ("uafw", "u·∫±"),
    ("uwaf", "·ª´a"),
    ("oafw", "o·∫±"),
    // ∆∞∆° compound
    ("uwows", "∆∞·ªõ"),
    ("uwowf", "∆∞·ªù"),
    ("uwowr", "∆∞·ªü"),
    ("uwowx", "∆∞·ª°"),
    ("uwowj", "∆∞·ª£"),
    ("uows", "∆∞·ªõ"),
    ("uowf", "∆∞·ªù"),
    // Real words
    ("nuwowcs", "n∆∞·ªõc"),
    ("buwowms", "b∆∞·ªõm"),
    ("suwowngs", "s∆∞·ªõng"),
    ("luwowngf", "l∆∞·ªùng"),
    ("dduwowngf", "ƒë∆∞·ªùng"),
    ("truwowngf", "tr∆∞·ªùng"),
    ("thuwowngf", "th∆∞·ªùng"),
    ("huwowngs", "h∆∞·ªõng"),
    ("vuwownf", "v∆∞·ªùn"),
    // ua vs qua
    ("muaf", "m√πa"),
    ("chuas", "ch√∫a"),
    ("ruaf", "r√πa"),
    ("luas", "l√∫a"),
    ("suwax", "s·ªØa"),
    ("quas", "qu√°"),
    ("quar", "qu·∫£"),
    ("quaf", "qu√†"),
    // i√™ words
    ("vieetj", "vi·ªát"),
    ("tieengs", "ti·∫øng"),
    ("bieenr", "bi·ªÉn"),
    ("mieengs", "mi·∫øng"),
    ("dieenx", "di·ªÖn"),
    ("kieemr", "ki·ªÉm"),
    ("tieenf", "ti·ªÅn"),
    ("hieeur", "hi·ªÉu"),
];

// ============================================================
// DELAYED INPUT PATTERNS
// ============================================================

const TELEX_DELAYED_PATTERNS: &[(&str, &str)] = &[
    ("tungw", "t∆∞ng"),
    ("tongw", "t∆°ng"),
    ("tangw", "tƒÉng"),
    ("tuow", "t∆∞∆°"),
    ("nguoiw", "ng∆∞∆°i"),
];

const VNI_DELAYED_PATTERNS: &[(&str, &str)] = &[
    ("tung7", "t∆∞ng"),
    ("tong7", "t∆°ng"),
    ("tang8", "tƒÉng"),
    ("dung9", "ƒëung"),
    ("Dung9", "ƒêung"),
];

// ============================================================
// TEST FUNCTIONS
// ============================================================

#[test]
fn telex_backspace() {
    telex(TELEX_BACKSPACE);
}

#[test]
fn vni_backspace() {
    vni(VNI_BACKSPACE);
}

#[test]
fn telex_typos() {
    telex(TELEX_TYPOS);
}

#[test]
fn telex_rapid_typing() {
    telex(TELEX_RAPID);
}

#[test]
fn vni_rapid_typing() {
    vni(VNI_RAPID);
}

#[test]
fn telex_capitalization() {
    telex(TELEX_CAPS);
}

#[test]
fn vni_capitalization() {
    vni(VNI_CAPS);
}

#[test]
fn telex_greetings() {
    telex(TELEX_GREETINGS);
}

#[test]
fn vni_greetings() {
    vni(VNI_GREETINGS);
}

#[test]
fn telex_proverbs() {
    telex(TELEX_PROVERBS);
}

#[test]
fn vni_proverbs() {
    vni(VNI_PROVERBS);
}

#[test]
fn telex_idioms() {
    telex(TELEX_IDIOMS);
}

#[test]
fn telex_daily_conversations() {
    telex(TELEX_DAILY);
}

#[test]
fn vni_daily_conversations() {
    vni(VNI_DAILY);
}

#[test]
fn telex_food() {
    telex(TELEX_FOOD);
}

#[test]
fn telex_expressions() {
    telex(TELEX_EXPRESSIONS);
}

#[test]
fn telex_poetry() {
    telex(TELEX_POETRY);
}

#[test]
fn telex_long_sentences() {
    telex(TELEX_LONG);
}

#[test]
fn vni_long_sentences() {
    vni(VNI_LONG);
}

#[test]
fn telex_mixed_case() {
    telex(TELEX_MIXED_CASE);
}

#[test]
fn vni_mixed_case() {
    vni(VNI_MIXED_CASE);
}

#[test]
fn telex_common_issues() {
    telex(TELEX_COMMON_ISSUES);
}

#[test]
fn vni_common_issues() {
    vni(VNI_COMMON_ISSUES);
}

#[test]
fn vni_mark_repositioning() {
    vni(VNI_MARK_REPOSITION);
}

#[test]
fn telex_mark_repositioning() {
    telex(TELEX_MARK_REPOSITION);
}

#[test]
fn telex_delayed_patterns() {
    telex(TELEX_DELAYED_PATTERNS);
}

#[test]
fn vni_delayed_patterns() {
    vni(VNI_DELAYED_PATTERNS);
}
</file>

<file path="platforms/macos/GoNhanh.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		A1000001000000000000001 /* App.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000001 /* App.swift */; };
		A1000001000000000000002 /* MenuBar.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000002 /* MenuBar.swift */; };
		A1000001000000000000003 /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000003 /* SettingsView.swift */; };
		A1000001000000000000004 /* RustBridge.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000004 /* RustBridge.swift */; };
		A1000001000000000000005 /* libgonhanh_core.a in Frameworks */ = {isa = PBXBuildFile; fileRef = A1000002000000000000005 /* libgonhanh_core.a */; };
		A1000001000000000000007 /* AppMetadata.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000007 /* AppMetadata.swift */; };
		A1000001000000000000008 /* OnboardingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000008 /* OnboardingView.swift */; };
		A1000001000000000000009 /* AboutView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A1000002000000000000009 /* AboutView.swift */; };
		A100000100000000000000A /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = A100000200000000000000A /* Assets.xcassets */; };
		A100000100000000000000B /* UpdateManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = A100000200000000000000B /* UpdateManager.swift */; };
		A100000100000000000000C /* UpdateChecker.swift in Sources */ = {isa = PBXBuildFile; fileRef = A100000200000000000000C /* UpdateChecker.swift */; };
		A100000100000000000000D /* LaunchAtLogin.swift in Sources */ = {isa = PBXBuildFile; fileRef = A100000200000000000000D /* LaunchAtLogin.swift */; };
		A100000100000000000000E /* UpdateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A100000200000000000000E /* UpdateView.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		A1000002000000000000001 /* App.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = App.swift; sourceTree = "<group>"; };
		A1000002000000000000002 /* MenuBar.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MenuBar.swift; sourceTree = "<group>"; };
		A1000002000000000000003 /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
		A1000002000000000000004 /* RustBridge.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RustBridge.swift; sourceTree = "<group>"; };
		A1000002000000000000005 /* libgonhanh_core.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libgonhanh_core.a; sourceTree = "<group>"; };
		A1000002000000000000006 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		A1000002000000000000007 /* AppMetadata.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppMetadata.swift; sourceTree = "<group>"; };
		A1000002000000000000008 /* OnboardingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingView.swift; sourceTree = "<group>"; };
		A1000002000000000000009 /* AboutView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AboutView.swift; sourceTree = "<group>"; };
		A100000200000000000000A /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		A100000200000000000000B /* UpdateManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UpdateManager.swift; sourceTree = "<group>"; };
		A100000200000000000000C /* UpdateChecker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UpdateChecker.swift; sourceTree = "<group>"; };
		A100000200000000000000D /* LaunchAtLogin.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LaunchAtLogin.swift; sourceTree = "<group>"; };
		A100000200000000000000E /* UpdateView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UpdateView.swift; sourceTree = "<group>"; };
		A1000003000000000000001 /* GoNhanh.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = GoNhanh.app; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		A1000004000000000000001 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A1000001000000000000005 /* libgonhanh_core.a in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		A1000005000000000000001 = {
			isa = PBXGroup;
			children = (
				A1000002000000000000007 /* AppMetadata.swift */,
				A1000002000000000000001 /* App.swift */,
				A1000002000000000000002 /* MenuBar.swift */,
				A1000002000000000000003 /* SettingsView.swift */,
				A1000002000000000000008 /* OnboardingView.swift */,
				A1000002000000000000009 /* AboutView.swift */,
				A1000002000000000000004 /* RustBridge.swift */,
				A100000200000000000000B /* UpdateManager.swift */,
				A100000200000000000000C /* UpdateChecker.swift */,
				A100000200000000000000D /* LaunchAtLogin.swift */,
				A100000200000000000000E /* UpdateView.swift */,
				A1000002000000000000005 /* libgonhanh_core.a */,
				A1000002000000000000006 /* Info.plist */,
				A100000200000000000000A /* Assets.xcassets */,
				A1000005000000000000002 /* Products */,
			);
			sourceTree = "<group>";
		};
		A1000005000000000000002 /* Products */ = {
			isa = PBXGroup;
			children = (
				A1000003000000000000001 /* GoNhanh.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		A1000006000000000000001 /* GoNhanh */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = A1000007000000000000001 /* Build configuration list for PBXNativeTarget "GoNhanh" */;
			buildPhases = (
				A1000008000000000000001 /* Sources */,
				A1000004000000000000001 /* Frameworks */,
				A1000009000000000000001 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = GoNhanh;
			productName = GoNhanh;
			productReference = A1000003000000000000001 /* GoNhanh.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		A1000010000000000000001 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1500;
				LastUpgradeCheck = 1500;
				TargetAttributes = {
					A1000006000000000000001 = {
						CreatedOnToolsVersion = 15.0;
					};
				};
			};
			buildConfigurationList = A1000011000000000000001 /* Build configuration list for PBXProject "GoNhanh" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = A1000005000000000000001;
			productRefGroup = A1000005000000000000002 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				A1000006000000000000001 /* GoNhanh */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		A1000009000000000000001 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A100000100000000000000A /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		A1000008000000000000001 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A1000001000000000000007 /* AppMetadata.swift in Sources */,
				A1000001000000000000001 /* App.swift in Sources */,
				A1000001000000000000002 /* MenuBar.swift in Sources */,
				A1000001000000000000003 /* SettingsView.swift in Sources */,
				A1000001000000000000008 /* OnboardingView.swift in Sources */,
				A1000001000000000000009 /* AboutView.swift in Sources */,
				A1000001000000000000004 /* RustBridge.swift in Sources */,
				A100000100000000000000B /* UpdateManager.swift in Sources */,
				A100000100000000000000C /* UpdateChecker.swift in Sources */,
				A100000100000000000000D /* LaunchAtLogin.swift in Sources */,
				A100000100000000000000E /* UpdateView.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		A1000012000000000000001 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		A1000012000000000000002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
			};
			name = Release;
		};
		A1000013000000000000001 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_ENTITLEMENTS = "";
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = "";
				ENABLE_HARDENED_RUNTIME = YES;
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = Info.plist;
				INFOPLIST_KEY_LSUIElement = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "Copyright ¬© 2025 GoNhanh Contributors. All rights reserved.";
				INFOPLIST_KEY_NSPrincipalClass = NSApplication;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)",
				);
				MARKETING_VERSION = 0.1.0;
				OTHER_LDFLAGS = (
					"-framework",
					Foundation,
					"-framework",
					AppKit,
					"-framework",
					SwiftUI,
					"-framework",
					Carbon,
				);
				PRODUCT_BUNDLE_IDENTIFIER = org.gonhanh.GoNhanh;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		A1000013000000000000002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_ENTITLEMENTS = "";
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = "";
				ENABLE_HARDENED_RUNTIME = YES;
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = Info.plist;
				INFOPLIST_KEY_LSUIElement = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "Copyright ¬© 2025 GoNhanh Contributors. All rights reserved.";
				INFOPLIST_KEY_NSPrincipalClass = NSApplication;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)",
				);
				MARKETING_VERSION = 0.1.0;
				OTHER_LDFLAGS = (
					"-framework",
					Foundation,
					"-framework",
					AppKit,
					"-framework",
					SwiftUI,
					"-framework",
					Carbon,
				);
				PRODUCT_BUNDLE_IDENTIFIER = org.gonhanh.GoNhanh;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		A1000007000000000000001 /* Build configuration list for PBXNativeTarget "GoNhanh" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				A1000013000000000000001 /* Debug */,
				A1000013000000000000002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		A1000011000000000000001 /* Build configuration list for PBXProject "GoNhanh" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				A1000012000000000000001 /* Debug */,
				A1000012000000000000002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = A1000010000000000000001 /* Project object */;
}
</file>

<file path="platforms/macos/Tests/LaunchAtLoginTests.swift">
import XCTest
@testable import GoNhanh

// MARK: - Launch at Login Tests

final class LaunchAtLoginTests: XCTestCase {

    var mock: MockLaunchAtLoginManager!

    override func setUp() {
        super.setUp()
        mock = MockLaunchAtLoginManager()
    }

    override func tearDown() {
        mock.reset()
        super.tearDown()
    }

    // MARK: - Initial State

    func testInitialStateIsDisabled() {
        XCTAssertFalse(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 0)
        XCTAssertEqual(mock.disableCallCount, 0)
    }

    // MARK: - Enable Tests

    func testEnableSuccess() throws {
        try mock.enable()

        XCTAssertTrue(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 1)
    }

    func testEnableMultipleTimes() throws {
        try mock.enable()
        try mock.enable()
        try mock.enable()

        XCTAssertTrue(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 3)
    }

    func testEnableThrowsError() {
        mock.shouldThrowOnEnable = true

        XCTAssertThrowsError(try mock.enable()) { error in
            XCTAssertEqual(error as? LaunchAtLoginError, .registrationFailed)
        }
        XCTAssertFalse(mock.isEnabled)
    }

    // MARK: - Disable Tests

    func testDisableSuccess() throws {
        try mock.enable()
        try mock.disable()

        XCTAssertFalse(mock.isEnabled)
        XCTAssertEqual(mock.disableCallCount, 1)
    }

    func testDisableWhenAlreadyDisabled() throws {
        try mock.disable()

        XCTAssertFalse(mock.isEnabled)
        XCTAssertEqual(mock.disableCallCount, 1)
    }

    func testDisableThrowsError() throws {
        try mock.enable()
        mock.shouldThrowOnDisable = true

        XCTAssertThrowsError(try mock.disable()) { error in
            XCTAssertEqual(error as? LaunchAtLoginError, .unregistrationFailed)
        }
        // State should remain enabled on error
        XCTAssertTrue(mock.isEnabled)
    }

    // MARK: - Toggle Tests

    func testToggleOnOff() throws {
        // Off ‚Üí On
        try mock.enable()
        XCTAssertTrue(mock.isEnabled)

        // On ‚Üí Off
        try mock.disable()
        XCTAssertFalse(mock.isEnabled)

        // Off ‚Üí On again
        try mock.enable()
        XCTAssertTrue(mock.isEnabled)
    }

    // MARK: - Reset Tests

    func testResetClearsState() throws {
        try mock.enable()
        mock.shouldThrowOnDisable = true

        mock.reset()

        XCTAssertFalse(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 0)
        XCTAssertEqual(mock.disableCallCount, 0)
        XCTAssertFalse(mock.shouldThrowOnEnable)
        XCTAssertFalse(mock.shouldThrowOnDisable)
    }
}

// MARK: - UserDefaults Integration Tests

final class LaunchAtLoginUserDefaultsTests: XCTestCase {

    let testKey = "testLaunchAtLogin"

    override func tearDown() {
        UserDefaults.standard.removeObject(forKey: testKey)
        UserDefaults.standard.removeObject(forKey: LaunchAtLoginManager.userDefaultsKey)
        super.tearDown()
    }

    func testCachedStateDefaultsToFalse() {
        UserDefaults.standard.removeObject(forKey: LaunchAtLoginManager.userDefaultsKey)
        let manager = LaunchAtLoginManager.shared
        // Note: cachedState reads from UserDefaults, not SMAppService
        // This test verifies the fallback behavior
        XCTAssertFalse(UserDefaults.standard.bool(forKey: LaunchAtLoginManager.userDefaultsKey))
    }

    func testSyncWritesToUserDefaults() {
        // This test requires actual SMAppService which may not work in test environment
        // So we just verify the key exists
        XCTAssertNotNil(LaunchAtLoginManager.userDefaultsKey)
    }
}

// MARK: - Onboarding Flow Tests

final class OnboardingLaunchAtLoginTests: XCTestCase {

    var mock: MockLaunchAtLoginManager!

    override func setUp() {
        super.setUp()
        mock = MockLaunchAtLoginManager()
    }

    func testOnboardingEnablesLaunchAtLogin() throws {
        // Simulate onboarding completion
        simulateOnboardingComplete()

        XCTAssertTrue(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 1)
    }

    func testOnboardingHandlesEnableError() {
        mock.shouldThrowOnEnable = true

        // Should not crash, just log error
        simulateOnboardingComplete()

        XCTAssertFalse(mock.isEnabled)
        XCTAssertEqual(mock.enableCallCount, 1)
    }

    private func simulateOnboardingComplete() {
        do {
            try mock.enable()
        } catch {
            // Log error (matches actual behavior in MenuBar.swift)
            print("[LaunchAtLogin] Error: \(error)")
        }
    }
}

// MARK: - App Restart Behavior Tests

final class AppRestartTests: XCTestCase {

    func testAppStartsWithPreviousState() {
        // Test scenario: App was enabled, user restarts Mac
        // Expected: App should start automatically

        // This is more of a documentation test - actual behavior
        // depends on SMAppService which requires real app bundle

        // We can verify the logic flow:
        // 1. On first launch after onboarding: enable() is called
        // 2. On subsequent launches: SMAppService handles auto-start
        // 3. isEnabled property reflects current state

        let mock = MockLaunchAtLoginManager()

        // Simulate first launch
        try? mock.enable()
        XCTAssertTrue(mock.isEnabled)

        // Simulate "restart" - create new instance but preserve state
        // In real app, SMAppService persists this across restarts
        // Mock simulates this by keeping isEnabled = true
        XCTAssertTrue(mock.isEnabled)
    }

    func testDisabledAppDoesNotAutoStart() throws {
        let mock = MockLaunchAtLoginManager()

        // User explicitly disabled launch at login
        try mock.enable()
        try mock.disable()

        XCTAssertFalse(mock.isEnabled)
        // On next "restart", app should NOT auto-start
        // (SMAppService respects this setting)
    }
}

// MARK: - Status Description Tests

final class LaunchAtLoginStatusTests: XCTestCase {

    func testStatusDescriptionValues() {
        let manager = LaunchAtLoginManager.shared

        // Status should be one of the known values
        let validStatuses = ["enabled", "notFound", "notRegistered", "requiresApproval", "unknown", "unsupported"]
        XCTAssertTrue(validStatuses.contains(manager.statusDescription))
    }
}
</file>

<file path="platforms/macos/OnboardingView.swift">
import SwiftUI

struct OnboardingView: View {
    @Environment(\.colorScheme) private var colorScheme
    @State private var step = 0
    @State private var hasPermission = false
    @State private var selectedMode: InputMode = .telex

    private let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    private var totalSteps: Int { step >= 10 ? 2 : 3 }
    private var stepIndex: Int { step >= 10 ? step - 10 : step }

    var body: some View {
        VStack(spacing: 0) {
            content.frame(height: 320)
            Divider()
            footer
        }
        .frame(width: 440)
        .onAppear {
            hasPermission = AXIsProcessTrusted()
            if UserDefaults.standard.bool(forKey: SettingsKey.permissionGranted) && hasPermission {
                step = 10
            }
        }
        .onReceive(timer) { _ in
            hasPermission = AXIsProcessTrusted()
            if step == 1 && hasPermission { step = 2 }
        }
    }

    @ViewBuilder
    private var content: some View {
        switch step {
        case 0:  WelcomeStep()
        case 1:  PermissionStep()
        case 2:  ReadyStep()
        case 10: SuccessStep()
        case 11: SetupStep(selectedMode: $selectedMode)
        default: EmptyView()
        }
    }

    private var footer: some View {
        HStack {
            HStack(spacing: 6) {
                ForEach(0..<totalSteps, id: \.self) { i in
                    Circle()
                        .fill(i == stepIndex ? Color.accentColor : Color.secondary.opacity(0.3))
                        .frame(width: 6, height: 6)
                }
            }
            Spacer()
            if step == 1 {
                Button("Quay l·∫°i") { step = 0 }
            }
            primaryButton
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
    }

    @ViewBuilder
    private var primaryButton: some View {
        switch step {
        case 0:  Button("Ti·∫øp t·ª•c") { step = 1 }.buttonStyle(.borderedProminent)
        case 1:  Button("M·ªü C√†i ƒë·∫∑t") { openSettings() }.buttonStyle(.borderedProminent)
        case 2:  Button("Kh·ªüi ƒë·ªông l·∫°i") { restart() }.buttonStyle(.borderedProminent)
        case 10: Button("Ti·∫øp t·ª•c") { step = 11 }.buttonStyle(.borderedProminent)
        case 11: Button("Ho√†n t·∫•t") { finish() }.buttonStyle(.borderedProminent)
        default: EmptyView()
        }
    }

    private func openSettings() {
        NSWorkspace.shared.open(URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")!)
    }

    private func restart() {
        UserDefaults.standard.set(selectedMode.rawValue, forKey: SettingsKey.method)
        UserDefaults.standard.set(true, forKey: SettingsKey.permissionGranted)
        UserDefaults.standard.set(false, forKey: SettingsKey.hasCompletedOnboarding)
        let task = Process()
        task.launchPath = "/bin/sh"
        task.arguments = ["-c", "sleep 0.5 && open \"\(Bundle.main.bundlePath)\""]
        try? task.run()
        NSApp.terminate(nil)
    }

    private func finish() {
        UserDefaults.standard.set(selectedMode.rawValue, forKey: SettingsKey.method)
        UserDefaults.standard.set(true, forKey: SettingsKey.hasCompletedOnboarding)
        NotificationCenter.default.post(name: .onboardingCompleted, object: nil)
        NSApp.keyWindow?.close()
    }
}

// MARK: - Steps

private struct WelcomeStep: View {
    var body: some View {
        StepLayout {
            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 80, height: 80)

            Text("Ch√†o m·ª´ng ƒë·∫øn v·ªõi \(AppMetadata.name)")
                .font(.title2.bold())

            Text(AppMetadata.tagline)
                .foregroundStyle(.secondary)
        }
    }
}

private struct PermissionStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "hand.raised.fill")
                .font(.system(size: 40))
                .foregroundStyle(.orange)

            Text("C·∫•p quy·ªÅn Accessibility")
                .font(.title2.bold())

            Text("B·∫≠t \(AppMetadata.name) trong System Settings ƒë·ªÉ g√µ ti·∫øng Vi·ªát.")
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)

            VStack(alignment: .leading, spacing: 8) {
                Label("M·ªü Privacy & Security ‚Üí Accessibility", systemImage: "1.circle.fill")
                Label("B·∫≠t c√¥ng t·∫Øc b√™n c·∫°nh \(AppMetadata.name)", systemImage: "2.circle.fill")
            }
            .font(.callout)
            .foregroundStyle(.secondary)
            .padding(.top, 4)
        }
    }
}

private struct ReadyStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "checkmark.shield.fill")
                .font(.system(size: 40))
                .foregroundStyle(.green)

            Text("ƒê√£ c·∫•p quy·ªÅn")
                .font(.title2.bold())

            Text("Nh·∫•n \"Kh·ªüi ƒë·ªông l·∫°i\" ƒë·ªÉ √°p d·ª•ng.")
                .foregroundStyle(.secondary)
        }
    }
}

private struct SuccessStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "checkmark.circle.fill")
                .font(.system(size: 48))
                .foregroundStyle(.green)

            Text("S·∫µn s√†ng ho·∫°t ƒë·ªông")
                .font(.title2.bold())

            Text("\(AppMetadata.name) ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn th√†nh c√¥ng.")
                .foregroundStyle(.secondary)
        }
    }
}

private struct SetupStep: View {
    @Binding var selectedMode: InputMode

    var body: some View {
        StepLayout {
            Image(systemName: "keyboard")
                .font(.system(size: 40))
                .foregroundStyle(.blue)

            Text("Ch·ªçn ki·ªÉu g√µ")
                .font(.title2.bold())

            Text("C√≥ th·ªÉ thay ƒë·ªïi sau trong menu.")
                .foregroundStyle(.secondary)

            VStack(spacing: 8) {
                ForEach(InputMode.allCases, id: \.rawValue) { mode in
                    ModeOption(mode: mode, isSelected: selectedMode == mode) {
                        selectedMode = mode
                    }
                }
            }
            .frame(maxWidth: 260)
            .padding(.top, 8)
        }
    }
}

private struct ModeOption: View {
    let mode: InputMode
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                VStack(alignment: .leading, spacing: 2) {
                    Text(mode.name)
                        .font(.headline)
                    Text(mode.description)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                Spacer()
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .font(.system(size: 20))
                    .foregroundStyle(isSelected ? Color.accentColor : Color.secondary.opacity(0.4))
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 10)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isSelected ? Color.accentColor.opacity(0.1) : Color.secondary.opacity(0.05))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(isSelected ? Color.accentColor.opacity(0.5) : .clear, lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Components

private struct StepLayout<Content: View>: View {
    @ViewBuilder let content: Content

    var body: some View {
        VStack(spacing: 12) {
            Spacer()
            content
            Spacer()
        }
        .padding(.horizontal, 40)
    }
}

// MARK: - Notification

extension Notification.Name {
    static let onboardingCompleted = Notification.Name("onboardingCompleted")
}
</file>

<file path="platforms/macos/UpdateChecker.swift">
import Foundation

// MARK: - FFI for Version Comparison

@_silgen_name("version_compare")
func version_compare(_ v1: UnsafePointer<CChar>?, _ v2: UnsafePointer<CChar>?) -> Int32

@_silgen_name("version_has_update")
func version_has_update(_ current: UnsafePointer<CChar>?, _ latest: UnsafePointer<CChar>?) -> Int32

// MARK: - Update Info

struct UpdateInfo {
    let version: String
    let downloadURL: URL
    let releaseNotes: String
    let publishedAt: Date?
}

// MARK: - Update Check Result

enum UpdateCheckResult {
    case available(UpdateInfo)
    case upToDate
    case error(String)
}

// MARK: - Update Checker

class UpdateChecker {
    static let shared = UpdateChecker()

    private let githubAPIURL = "https://api.github.com/repos/khaphanspace/gonhanh.org/releases/latest"
    private let downloadBaseURL = "https://github.com/khaphanspace/gonhanh.org/releases/latest/download"

    private init() {}

    /// Check for updates asynchronously
    func checkForUpdates(completion: @escaping (UpdateCheckResult) -> Void) {
        guard let url = URL(string: githubAPIURL) else {
            completion(.error("Invalid API URL"))
            return
        }

        var request = URLRequest(url: url)
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.timeoutInterval = 10

        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            if let error = error {
                DispatchQueue.main.async {
                    completion(.error("Network error: \(error.localizedDescription)"))
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                DispatchQueue.main.async {
                    completion(.error("Invalid response"))
                }
                return
            }

            guard httpResponse.statusCode == 200 else {
                DispatchQueue.main.async {
                    completion(.error("Server error: \(httpResponse.statusCode)"))
                }
                return
            }

            guard let data = data else {
                DispatchQueue.main.async {
                    completion(.error("No data received"))
                }
                return
            }

            self?.parseResponse(data: data, completion: completion)
        }

        task.resume()
    }

    private func parseResponse(data: Data, completion: @escaping (UpdateCheckResult) -> Void) {
        do {
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                DispatchQueue.main.async {
                    completion(.error("Invalid JSON format"))
                }
                return
            }

            // Extract version from tag_name (e.g., "v1.0.10" -> "1.0.10")
            guard let tagName = json["tag_name"] as? String else {
                DispatchQueue.main.async {
                    completion(.error("Missing version tag"))
                }
                return
            }

            let latestVersion = tagName.hasPrefix("v") ? String(tagName.dropFirst()) : tagName
            let currentVersion = AppMetadata.version

            // Use Rust core for version comparison
            let hasUpdate = currentVersion.withCString { currentPtr in
                latestVersion.withCString { latestPtr in
                    version_has_update(currentPtr, latestPtr)
                }
            }

            if hasUpdate == 1 {
                // Parse additional info
                let releaseNotes = json["body"] as? String ?? ""
                let htmlURL = json["html_url"] as? String ?? ""

                // Find DMG download URL from assets
                var downloadURL: URL?
                if let assets = json["assets"] as? [[String: Any]] {
                    for asset in assets {
                        if let name = asset["name"] as? String,
                           name.lowercased().hasSuffix(".dmg"),
                           let urlString = asset["browser_download_url"] as? String,
                           let url = URL(string: urlString) {
                            downloadURL = url
                            break
                        }
                    }
                }

                // Fallback to default download URL
                let finalDownloadURL = downloadURL ?? URL(string: "\(downloadBaseURL)/GoNhanh.dmg")!

                // Parse published date
                var publishedAt: Date?
                if let publishedString = json["published_at"] as? String {
                    let formatter = ISO8601DateFormatter()
                    publishedAt = formatter.date(from: publishedString)
                }

                let updateInfo = UpdateInfo(
                    version: latestVersion,
                    downloadURL: finalDownloadURL,
                    releaseNotes: releaseNotes,
                    publishedAt: publishedAt
                )

                DispatchQueue.main.async {
                    completion(.available(updateInfo))
                }
            } else {
                DispatchQueue.main.async {
                    completion(.upToDate)
                }
            }

        } catch {
            DispatchQueue.main.async {
                completion(.error("JSON parse error: \(error.localizedDescription)"))
            }
        }
    }

    /// Compare two version strings using Rust core
    /// Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2
    func compareVersions(_ v1: String, _ v2: String) -> Int {
        return v1.withCString { v1Ptr in
            v2.withCString { v2Ptr in
                Int(version_compare(v1Ptr, v2Ptr))
            }
        }
    }
}
</file>

<file path="platforms/windows/GoNhanh/Core/AppMetadata.cs">
using System.Reflection;

namespace GoNhanh.Core;

/// <summary>
/// Centralized app metadata - matches macOS AppMetadata.swift
/// All project metadata in one place for consistency
/// </summary>
public static class AppMetadata
{
    // App Info
    public static readonly string Name = "GoNhanh";
    public static readonly string DisplayName = "GoNhanh - G√µ Nhanh";
    public static readonly string Tagline = "B·ªô g√µ ti·∫øng Vi·ªát hi·ªáu su·∫•t cao";

    // Version
    public static string Version
    {
        get
        {
            var version = Assembly.GetExecutingAssembly().GetName().Version;
            return $"{version?.Major ?? 1}.{version?.Minor ?? 0}.{version?.Build ?? 0}";
        }
    }

    // Author
    public static readonly string Author = "Kha Phan";
    public static readonly string AuthorEmail = "nhatkha1407@gmail.com";
    public static readonly string AuthorLinkedin = "https://www.linkedin.com/in/khaphanspace";

    // Links
    public static readonly string Website = "https://gonhanh.org";
    public static readonly string Repository = "https://github.com/khaphanspace/gonhanh.org";
    public static readonly string IssuesUrl = "https://github.com/khaphanspace/gonhanh.org/issues";

    // Legal
    public static readonly string Copyright = $"Copyright (c) 2025 {Author}. All rights reserved.";
    public static readonly string License = "GPL-3.0-or-later";

    // Tech
    public static readonly string TechStack = "Rust + WPF";
}

/// <summary>
/// Input method descriptions - matches macOS InputMode
/// </summary>
public static class InputMethodInfo
{
    public static string GetName(InputMethod method) => method switch
    {
        InputMethod.Telex => "Telex",
        InputMethod.VNI => "VNI",
        _ => "Unknown"
    };

    public static string GetShortName(InputMethod method) => method switch
    {
        InputMethod.Telex => "T",
        InputMethod.VNI => "V",
        _ => "?"
    };

    public static string GetDescription(InputMethod method) => method switch
    {
        InputMethod.Telex => "aw, ow, w, s, f, r, x, j",
        InputMethod.VNI => "a8, o9, 1-5",
        _ => ""
    };

    public static string GetFullDescription(InputMethod method) => method switch
    {
        InputMethod.Telex => $"Telex ({GetDescription(method)})",
        InputMethod.VNI => $"VNI ({GetDescription(method)})",
        _ => ""
    };
}
</file>

<file path="platforms/windows/GoNhanh/Core/KeyboardHook.cs">
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace GoNhanh.Core;

/// <summary>
/// Low-level Windows keyboard hook for system-wide key interception
/// Similar to CGEventTap on macOS
/// </summary>
public class KeyboardHook : IDisposable
{
    #region Win32 Constants

    private const int WH_KEYBOARD_LL = 13;
    private const int WM_KEYDOWN = 0x0100;
    private const int WM_SYSKEYDOWN = 0x0104;
    private const uint LLKHF_INJECTED = 0x10;

    #endregion

    #region Win32 Imports

    private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("user32.dll")]
    private static extern short GetKeyState(int nVirtKey);

    [DllImport("user32.dll")]
    private static extern short GetAsyncKeyState(int vKey);

    #endregion

    #region Structures

    [StructLayout(LayoutKind.Sequential)]
    private struct KBDLLHOOKSTRUCT
    {
        public uint vkCode;
        public uint scanCode;
        public uint flags;
        public uint time;
        public IntPtr dwExtraInfo;
    }

    #endregion

    #region Fields

    private LowLevelKeyboardProc? _proc;
    private IntPtr _hookId = IntPtr.Zero;
    private bool _disposed;

    // Flag to prevent recursive processing of injected keys
    private bool _isProcessing;

    // Identifier for our injected keys (to skip processing them)
    private static readonly IntPtr InjectedKeyMarker = new IntPtr(0x474E4820); // "GNH " in hex

    #endregion

    #region Events

    public event EventHandler<KeyPressedEventArgs>? KeyPressed;

    #endregion

    #region Public Methods

    /// <summary>
    /// Start the keyboard hook
    /// </summary>
    public void Start()
    {
        if (_hookId != IntPtr.Zero) return;

        _proc = HookCallback;
        using var curProcess = Process.GetCurrentProcess();
        using var curModule = curProcess.MainModule!;

        _hookId = SetWindowsHookEx(
            WH_KEYBOARD_LL,
            _proc,
            GetModuleHandle(curModule.ModuleName!),
            0);

        if (_hookId == IntPtr.Zero)
        {
            int error = Marshal.GetLastWin32Error();
            throw new System.ComponentModel.Win32Exception(error, $"Failed to install keyboard hook. Error: {error}");
        }
    }

    /// <summary>
    /// Stop the keyboard hook
    /// </summary>
    public void Stop()
    {
        if (_hookId != IntPtr.Zero)
        {
            UnhookWindowsHookEx(_hookId);
            _hookId = IntPtr.Zero;
        }
    }

    #endregion

    #region Private Methods

    private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
    {
        // Don't process if already processing (prevents recursion)
        if (_isProcessing)
        {
            return CallNextHookEx(_hookId, nCode, wParam, lParam);
        }

        // Only process key down events
        if (nCode >= 0 && (wParam == (IntPtr)WM_KEYDOWN || wParam == (IntPtr)WM_SYSKEYDOWN))
        {
            var hookStruct = Marshal.PtrToStructure<KBDLLHOOKSTRUCT>(lParam);

            // Skip our own injected keys
            if (hookStruct.dwExtraInfo == InjectedKeyMarker)
            {
                return CallNextHookEx(_hookId, nCode, wParam, lParam);
            }

            // Skip injected keys from other sources (optional, for safety)
            if ((hookStruct.flags & LLKHF_INJECTED) != 0)
            {
                return CallNextHookEx(_hookId, nCode, wParam, lParam);
            }

            ushort keyCode = (ushort)hookStruct.vkCode;

            // Only process relevant keys for Vietnamese input
            if (KeyCodes.IsRelevantKey(keyCode))
            {
                bool shift = IsKeyDown(KeyCodes.VK_SHIFT);
                bool capsLock = IsCapsLockOn();
                bool ctrl = IsKeyDown(KeyCodes.VK_CONTROL);
                bool alt = IsKeyDown(KeyCodes.VK_MENU);

                // Skip if Ctrl or Alt is pressed (shortcuts)
                if (ctrl || alt)
                {
                    // Clear buffer on Ctrl+key combinations
                    if (ctrl)
                    {
                        RustBridge.Clear();
                    }
                    return CallNextHookEx(_hookId, nCode, wParam, lParam);
                }

                // Handle buffer-clearing keys
                if (KeyCodes.IsBufferClearKey(keyCode))
                {
                    RustBridge.Clear();
                    return CallNextHookEx(_hookId, nCode, wParam, lParam);
                }

                // Process the key through IME
                var args = new KeyPressedEventArgs(keyCode, shift, capsLock);

                try
                {
                    _isProcessing = true;
                    KeyPressed?.Invoke(this, args);
                }
                finally
                {
                    _isProcessing = false;
                }

                // Block the original key if handled
                if (args.Handled)
                {
                    return (IntPtr)1;
                }
            }
        }

        return CallNextHookEx(_hookId, nCode, wParam, lParam);
    }

    private static bool IsKeyDown(int vKey)
    {
        return (GetAsyncKeyState(vKey) & 0x8000) != 0;
    }

    private static bool IsCapsLockOn()
    {
        return (GetKeyState(KeyCodes.VK_CAPITAL) & 0x0001) != 0;
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            Stop();
            _disposed = true;
        }
    }

    ~KeyboardHook()
    {
        Dispose(false);
    }

    #endregion

    /// <summary>
    /// Get the marker used to identify injected keys from this application
    /// </summary>
    public static IntPtr GetInjectedKeyMarker() => InjectedKeyMarker;
}

/// <summary>
/// Event args for key press events
/// </summary>
public class KeyPressedEventArgs : EventArgs
{
    public ushort VirtualKeyCode { get; }
    public bool Shift { get; }
    public bool CapsLock { get; }
    public bool Handled { get; set; }

    public KeyPressedEventArgs(ushort vkCode, bool shift, bool capsLock)
    {
        VirtualKeyCode = vkCode;
        Shift = shift;
        CapsLock = capsLock;
        Handled = false;
    }
}
</file>

<file path="platforms/windows/GoNhanh/Core/KeyCodes.cs">
namespace GoNhanh.Core;

/// <summary>
/// Windows Virtual Key Codes
/// Maps to Rust core key codes for FFI compatibility
/// Reference: https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
/// </summary>
public static class KeyCodes
{
    // Letters A-Z (0x41 - 0x5A)
    public const ushort VK_A = 0x41;
    public const ushort VK_B = 0x42;
    public const ushort VK_C = 0x43;
    public const ushort VK_D = 0x44;
    public const ushort VK_E = 0x45;
    public const ushort VK_F = 0x46;
    public const ushort VK_G = 0x47;
    public const ushort VK_H = 0x48;
    public const ushort VK_I = 0x49;
    public const ushort VK_J = 0x4A;
    public const ushort VK_K = 0x4B;
    public const ushort VK_L = 0x4C;
    public const ushort VK_M = 0x4D;
    public const ushort VK_N = 0x4E;
    public const ushort VK_O = 0x4F;
    public const ushort VK_P = 0x50;
    public const ushort VK_Q = 0x51;
    public const ushort VK_R = 0x52;
    public const ushort VK_S = 0x53;
    public const ushort VK_T = 0x54;
    public const ushort VK_U = 0x55;
    public const ushort VK_V = 0x56;
    public const ushort VK_W = 0x57;
    public const ushort VK_X = 0x58;
    public const ushort VK_Y = 0x59;
    public const ushort VK_Z = 0x5A;

    // Numbers 0-9 (0x30 - 0x39)
    public const ushort VK_0 = 0x30;
    public const ushort VK_1 = 0x31;
    public const ushort VK_2 = 0x32;
    public const ushort VK_3 = 0x33;
    public const ushort VK_4 = 0x34;
    public const ushort VK_5 = 0x35;
    public const ushort VK_6 = 0x36;
    public const ushort VK_7 = 0x37;
    public const ushort VK_8 = 0x38;
    public const ushort VK_9 = 0x39;

    // Special keys
    public const ushort VK_BACK = 0x08;      // Backspace
    public const ushort VK_TAB = 0x09;
    public const ushort VK_RETURN = 0x0D;    // Enter
    public const ushort VK_SHIFT = 0x10;
    public const ushort VK_CONTROL = 0x11;
    public const ushort VK_MENU = 0x12;      // Alt
    public const ushort VK_CAPITAL = 0x14;   // Caps Lock
    public const ushort VK_ESCAPE = 0x1B;
    public const ushort VK_SPACE = 0x20;

    // Punctuation (US keyboard layout)
    public const ushort VK_OEM_1 = 0xBA;     // ;:
    public const ushort VK_OEM_PLUS = 0xBB;  // =+
    public const ushort VK_OEM_COMMA = 0xBC; // ,<
    public const ushort VK_OEM_MINUS = 0xBD; // -_
    public const ushort VK_OEM_PERIOD = 0xBE;// .>
    public const ushort VK_OEM_2 = 0xBF;     // /?
    public const ushort VK_OEM_3 = 0xC0;     // `~
    public const ushort VK_OEM_4 = 0xDB;     // [{
    public const ushort VK_OEM_5 = 0xDC;     // \|
    public const ushort VK_OEM_6 = 0xDD;     // ]}
    public const ushort VK_OEM_7 = 0xDE;     // '"

    // Numpad
    public const ushort VK_NUMPAD0 = 0x60;
    public const ushort VK_NUMPAD1 = 0x61;
    public const ushort VK_NUMPAD2 = 0x62;
    public const ushort VK_NUMPAD3 = 0x63;
    public const ushort VK_NUMPAD4 = 0x64;
    public const ushort VK_NUMPAD5 = 0x65;
    public const ushort VK_NUMPAD6 = 0x66;
    public const ushort VK_NUMPAD7 = 0x67;
    public const ushort VK_NUMPAD8 = 0x68;
    public const ushort VK_NUMPAD9 = 0x69;

    /// <summary>
    /// Check if a key code is a letter (A-Z)
    /// </summary>
    public static bool IsLetter(ushort keyCode) => keyCode >= VK_A && keyCode <= VK_Z;

    /// <summary>
    /// Check if a key code is a number (0-9)
    /// </summary>
    public static bool IsNumber(ushort keyCode) => keyCode >= VK_0 && keyCode <= VK_9;

    /// <summary>
    /// Check if a key code is relevant for Vietnamese input
    /// Letters, numbers (for VNI), and word-breaking keys
    /// </summary>
    public static bool IsRelevantKey(ushort keyCode)
    {
        return IsLetter(keyCode) ||
               IsNumber(keyCode) ||
               keyCode == VK_SPACE ||
               keyCode == VK_RETURN ||
               keyCode == VK_BACK ||
               keyCode == VK_OEM_4 ||  // [
               keyCode == VK_OEM_6;    // ]
    }

    /// <summary>
    /// Check if a key should clear the IME buffer (word boundaries)
    /// </summary>
    public static bool IsBufferClearKey(ushort keyCode)
    {
        return keyCode == VK_SPACE ||
               keyCode == VK_RETURN ||
               keyCode == VK_TAB ||
               keyCode == VK_ESCAPE;
    }
}
</file>

<file path="platforms/windows/GoNhanh/Core/RustBridge.cs">
using System.Runtime.InteropServices;
using System.Text;

namespace GoNhanh.Core;

/// <summary>
/// P/Invoke bridge to Rust core library (gonhanh_core.dll)
/// FFI contract matches core/src/lib.rs exports
/// </summary>
public static class RustBridge
{
    private const string DllName = "gonhanh_core.dll";

    #region Native Imports

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_init();

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_clear();

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_free(IntPtr result);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_method(byte method);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_enabled([MarshalAs(UnmanagedType.U1)] bool enabled);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern void ime_modern([MarshalAs(UnmanagedType.U1)] bool modern);

    [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
    private static extern IntPtr ime_key(ushort keycode, [MarshalAs(UnmanagedType.U1)] bool shift, [MarshalAs(UnmanagedType.U1)] bool capslock);

    #endregion

    #region Public API

    /// <summary>
    /// Initialize the IME engine. Call once at startup.
    /// </summary>
    public static void Initialize()
    {
        ime_init();
    }

    /// <summary>
    /// Clear the typing buffer.
    /// </summary>
    public static void Clear()
    {
        ime_clear();
    }

    /// <summary>
    /// Set input method (Telex=0, VNI=1)
    /// </summary>
    public static void SetMethod(InputMethod method)
    {
        ime_method((byte)method);
    }

    /// <summary>
    /// Enable or disable IME processing
    /// </summary>
    public static void SetEnabled(bool enabled)
    {
        ime_enabled(enabled);
    }

    /// <summary>
    /// Set tone style (modern=true: h√≤a, old=false: ho√†)
    /// </summary>
    public static void SetModernTone(bool modern)
    {
        ime_modern(modern);
    }

    /// <summary>
    /// Process a keystroke and get the result
    /// </summary>
    public static ImeResult ProcessKey(ushort keycode, bool shift, bool capslock)
    {
        IntPtr ptr = ime_key(keycode, shift, capslock);
        if (ptr == IntPtr.Zero)
        {
            return ImeResult.Empty;
        }

        try
        {
            var native = Marshal.PtrToStructure<NativeResult>(ptr);
            return ImeResult.FromNative(native);
        }
        finally
        {
            ime_free(ptr);
        }
    }

    #endregion
}

/// <summary>
/// Input method type
/// </summary>
public enum InputMethod : byte
{
    Telex = 0,
    VNI = 1
}

/// <summary>
/// IME action type
/// </summary>
public enum ImeAction : byte
{
    None = 0,    // No action needed
    Send = 1,    // Send text replacement
    Restore = 2  // Restore original text
}

/// <summary>
/// Native result structure from Rust (must match core/src/lib.rs)
/// </summary>
[StructLayout(LayoutKind.Sequential)]
internal struct NativeResult
{
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
    public uint[] chars;
    public byte action;
    public byte backspace;
    public byte count;
    public byte _pad;
}

/// <summary>
/// Managed IME result
/// </summary>
public readonly struct ImeResult
{
    public readonly ImeAction Action;
    public readonly byte Backspace;
    public readonly byte Count;
    private readonly uint[] _chars;

    public static readonly ImeResult Empty = new(ImeAction.None, 0, 0, Array.Empty<uint>());

    private ImeResult(ImeAction action, byte backspace, byte count, uint[] chars)
    {
        Action = action;
        Backspace = backspace;
        Count = count;
        _chars = chars;
    }

    internal static ImeResult FromNative(NativeResult native)
    {
        return new ImeResult(
            (ImeAction)native.action,
            native.backspace,
            native.count,
            native.chars ?? Array.Empty<uint>()
        );
    }

    /// <summary>
    /// Get the result text as a string
    /// </summary>
    public string GetText()
    {
        if (Count == 0 || _chars == null)
            return string.Empty;

        var sb = new StringBuilder(Count);
        for (int i = 0; i < Count && i < _chars.Length; i++)
        {
            if (_chars[i] > 0)
            {
                sb.Append(char.ConvertFromUtf32((int)_chars[i]));
            }
        }
        return sb.ToString();
    }
}
</file>

<file path="platforms/windows/GoNhanh/Core/TextSender.cs">
using System.Runtime.InteropServices;

namespace GoNhanh.Core;

/// <summary>
/// Sends text to the active window using Windows SendInput API
/// Handles backspace deletion and Unicode character insertion
/// </summary>
public static class TextSender
{
    #region Win32 Constants

    private const uint INPUT_KEYBOARD = 1;
    private const uint KEYEVENTF_KEYUP = 0x0002;
    private const uint KEYEVENTF_UNICODE = 0x0004;

    #endregion

    #region Win32 Imports

    [DllImport("user32.dll", SetLastError = true)]
    private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

    #endregion

    #region Structures

    [StructLayout(LayoutKind.Sequential)]
    private struct INPUT
    {
        public uint type;
        public INPUTUNION u;
    }

    [StructLayout(LayoutKind.Explicit)]
    private struct INPUTUNION
    {
        [FieldOffset(0)] public KEYBDINPUT ki;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct KEYBDINPUT
    {
        public ushort wVk;
        public ushort wScan;
        public uint dwFlags;
        public uint time;
        public IntPtr dwExtraInfo;
    }

    #endregion

    /// <summary>
    /// Send text replacement: delete characters and insert new text
    /// </summary>
    /// <param name="text">Text to insert</param>
    /// <param name="backspaces">Number of backspaces to send first</param>
    public static void SendText(string text, int backspaces)
    {
        if (string.IsNullOrEmpty(text) && backspaces == 0)
            return;

        var inputs = new List<INPUT>();
        var marker = KeyboardHook.GetInjectedKeyMarker();

        // Add backspaces
        for (int i = 0; i < backspaces; i++)
        {
            // Key down
            inputs.Add(new INPUT
            {
                type = INPUT_KEYBOARD,
                u = new INPUTUNION
                {
                    ki = new KEYBDINPUT
                    {
                        wVk = KeyCodes.VK_BACK,
                        wScan = 0,
                        dwFlags = 0,
                        time = 0,
                        dwExtraInfo = marker
                    }
                }
            });

            // Key up
            inputs.Add(new INPUT
            {
                type = INPUT_KEYBOARD,
                u = new INPUTUNION
                {
                    ki = new KEYBDINPUT
                    {
                        wVk = KeyCodes.VK_BACK,
                        wScan = 0,
                        dwFlags = KEYEVENTF_KEYUP,
                        time = 0,
                        dwExtraInfo = marker
                    }
                }
            });
        }

        // Add text characters (Unicode)
        foreach (char c in text)
        {
            // For Unicode characters, use wScan with KEYEVENTF_UNICODE flag
            // Key down
            inputs.Add(new INPUT
            {
                type = INPUT_KEYBOARD,
                u = new INPUTUNION
                {
                    ki = new KEYBDINPUT
                    {
                        wVk = 0,
                        wScan = c,
                        dwFlags = KEYEVENTF_UNICODE,
                        time = 0,
                        dwExtraInfo = marker
                    }
                }
            });

            // Key up
            inputs.Add(new INPUT
            {
                type = INPUT_KEYBOARD,
                u = new INPUTUNION
                {
                    ki = new KEYBDINPUT
                    {
                        wVk = 0,
                        wScan = c,
                        dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP,
                        time = 0,
                        dwExtraInfo = marker
                    }
                }
            });
        }

        if (inputs.Count > 0)
        {
            var inputArray = inputs.ToArray();
            SendInput((uint)inputArray.Length, inputArray, Marshal.SizeOf<INPUT>());
        }
    }
}
</file>

<file path="platforms/windows/GoNhanh/Native/.gitkeep">
# Placeholder for native Rust DLL
# gonhanh_core.dll will be placed here after building
</file>

<file path="platforms/windows/GoNhanh/Resources/Icons/.gitkeep">
# Placeholder for app icons
# Add app.ico (multi-size Windows icon) here
</file>

<file path="platforms/windows/GoNhanh/Services/SettingsService.cs">
using Microsoft.Win32;
using GoNhanh.Core;

namespace GoNhanh.Services;

/// <summary>
/// Manages application settings using Windows Registry
/// Similar to UserDefaults on macOS
/// </summary>
public class SettingsService
{
    private const string RegistryKeyPath = @"SOFTWARE\GoNhanh";
    private const string AutoStartKeyPath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Run";
    private const string AppName = "GoNhanh";

    #region Settings Keys

    private const string KeyInputMethod = "InputMethod";
    private const string KeyModernTone = "ModernTone";
    private const string KeyEnabled = "Enabled";
    private const string KeyFirstRun = "FirstRun";
    private const string KeyAutoStart = "AutoStart";

    #endregion

    #region Properties

    public InputMethod CurrentMethod { get; set; } = InputMethod.Telex;
    public bool UseModernTone { get; set; } = true;
    public bool IsEnabled { get; set; } = true;
    public bool IsFirstRun { get; set; } = true;
    public bool AutoStart { get; set; } = false;

    #endregion

    #region Public Methods

    /// <summary>
    /// Load settings from registry
    /// </summary>
    public void Load()
    {
        try
        {
            using var key = Registry.CurrentUser.OpenSubKey(RegistryKeyPath);
            if (key == null)
            {
                // First run, use defaults
                IsFirstRun = true;
                return;
            }

            CurrentMethod = (InputMethod)(int)(key.GetValue(KeyInputMethod, 0) ?? 0);
            UseModernTone = ((int)(key.GetValue(KeyModernTone, 1) ?? 1)) == 1;
            IsEnabled = ((int)(key.GetValue(KeyEnabled, 1) ?? 1)) == 1;
            IsFirstRun = ((int)(key.GetValue(KeyFirstRun, 1) ?? 1)) == 1;
            AutoStart = ((int)(key.GetValue(KeyAutoStart, 0) ?? 0)) == 1;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load settings: {ex.Message}");
        }
    }

    /// <summary>
    /// Save settings to registry
    /// </summary>
    public void Save()
    {
        try
        {
            using var key = Registry.CurrentUser.CreateSubKey(RegistryKeyPath);
            if (key != null)
            {
                key.SetValue(KeyInputMethod, (int)CurrentMethod, RegistryValueKind.DWord);
                key.SetValue(KeyModernTone, UseModernTone ? 1 : 0, RegistryValueKind.DWord);
                key.SetValue(KeyEnabled, IsEnabled ? 1 : 0, RegistryValueKind.DWord);
                key.SetValue(KeyFirstRun, IsFirstRun ? 1 : 0, RegistryValueKind.DWord);
                key.SetValue(KeyAutoStart, AutoStart ? 1 : 0, RegistryValueKind.DWord);
            }

            // Update auto-start registry
            UpdateAutoStart();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to save settings: {ex.Message}");
        }
    }

    /// <summary>
    /// Update Windows startup entry
    /// </summary>
    public void UpdateAutoStart()
    {
        try
        {
            using var key = Registry.CurrentUser.OpenSubKey(AutoStartKeyPath, true);
            if (key == null) return;

            if (AutoStart)
            {
                string exePath = System.Diagnostics.Process.GetCurrentProcess().MainModule?.FileName ?? "";
                if (!string.IsNullOrEmpty(exePath))
                {
                    key.SetValue(AppName, $"\"{exePath}\"");
                }
            }
            else
            {
                key.DeleteValue(AppName, false);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to update auto-start: {ex.Message}");
        }
    }

    /// <summary>
    /// Reset settings to defaults
    /// </summary>
    public void Reset()
    {
        CurrentMethod = InputMethod.Telex;
        UseModernTone = true;
        IsEnabled = true;
        AutoStart = false;
        Save();
    }

    #endregion
}
</file>

<file path="platforms/windows/GoNhanh/Views/AboutWindow.xaml">
<Window x:Class="GoNhanh.Views.AboutWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Gi·ªõi thi·ªáu GoNhanh"
        Height="400" Width="340"
        WindowStartupLocation="CenterScreen"
        ResizeMode="NoResize"
        Background="{StaticResource BackgroundBrush}">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Content -->
        <StackPanel Grid.Row="0" VerticalAlignment="Center" Margin="32,24">
            <!-- App Logo & Name -->
            <TextBlock Text="GoNhanh"
                       FontSize="24"
                       FontWeight="Bold"
                       Foreground="{StaticResource PrimaryBrush}"
                       HorizontalAlignment="Center"/>
            <TextBlock Text="(G√µ Nhanh)"
                       FontSize="13"
                       Foreground="{StaticResource SecondaryTextBrush}"
                       HorizontalAlignment="Center"
                       Margin="0,2,0,0"/>
            <TextBlock x:Name="VersionText"
                       Text="Version 1.0.0"
                       FontSize="11"
                       Foreground="#9CA3AF"
                       HorizontalAlignment="Center"
                       Margin="0,4,0,0"/>

            <!-- Tagline -->
            <TextBlock Text="B·ªô g√µ ti·∫øng Vi·ªát hi·ªáu su·∫•t cao"
                       FontSize="13"
                       Foreground="{StaticResource TextBrush}"
                       HorizontalAlignment="Center"
                       Margin="0,20,0,0"/>

            <!-- Author Section -->
            <StackPanel HorizontalAlignment="Center" Margin="0,24,0,0">
                <TextBlock x:Name="AuthorText"
                           FontSize="13"
                           FontWeight="Medium"
                           Foreground="{StaticResource TextBrush}"
                           HorizontalAlignment="Center"/>
                <TextBlock HorizontalAlignment="Center" Margin="0,4,0,0">
                    <Hyperlink x:Name="EmailLink"
                               RequestNavigate="Hyperlink_RequestNavigate"
                               Foreground="{StaticResource SecondaryTextBrush}">
                        <Run x:Name="EmailText" FontSize="12"/>
                    </Hyperlink>
                </TextBlock>
                <TextBlock HorizontalAlignment="Center" Margin="0,4,0,0">
                    <Hyperlink x:Name="LinkedInLink"
                               RequestNavigate="Hyperlink_RequestNavigate">
                        <Run Text="LinkedIn" FontSize="12"/>
                    </Hyperlink>
                </TextBlock>
            </StackPanel>

            <!-- Links -->
            <StackPanel Orientation="Horizontal"
                        HorizontalAlignment="Center"
                        Margin="0,24,0,0">
                <TextBlock>
                    <Hyperlink x:Name="WebsiteLink"
                               RequestNavigate="Hyperlink_RequestNavigate">
                        <Run Text="Website" FontSize="13"/>
                    </Hyperlink>
                </TextBlock>
                <TextBlock Text="  ‚Ä¢  "
                           Foreground="{StaticResource SecondaryTextBrush}"
                           FontSize="13"/>
                <TextBlock>
                    <Hyperlink x:Name="GitHubLink"
                               RequestNavigate="Hyperlink_RequestNavigate">
                        <Run Text="GitHub" FontSize="13"/>
                    </Hyperlink>
                </TextBlock>
            </StackPanel>
        </StackPanel>

        <!-- Footer -->
        <Border Grid.Row="1"
                BorderBrush="#E5E7EB"
                BorderThickness="0,1,0,0"
                Padding="0,12">
            <TextBlock x:Name="CopyrightText"
                       FontSize="10"
                       Foreground="#9CA3AF"
                       HorizontalAlignment="Center"/>
        </Border>
    </Grid>
</Window>
</file>

<file path="platforms/windows/GoNhanh/Views/AboutWindow.xaml.cs">
using System.Diagnostics;
using System.Windows;
using System.Windows.Navigation;
using GoNhanh.Core;

namespace GoNhanh.Views;

/// <summary>
/// About window showing app info and links
/// Matches macOS AboutView exactly
/// </summary>
public partial class AboutWindow : Window
{
    public AboutWindow()
    {
        InitializeComponent();
        LoadMetadata();
    }

    private void LoadMetadata()
    {
        // Version
        VersionText.Text = $"Version {AppMetadata.Version}";

        // Author
        AuthorText.Text = AppMetadata.Author;
        EmailText.Text = AppMetadata.AuthorEmail;
        EmailLink.NavigateUri = new Uri($"mailto:{AppMetadata.AuthorEmail}");
        LinkedInLink.NavigateUri = new Uri(AppMetadata.AuthorLinkedin);

        // Links
        WebsiteLink.NavigateUri = new Uri(AppMetadata.Website);
        GitHubLink.NavigateUri = new Uri(AppMetadata.Repository);

        // Copyright
        CopyrightText.Text = AppMetadata.Copyright;
    }

    private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
    {
        try
        {
            Process.Start(new ProcessStartInfo
            {
                FileName = e.Uri.AbsoluteUri,
                UseShellExecute = true
            });
        }
        catch
        {
            // Ignore errors opening browser/email client
        }
        e.Handled = true;
    }
}
</file>

<file path="platforms/windows/GoNhanh/Views/OnboardingWindow.xaml">
<Window x:Class="GoNhanh.Views.OnboardingWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Ch√†o m·ª´ng ƒë·∫øn GoNhanh"
        Height="500" Width="500"
        WindowStartupLocation="CenterScreen"
        ResizeMode="NoResize"
        Background="{StaticResource BackgroundBrush}">

    <Grid>
        <!-- Page Container -->
        <TabControl x:Name="PageTabs"
                    BorderThickness="0"
                    Background="Transparent"
                    Padding="0">
            <TabControl.ItemContainerStyle>
                <Style TargetType="TabItem">
                    <Setter Property="Visibility" Value="Collapsed"/>
                </Style>
            </TabControl.ItemContainerStyle>

            <!-- Page 1: Welcome -->
            <TabItem>
                <Grid Margin="40">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <StackPanel Grid.Row="0" VerticalAlignment="Center">
                        <TextBlock Text="GoNhanh"
                                   FontSize="36"
                                   FontWeight="Bold"
                                   Foreground="{StaticResource PrimaryBrush}"
                                   HorizontalAlignment="Center"/>
                        <TextBlock Text="G√µ Ti·∫øng Vi·ªát Nhanh"
                                   FontSize="16"
                                   Foreground="{StaticResource SecondaryTextBrush}"
                                   HorizontalAlignment="Center"
                                   Margin="0,8,0,0"/>

                        <TextBlock TextWrapping="Wrap"
                                   TextAlignment="Center"
                                   Margin="0,40,0,0"
                                   FontSize="14"
                                   Foreground="{StaticResource TextBrush}">
                            <Run Text="B·ªô g√µ ti·∫øng Vi·ªát hi·ªán ƒë·∫°i, nh·∫π v√† nhanh."/>
                            <LineBreak/>
                            <LineBreak/>
                            <Run Text="C√†i ƒë·∫∑t xong - D√πng ngay" FontWeight="SemiBold"/>
                            <LineBreak/>
                            <Run Text="Kh√¥ng qu·∫£ng c√°o - Kh√¥ng theo d√µi - Mi·ªÖn ph√≠"/>
                        </TextBlock>
                    </StackPanel>

                    <Button Grid.Row="1"
                            Content="B·∫Øt ƒë·∫ßu"
                            Style="{StaticResource PrimaryButton}"
                            HorizontalAlignment="Center"
                            Width="160"
                            Click="NextPage_Click"/>
                </Grid>
            </TabItem>

            <!-- Page 2: Select Input Method -->
            <TabItem>
                <Grid Margin="40">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <StackPanel Grid.Row="0">
                        <TextBlock Text="Ch·ªçn ki·ªÉu g√µ"
                                   FontSize="24"
                                   FontWeight="SemiBold"
                                   Foreground="{StaticResource TextBrush}"/>
                        <TextBlock Text="B·∫°n quen d√πng ki·ªÉu g√µ n√†o?"
                                   FontSize="14"
                                   Foreground="{StaticResource SecondaryTextBrush}"
                                   Margin="0,8,0,0"/>
                    </StackPanel>

                    <StackPanel Grid.Row="1" VerticalAlignment="Center">
                        <Border BorderBrush="#E5E7EB"
                                BorderThickness="1"
                                CornerRadius="8"
                                Padding="16"
                                Margin="0,0,0,12"
                                Cursor="Hand"
                                MouseDown="SelectTelex_Click">
                            <StackPanel>
                                <RadioButton x:Name="OnboardTelexRadio"
                                             Content="Telex"
                                             FontWeight="SemiBold"
                                             FontSize="15"
                                             IsChecked="True"/>
                                <TextBlock Text="aa ‚Üí √¢   ow ‚Üí ∆°   dd ‚Üí ƒë   s ‚Üí s·∫Øc   f ‚Üí huy·ªÅn"
                                           Foreground="{StaticResource SecondaryTextBrush}"
                                           Margin="20,4,0,0"
                                           FontSize="13"/>
                            </StackPanel>
                        </Border>

                        <Border BorderBrush="#E5E7EB"
                                BorderThickness="1"
                                CornerRadius="8"
                                Padding="16"
                                Cursor="Hand"
                                MouseDown="SelectVni_Click">
                            <StackPanel>
                                <RadioButton x:Name="OnboardVniRadio"
                                             Content="VNI"
                                             FontWeight="SemiBold"
                                             FontSize="15"/>
                                <TextBlock Text="a6 ‚Üí √¢   o7 ‚Üí ∆°   d9 ‚Üí ƒë   1 ‚Üí s·∫Øc   2 ‚Üí huy·ªÅn"
                                           Foreground="{StaticResource SecondaryTextBrush}"
                                           Margin="20,4,0,0"
                                           FontSize="13"/>
                            </StackPanel>
                        </Border>
                    </StackPanel>

                    <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center">
                        <Button Content="Quay l·∫°i"
                                Padding="16,8"
                                Margin="0,0,12,0"
                                Click="PrevPage_Click"/>
                        <Button Content="Ti·∫øp theo"
                                Style="{StaticResource PrimaryButton}"
                                Width="120"
                                Click="NextPage_Click"/>
                    </StackPanel>
                </Grid>
            </TabItem>

            <!-- Page 3: Done -->
            <TabItem>
                <Grid Margin="40">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <StackPanel Grid.Row="0" VerticalAlignment="Center">
                        <TextBlock Text="S·∫µn s√†ng!"
                                   FontSize="32"
                                   FontWeight="Bold"
                                   Foreground="{StaticResource PrimaryBrush}"
                                   HorizontalAlignment="Center"/>

                        <TextBlock TextWrapping="Wrap"
                                   TextAlignment="Center"
                                   Margin="0,24,0,0"
                                   FontSize="14"
                                   Foreground="{StaticResource TextBrush}">
                            <Run Text="GoNhanh ƒëang ch·∫°y trong khay h·ªá th·ªëng (system tray)."/>
                            <LineBreak/>
                            <LineBreak/>
                            <Run Text="Nh·∫•p chu·ªôt ph·∫£i v√†o bi·ªÉu t∆∞·ª£ng 'V' ƒë·ªÉ:" FontWeight="SemiBold"/>
                            <LineBreak/>
                            <Run Text="‚Ä¢ ƒê·ªïi ki·ªÉu g√µ (Telex/VNI)"/>
                            <LineBreak/>
                            <Run Text="‚Ä¢ B·∫≠t/t·∫Øt b·ªô g√µ"/>
                        </TextBlock>

                        <Border Background="#F3F4F6"
                                CornerRadius="8"
                                Padding="16"
                                Margin="0,24,0,0">
                            <TextBlock TextWrapping="Wrap"
                                       TextAlignment="Center"
                                       FontSize="13"
                                       Foreground="{StaticResource SecondaryTextBrush}">
                                <Run Text="M·∫πo: " FontWeight="SemiBold"/>
                                <Run Text="Nh·∫•p ƒë√∫p v√†o bi·ªÉu t∆∞·ª£ng ƒë·ªÉ nhanh ch√≥ng b·∫≠t/t·∫Øt b·ªô g√µ."/>
                            </TextBlock>
                        </Border>
                    </StackPanel>

                    <Button Grid.Row="1"
                            Content="B·∫Øt ƒë·∫ßu g√µ ti·∫øng Vi·ªát"
                            Style="{StaticResource PrimaryButton}"
                            HorizontalAlignment="Center"
                            Width="200"
                            Click="Finish_Click"/>
                </Grid>
            </TabItem>
        </TabControl>

        <!-- Page Indicator -->
        <StackPanel Orientation="Horizontal"
                    HorizontalAlignment="Center"
                    VerticalAlignment="Bottom"
                    Margin="0,0,0,20">
            <Ellipse x:Name="Dot1" Width="8" Height="8" Fill="{StaticResource PrimaryBrush}" Margin="4"/>
            <Ellipse x:Name="Dot2" Width="8" Height="8" Fill="#E5E7EB" Margin="4"/>
            <Ellipse x:Name="Dot3" Width="8" Height="8" Fill="#E5E7EB" Margin="4"/>
        </StackPanel>
    </Grid>
</Window>
</file>

<file path="platforms/windows/GoNhanh/Views/TrayIcon.cs">
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using GoNhanh.Core;

namespace GoNhanh.Views;

/// <summary>
/// System tray icon with context menu
/// Matches macOS MenuBarController flow exactly
/// </summary>
public class TrayIcon : IDisposable
{
    private NotifyIcon? _notifyIcon;
    private ContextMenuStrip? _contextMenu;
    private ToolStripMenuItem? _headerItem;
    private ToolStripMenuItem? _telexItem;
    private ToolStripMenuItem? _vniItem;
    private bool _isEnabled = true;
    private InputMethod _currentMethod = InputMethod.Telex;
    private bool _disposed;

    #region Events

    public event Action? OnExitRequested;
    public event Action<InputMethod>? OnMethodChanged;
    public event Action<bool>? OnEnabledChanged;

    #endregion

    /// <summary>
    /// Initialize the system tray icon
    /// </summary>
    public void Initialize(InputMethod currentMethod, bool isEnabled)
    {
        _currentMethod = currentMethod;
        _isEnabled = isEnabled;

        _contextMenu = new ContextMenuStrip();
        _contextMenu.Font = new Font("Segoe UI", 9F);
        _contextMenu.ShowCheckMargin = true;
        _contextMenu.ShowImageMargin = false;

        // Header with toggle (like macOS)
        _headerItem = new ToolStripMenuItem();
        _headerItem.Enabled = false; // Non-clickable, just display
        _contextMenu.Items.Add(_headerItem);
        _contextMenu.Items.Add(new ToolStripSeparator());

        // Input methods with shortcuts (Ctrl+1, Ctrl+2 like macOS ‚åò1, ‚åò2)
        _telexItem = new ToolStripMenuItem("Telex");
        _telexItem.ShortcutKeys = Keys.Control | Keys.D1;
        _telexItem.Click += (s, e) => SetMethod(InputMethod.Telex);
        _contextMenu.Items.Add(_telexItem);

        _vniItem = new ToolStripMenuItem("VNI");
        _vniItem.ShortcutKeys = Keys.Control | Keys.D2;
        _vniItem.Click += (s, e) => SetMethod(InputMethod.VNI);
        _contextMenu.Items.Add(_vniItem);

        _contextMenu.Items.Add(new ToolStripSeparator());

        // Toggle enabled
        var toggleItem = new ToolStripMenuItem("B·∫≠t/T·∫Øt");
        toggleItem.ShortcutKeys = Keys.Control | Keys.D0;
        toggleItem.Click += (s, e) => ToggleEnabled();
        _contextMenu.Items.Add(toggleItem);

        _contextMenu.Items.Add(new ToolStripSeparator());

        // About (like macOS "Gi·ªõi thi·ªáu GoNhanh")
        var aboutItem = new ToolStripMenuItem($"Gi·ªõi thi·ªáu {AppMetadata.Name}");
        aboutItem.Click += (s, e) => ShowAbout();
        _contextMenu.Items.Add(aboutItem);

        // Feedback/Issues (like macOS "G√≥p √Ω & B√°o l·ªói")
        var feedbackItem = new ToolStripMenuItem("G√≥p √Ω && B√°o l·ªói");
        feedbackItem.Click += (s, e) => OpenFeedback();
        _contextMenu.Items.Add(feedbackItem);

        _contextMenu.Items.Add(new ToolStripSeparator());

        // Exit (like macOS "Tho√°t")
        var exitItem = new ToolStripMenuItem("Tho√°t");
        exitItem.ShortcutKeys = Keys.Control | Keys.Q;
        exitItem.Click += (s, e) => OnExitRequested?.Invoke();
        _contextMenu.Items.Add(exitItem);

        // Create tray icon
        _notifyIcon = new NotifyIcon
        {
            ContextMenuStrip = _contextMenu,
            Visible = true
        };

        // Double-click to toggle (like macOS)
        _notifyIcon.DoubleClick += (s, e) => ToggleEnabled();

        // Update initial state
        UpdateState(currentMethod, isEnabled);
    }

    /// <summary>
    /// Update tray icon and menu state
    /// </summary>
    public void UpdateState(InputMethod method, bool isEnabled)
    {
        _currentMethod = method;
        _isEnabled = isEnabled;

        // Update header text
        if (_headerItem != null)
        {
            string status = isEnabled ? "ON" : "OFF";
            _headerItem.Text = $"{AppMetadata.Name}  [{status}]";
        }

        // Update method checkmarks
        if (_telexItem != null)
            _telexItem.Checked = method == InputMethod.Telex;

        if (_vniItem != null)
            _vniItem.Checked = method == InputMethod.VNI;

        UpdateIcon(isEnabled);
        UpdateTooltip(method, isEnabled);
    }

    private void SetMethod(InputMethod method)
    {
        _currentMethod = method;
        OnMethodChanged?.Invoke(method);

        if (_telexItem != null)
            _telexItem.Checked = method == InputMethod.Telex;

        if (_vniItem != null)
            _vniItem.Checked = method == InputMethod.VNI;
    }

    private void ToggleEnabled()
    {
        _isEnabled = !_isEnabled;
        UpdateState(_currentMethod, _isEnabled);
        OnEnabledChanged?.Invoke(_isEnabled);
    }

    private void UpdateIcon(bool isEnabled)
    {
        if (_notifyIcon == null) return;

        try
        {
            // Create icon matching macOS style:
            // White rounded rect background with "V" or "E" text
            _notifyIcon.Icon = CreateStatusIcon(isEnabled ? "V" : "E", isEnabled);
        }
        catch
        {
            _notifyIcon.Icon = SystemIcons.Application;
        }
    }

    private void UpdateTooltip(InputMethod method, bool isEnabled)
    {
        if (_notifyIcon == null) return;

        string status = isEnabled ? "B·∫≠t" : "T·∫Øt";
        string methodName = InputMethodInfo.GetName(method);
        _notifyIcon.Text = $"{AppMetadata.Name} [{methodName}] - {status}";
    }

    /// <summary>
    /// Create status icon matching macOS style
    /// White rounded rect background with colored text
    /// </summary>
    private static Icon CreateStatusIcon(string text, bool isEnabled)
    {
        const int size = 16;
        using var bitmap = new Bitmap(size, size);

        using (var g = Graphics.FromImage(bitmap))
        {
            g.SmoothingMode = SmoothingMode.AntiAlias;
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
            g.Clear(Color.Transparent);

            // White rounded rect background (like macOS)
            var rect = new Rectangle(0, 0, size - 1, size - 1);
            using var path = CreateRoundedRectPath(rect, 3);
            using var bgBrush = new SolidBrush(Color.White);
            g.FillPath(bgBrush, path);

            // Text color based on state
            var textColor = isEnabled
                ? Color.FromArgb(37, 99, 235)  // Blue when enabled
                : Color.FromArgb(156, 163, 175); // Gray when disabled

            using var font = new Font("Segoe UI", 9, FontStyle.Bold);
            using var brush = new SolidBrush(textColor);

            var textSize = g.MeasureString(text, font);
            float x = (size - textSize.Width) / 2;
            float y = (size - textSize.Height) / 2;

            g.DrawString(text, font, brush, x, y);
        }

        // Clone icon to own it, then dispose temp resources
        var hIcon = bitmap.GetHicon();
        using var tempIcon = Icon.FromHandle(hIcon);
        return (Icon)tempIcon.Clone();
    }

    private static GraphicsPath CreateRoundedRectPath(Rectangle rect, int radius)
    {
        var path = new GraphicsPath();
        int d = radius * 2;

        path.AddArc(rect.X, rect.Y, d, d, 180, 90);
        path.AddArc(rect.Right - d, rect.Y, d, d, 270, 90);
        path.AddArc(rect.Right - d, rect.Bottom - d, d, d, 0, 90);
        path.AddArc(rect.X, rect.Bottom - d, d, d, 90, 90);
        path.CloseFigure();

        return path;
    }

    private void ShowAbout()
    {
        var about = new AboutWindow();
        about.ShowDialog();
    }

    private void OpenFeedback()
    {
        try
        {
            Process.Start(new ProcessStartInfo
            {
                FileName = AppMetadata.IssuesUrl,
                UseShellExecute = true
            });
        }
        catch
        {
            // Ignore errors opening browser
        }
    }

    #region IDisposable

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _notifyIcon?.Dispose();
                _contextMenu?.Dispose();
            }
            _disposed = true;
        }
    }

    ~TrayIcon()
    {
        Dispose(false);
    }

    #endregion
}
</file>

<file path="platforms/windows/GoNhanh/App.xaml">
<Application x:Class="GoNhanh.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             ShutdownMode="OnExplicitShutdown">
    <Application.Resources>
        <ResourceDictionary>
            <!-- Colors -->
            <Color x:Key="PrimaryColor">#2563EB</Color>
            <Color x:Key="PrimaryHoverColor">#1D4ED8</Color>
            <Color x:Key="BackgroundColor">#FFFFFF</Color>
            <Color x:Key="TextColor">#1F2937</Color>
            <Color x:Key="SecondaryTextColor">#6B7280</Color>

            <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}"/>
            <SolidColorBrush x:Key="PrimaryHoverBrush" Color="{StaticResource PrimaryHoverColor}"/>
            <SolidColorBrush x:Key="BackgroundBrush" Color="{StaticResource BackgroundColor}"/>
            <SolidColorBrush x:Key="TextBrush" Color="{StaticResource TextColor}"/>
            <SolidColorBrush x:Key="SecondaryTextBrush" Color="{StaticResource SecondaryTextColor}"/>

            <!-- Button Style -->
            <Style x:Key="PrimaryButton" TargetType="Button">
                <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
                <Setter Property="Foreground" Value="White"/>
                <Setter Property="Padding" Value="16,8"/>
                <Setter Property="BorderThickness" Value="0"/>
                <Setter Property="Cursor" Value="Hand"/>
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="Button">
                            <Border Background="{TemplateBinding Background}"
                                    CornerRadius="6"
                                    Padding="{TemplateBinding Padding}">
                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                            </Border>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
                <Style.Triggers>
                    <Trigger Property="IsMouseOver" Value="True">
                        <Setter Property="Background" Value="{StaticResource PrimaryHoverBrush}"/>
                    </Trigger>
                </Style.Triggers>
            </Style>
        </ResourceDictionary>
    </Application.Resources>
</Application>
</file>

<file path="platforms/windows/README.md">
# GoNhanh for Windows

Modern Vietnamese input method for Windows.

## Requirements

- Windows 10/11 (64-bit)
- .NET 8.0 Runtime
- Visual Studio 2022 (for building)
- Rust toolchain with MSVC target

## Development Setup

### 1. Install Prerequisites

```powershell
# Install Rust (if not already installed)
# Download from https://rustup.rs

# Add Windows targets
rustup target add x86_64-pc-windows-msvc

# Install .NET 8.0 SDK
# Download from https://dotnet.microsoft.com/download/dotnet/8.0
```

### 2. Run Setup Script

```powershell
powershell -ExecutionPolicy Bypass -File scripts/setup-windows.ps1
```

### 3. Build Rust Core

```powershell
powershell -ExecutionPolicy Bypass -File scripts/build-core-windows.ps1
```

### 4. Build WPF Application

```powershell
cd platforms/windows/GoNhanh
dotnet build -c Release
```

Or open `platforms/windows/GoNhanh/GoNhanh.csproj` in Visual Studio.

## Project Structure

```
platforms/windows/
‚îú‚îÄ‚îÄ GoNhanh/
‚îÇ   ‚îú‚îÄ‚îÄ GoNhanh.csproj      # WPF project file
‚îÇ   ‚îú‚îÄ‚îÄ App.xaml            # Application entry
‚îÇ   ‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RustBridge.cs   # P/Invoke FFI to Rust
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KeyboardHook.cs # Low-level keyboard hook
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KeyCodes.cs     # Virtual key constants
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TextSender.cs   # SendInput API wrapper
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrayIcon.cs     # System tray icon
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SettingsWindow  # Settings UI
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OnboardingWindow# First-run wizard
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AboutWindow     # About dialog
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsService # Registry-based settings
‚îÇ   ‚îú‚îÄ‚îÄ Native/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gonhanh_core.dll# Rust core library
‚îÇ   ‚îî‚îÄ‚îÄ Resources/
‚îÇ       ‚îî‚îÄ‚îÄ Icons/          # App icons
‚îî‚îÄ‚îÄ README.md
```

## Architecture

### Keyboard Hook

Uses Win32 Low-Level Keyboard Hook (`SetWindowsHookEx` with `WH_KEYBOARD_LL`) for system-wide key interception. This is similar to `CGEventTap` on macOS.

### Text Insertion

Uses `SendInput` API with `KEYEVENTF_UNICODE` flag for direct Unicode character insertion. Supports:
- Backspace deletion for replacing text
- Unicode character insertion (Vietnamese diacritics)
- Injected key marking to prevent recursive processing

### Settings Storage

Settings are stored in Windows Registry at:
```
HKEY_CURRENT_USER\SOFTWARE\GoNhanh
```

Auto-start is managed via:
```
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```

## Known Issues & Solutions

### Antivirus False Positives

Low-level keyboard hooks may trigger antivirus warnings. Solutions:
- Code sign the application with a valid certificate
- Submit to Microsoft for SmartScreen reputation
- Add to antivirus exclusions (for development)

### UAC / Admin Rights

The application should work without admin rights for most applications. Some elevated apps may not receive keyboard input.

### UWP Apps

Some Windows Store apps may block low-level keyboard hooks due to app container isolation.

## License

GPL-3.0-or-later
</file>

<file path="scripts/build-core-windows.ps1">
# GoNhanh Windows Core Build Script
# Run: powershell -ExecutionPolicy Bypass -File scripts/build-core-windows.ps1

param(
    [switch]$Release = $true,
    [switch]$x86 = $false,
    [switch]$ARM64 = $false
)

$ErrorActionPreference = "Stop"

Write-Host "Building GoNhanh Core for Windows" -ForegroundColor Cyan
Write-Host "=================================" -ForegroundColor Cyan

$projectRoot = Split-Path -Parent (Split-Path -Parent $MyInvocation.MyCommand.Path)
$coreDir = Join-Path $projectRoot "core"
$outputDir = Join-Path $projectRoot "platforms/windows/GoNhanh/Native"

# Ensure output directory exists
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    Write-Host "Created output directory: $outputDir" -ForegroundColor Yellow
}

# Build configuration
$buildType = if ($Release) { "release" } else { "debug" }
$buildFlag = if ($Release) { "--release" } else { "" }

# Primary target: x64
Write-Host "`nBuilding for x86_64-pc-windows-msvc..." -ForegroundColor Yellow
Push-Location $coreDir
try {
    cargo build $buildFlag --target x86_64-pc-windows-msvc

    $srcDll = Join-Path $coreDir "target/x86_64-pc-windows-msvc/$buildType/gonhanh_core.dll"
    $dstDll = Join-Path $outputDir "gonhanh_core.dll"

    if (Test-Path $srcDll) {
        Copy-Item $srcDll $dstDll -Force
        Write-Host "Copied: $dstDll" -ForegroundColor Green

        $fileInfo = Get-Item $dstDll
        Write-Host "Size: $([math]::Round($fileInfo.Length / 1KB, 2)) KB" -ForegroundColor Gray
    } else {
        Write-Host "Build failed: DLL not found at $srcDll" -ForegroundColor Red
        exit 1
    }
} finally {
    Pop-Location
}

# Optional: 32-bit build
if ($x86) {
    Write-Host "`nBuilding for i686-pc-windows-msvc..." -ForegroundColor Yellow
    Push-Location $coreDir
    try {
        cargo build $buildFlag --target i686-pc-windows-msvc

        $srcDll = Join-Path $coreDir "target/i686-pc-windows-msvc/$buildType/gonhanh_core.dll"
        $dstDll = Join-Path $outputDir "gonhanh_core_x86.dll"

        if (Test-Path $srcDll) {
            Copy-Item $srcDll $dstDll -Force
            Write-Host "Copied: $dstDll" -ForegroundColor Green
        }
    } finally {
        Pop-Location
    }
}

# Optional: ARM64 build
if ($ARM64) {
    Write-Host "`nBuilding for aarch64-pc-windows-msvc..." -ForegroundColor Yellow
    Push-Location $coreDir
    try {
        cargo build $buildFlag --target aarch64-pc-windows-msvc

        $srcDll = Join-Path $coreDir "target/aarch64-pc-windows-msvc/$buildType/gonhanh_core.dll"
        $dstDll = Join-Path $outputDir "gonhanh_core_arm64.dll"

        if (Test-Path $srcDll) {
            Copy-Item $srcDll $dstDll -Force
            Write-Host "Copied: $dstDll" -ForegroundColor Green
        }
    } finally {
        Pop-Location
    }
}

Write-Host "`nBuild complete!" -ForegroundColor Green
</file>

<file path="scripts/build-macos.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Parse arguments
CLEAN_INSTALL=false
for arg in "$@"; do
    case $arg in
        --clean)
            CLEAN_INSTALL=true
            shift
            ;;
        --help|-h)
            echo "Usage: build-macos.sh [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --clean    Remove existing GoNhanh app and clear permissions before building"
            echo "  --help     Show this help message"
            exit 0
            ;;
    esac
done

# Clean install: remove existing app and reset permissions
if [ "$CLEAN_INSTALL" = true ]; then
    echo "üßπ Cleaning existing installation..."

    # Kill running GoNhanh processes
    if pgrep -f "GoNhanh" > /dev/null 2>&1; then
        echo "Stopping running GoNhanh processes..."
        pkill -f "GoNhanh" 2>/dev/null || true
        # Wait for process to terminate
        sleep 1
        # Force kill if still running
        if pgrep -f "GoNhanh" > /dev/null 2>&1; then
            echo "Force killing GoNhanh..."
            pkill -9 -f "GoNhanh" 2>/dev/null || true
            sleep 1
        fi
        echo "GoNhanh processes stopped."
    else
        echo "No running GoNhanh process found."
    fi

    # Remove from /Applications (requires sudo)
    if [ -d "/Applications/GoNhanh.app" ]; then
        echo "Removing /Applications/GoNhanh.app (requires sudo)..."
        sudo rm -rf "/Applications/GoNhanh.app"
    fi

    # Remove from Input Methods
    if [ -d "$HOME/Library/Input Methods/GoNhanh.app" ]; then
        echo "Removing ~/Library/Input Methods/GoNhanh.app..."
        rm -rf "$HOME/Library/Input Methods/GoNhanh.app"
    fi

    # Clear TCC database (Accessibility permissions) - requires Full Disk Access or SIP disabled
    echo "Note: To fully reset Accessibility permissions, go to:"
    echo "  System Settings > Privacy & Security > Accessibility"
    echo "  Remove GoNhanh from the list manually"
    echo ""

    # Clear input source registration
    echo "Clearing input source cache..."
    defaults delete com.apple.HIToolbox AppleEnabledInputSources 2>/dev/null || true

    echo "‚úÖ Clean complete!"
    echo ""
fi

# Always kill running GoNhanh before build (even without --clean)
if pgrep -x "GoNhanh" > /dev/null 2>&1; then
    echo "üõë Stopping running GoNhanh..."
    pkill -x "GoNhanh" 2>/dev/null || true
    sleep 0.5
    # Force kill if still running
    if pgrep -x "GoNhanh" > /dev/null 2>&1; then
        pkill -9 -x "GoNhanh" 2>/dev/null || true
        sleep 0.5
    fi
fi

echo "üçé Building macOS app..."

# Get version from git tag
GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
VERSION=${GIT_TAG#v}  # Remove 'v' prefix
echo "üìå Version from git tag: $VERSION"

# Build macOS app with xcodebuild
cd "$(dirname "$0")/../platforms/macos"

if [ -d "GoNhanh.xcodeproj" ]; then
    echo "Building with Xcode..."

    # Build with version from git tag
    xcodebuild -scheme GoNhanh \
        -configuration Release \
        -destination 'platform=macOS,arch=arm64' \
        -destination 'platform=macOS,arch=x86_64' \
        -derivedDataPath "$(pwd)/build/DerivedData" \
        MARKETING_VERSION="$VERSION" \
        CURRENT_PROJECT_VERSION="$VERSION" \
        2>&1 | grep -v "Using the first of multiple matching destinations"

    # Copy app from DerivedData to local build directory
    echo "Copying app to build directory..."
    mkdir -p build/Release
    cp -R "build/DerivedData/Build/Products/Release/GoNhanh.app" build/Release/

    # Re-sign app with entitlements for local development
    echo "Signing app with entitlements..."
    codesign --force --deep --sign - --entitlements GoNhanh.entitlements build/Release/GoNhanh.app

    echo "‚úÖ macOS app built successfully!"
    echo "üì¶ App: platforms/macos/build/Release/GoNhanh.app"
else
    echo "‚ö†Ô∏è  Xcode project not found!"
    echo "Please create Xcode project in platforms/macos/"
    echo "Steps:"
    echo "  1. Open Xcode"
    echo "  2. Create new macOS App project"
    echo "  3. Name: GoNhanh"
    echo "  4. Location: platforms/macos/"
    echo "  5. Add Swift files from GoNhanh/ folder"
    echo "  6. Link libgonhanh_core.a in Build Phases"
fi
</file>

<file path="scripts/setup-windows.ps1">
# GoNhanh Windows Development Setup Script
# Run: powershell -ExecutionPolicy Bypass -File scripts/setup-windows.ps1

Write-Host "GoNhanh Windows Setup" -ForegroundColor Cyan
Write-Host "=====================" -ForegroundColor Cyan

# Check Rust installation
Write-Host "`nChecking Rust installation..." -ForegroundColor Yellow
if (Get-Command rustc -ErrorAction SilentlyContinue) {
    $rustVersion = rustc --version
    Write-Host "Rust installed: $rustVersion" -ForegroundColor Green
} else {
    Write-Host "Rust not found. Please install from https://rustup.rs" -ForegroundColor Red
    exit 1
}

# Add Windows targets
Write-Host "`nAdding Windows targets..." -ForegroundColor Yellow

$targets = @(
    "x86_64-pc-windows-msvc",    # 64-bit Windows (primary)
    "i686-pc-windows-msvc",       # 32-bit Windows (optional)
    "aarch64-pc-windows-msvc"     # ARM64 Windows (optional)
)

foreach ($target in $targets) {
    Write-Host "Adding target: $target"
    rustup target add $target
}

# Check .NET SDK
Write-Host "`nChecking .NET SDK..." -ForegroundColor Yellow
if (Get-Command dotnet -ErrorAction SilentlyContinue) {
    $dotnetVersion = dotnet --version
    Write-Host ".NET SDK installed: $dotnetVersion" -ForegroundColor Green
} else {
    Write-Host ".NET SDK not found. Please install .NET 8.0 SDK from https://dotnet.microsoft.com" -ForegroundColor Red
    exit 1
}

# Check Visual Studio Build Tools
Write-Host "`nChecking Visual Studio Build Tools..." -ForegroundColor Yellow
$vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
if (Test-Path $vsWhere) {
    $vsPath = & $vsWhere -latest -property installationPath
    Write-Host "Visual Studio found: $vsPath" -ForegroundColor Green
} else {
    Write-Host "Visual Studio not found. Rust MSVC target requires Visual Studio Build Tools." -ForegroundColor Yellow
    Write-Host "Download from: https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022" -ForegroundColor Yellow
}

Write-Host "`nSetup complete!" -ForegroundColor Green
Write-Host "Run 'scripts/build-core-windows.ps1' to build the Rust core library." -ForegroundColor Cyan
</file>

<file path=".gitignore">
# Rust
target/
Cargo.lock
**/*.rs.bk

# Node
node_modules/

# macOS
*.xcuserstate
xcuserdata/
DerivedData/
*.ipa
*.dSYM.zip
*.dSYM
.DS_Store
platforms/macos/*.a
platforms/macos/*.dylib
platforms/macos/build/
*.xcworkspace/
project.xcworkspace/

# Windows
bin/
obj/
*.exe
*.dll
*.pdb

# Build artifacts
*.o
*.so

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Agent configs (not project-specific)
.claude/
.opencode/
plans/
CLAUDE.md
</file>

<file path="LICENSE">
GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright (C) 2025 G√µ Nhanh Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
</file>

<file path="core/src/data/constants.rs">
//! Vietnamese Phonological Constants
//!
//! Centralized constants for valid initials, finals, and spelling rules.

use crate::data::keys;

/// Valid single initial consonants
pub const VALID_INITIALS_1: &[u16] = &[
    keys::B,
    keys::C,
    keys::D,
    keys::G,
    keys::H,
    keys::K,
    keys::L,
    keys::M,
    keys::N,
    keys::P,
    keys::Q,
    keys::R,
    keys::S,
    keys::T,
    keys::V,
    keys::X,
];

/// Valid double initial consonants
pub const VALID_INITIALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::G, keys::H], // gh
    [keys::G, keys::I], // gi
    [keys::K, keys::H], // kh
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
    [keys::P, keys::H], // ph
    [keys::Q, keys::U], // qu
    [keys::T, keys::H], // th
    [keys::T, keys::R], // tr
];

/// Valid single final consonants
pub const VALID_FINALS_1: &[u16] = &[
    keys::C,
    keys::M,
    keys::N,
    keys::P,
    keys::T,
    keys::I,
    keys::Y,
    keys::O,
    keys::U, // semi-vowels
];

/// Valid double final consonants
pub const VALID_FINALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
];

/// Spelling rules: (consonant, invalid_vowels, description)
/// If consonant + vowel matches, it's INVALID
pub const SPELLING_RULES: &[(&[u16], &[u16], &str)] = &[
    // c before e, i, y ‚Üí invalid (should use k)
    (&[keys::C], &[keys::E, keys::I, keys::Y], "c before e/i/y"),
    // k before a, o, u ‚Üí invalid (should use c)
    (&[keys::K], &[keys::A, keys::O, keys::U], "k before a/o/u"),
    // g before e ‚Üí invalid (should use gh)
    (&[keys::G], &[keys::E], "g before e"),
    // ng before e, i ‚Üí invalid (should use ngh)
    (&[keys::N, keys::G], &[keys::E, keys::I], "ng before e/i"),
    // gh before a, o, u ‚Üí invalid (should use g)
    (
        &[keys::G, keys::H],
        &[keys::A, keys::O, keys::U],
        "gh before a/o/u",
    ),
    // ngh before a, o, u ‚Üí invalid (should use ng)
    (
        &[keys::N, keys::G, keys::H],
        &[keys::A, keys::O, keys::U],
        "ngh before a/o/u",
    ),
];
</file>

<file path="core/src/input/mod.rs">
//! Input Methods
//!
//! Defines key mappings for Vietnamese input methods.
//! Engine handles all pattern matching based on buffer scan.

pub mod telex;
pub mod vni;

pub use telex::Telex;
pub use vni::Vni;

use crate::data::chars::tone;
use crate::data::keys;

/// Shared tone target constants
pub const CIRCUMFLEX_TARGETS: &[u16] = &[keys::A, keys::E, keys::O];
pub const HORN_TARGETS_TELEX: &[u16] = &[keys::A, keys::O, keys::U];
pub const HORN_TARGETS_VNI: &[u16] = &[keys::O, keys::U];
pub const BREVE_TARGETS: &[u16] = &[keys::A];

/// Tone modifier type
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ToneType {
    /// Circumflex: √¢, √™, √¥
    Circumflex,
    /// Horn: ∆°, ∆∞ (and ƒÉ for Telex)
    Horn,
    /// Breve: ƒÉ (VNI only)
    Breve,
}

impl ToneType {
    pub fn value(&self) -> u8 {
        match self {
            ToneType::Circumflex => tone::CIRCUMFLEX,
            ToneType::Horn => tone::HORN,
            ToneType::Breve => tone::HORN, // ƒÉ uses same internal value
        }
    }
}

/// Input method trait - defines key mappings only
pub trait Method {
    /// Check if key is a mark modifier
    /// Returns: 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
    fn mark(&self, key: u16) -> Option<u8>;

    /// Check if key is a tone modifier
    /// Returns tone type if this key can modify vowels
    fn tone(&self, key: u16) -> Option<ToneType>;

    /// Get valid targets for tone key
    /// Returns list of vowel keys this tone can apply to
    fn tone_targets(&self, key: u16) -> &'static [u16];

    /// Check if key is stroke modifier (d ‚Üí ƒë)
    fn stroke(&self, key: u16) -> bool;

    /// Check if key removes diacritics
    fn remove(&self, key: u16) -> bool;
}

/// Get method by id
pub fn get(id: u8) -> Box<dyn Method> {
    match id {
        1 => Box::new(Vni),
        _ => Box::new(Telex),
    }
}
</file>

<file path="core/src/input/telex.rs">
//! Telex Input Method
//!
//! Key mappings:
//! - Marks: s=s·∫Øc, f=huy·ªÅn, r=h·ªèi, x=ng√£, j=n·∫∑ng
//! - Tones: a/e/o=circumflex, w=horn/breve
//! - Stroke: d
//! - Remove: z

use super::{Method, ToneType, HORN_TARGETS_TELEX};
use crate::data::keys;

pub struct Telex;

impl Method for Telex {
    fn mark(&self, key: u16) -> Option<u8> {
        match key {
            keys::S => Some(1), // s·∫Øc
            keys::F => Some(2), // huy·ªÅn
            keys::R => Some(3), // h·ªèi
            keys::X => Some(4), // ng√£
            keys::J => Some(5), // n·∫∑ng
            _ => None,
        }
    }

    fn tone(&self, key: u16) -> Option<ToneType> {
        match key {
            keys::A | keys::E | keys::O => Some(ToneType::Circumflex),
            keys::W => Some(ToneType::Horn),
            _ => None,
        }
    }

    fn tone_targets(&self, key: u16) -> &'static [u16] {
        match key {
            keys::A => &[keys::A],
            keys::E => &[keys::E],
            keys::O => &[keys::O],
            keys::W => HORN_TARGETS_TELEX,
            _ => &[],
        }
    }

    fn stroke(&self, key: u16) -> bool {
        key == keys::D
    }

    fn remove(&self, key: u16) -> bool {
        key == keys::Z
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_marks() {
        let t = Telex;
        assert_eq!(t.mark(keys::S), Some(1));
        assert_eq!(t.mark(keys::F), Some(2));
        assert_eq!(t.mark(keys::A), None);
    }

    #[test]
    fn test_tones() {
        let t = Telex;
        assert_eq!(t.tone(keys::A), Some(ToneType::Circumflex));
        assert_eq!(t.tone(keys::W), Some(ToneType::Horn));
        assert_eq!(t.tone(keys::B), None);
    }

    #[test]
    fn test_tone_targets() {
        let t = Telex;
        assert_eq!(t.tone_targets(keys::A), &[keys::A]);
        assert_eq!(t.tone_targets(keys::W), HORN_TARGETS_TELEX);
    }
}
</file>

<file path="core/tests/unit_test.rs">
//! Unit Tests - Character & Word transformations
//! All tests defined as data arrays for maximum coverage with minimal code

mod common;
use common::{telex, vni};

// ============================================================
// TELEX: SINGLE VOWELS WITH ALL MARKS
// ============================================================

const TELEX_VOWELS: &[(&str, &str)] = &[
    // a
    ("a", "a"),
    ("as", "√°"),
    ("af", "√†"),
    ("ar", "·∫£"),
    ("ax", "√£"),
    ("aj", "·∫°"),
    // e
    ("e", "e"),
    ("es", "√©"),
    ("ef", "√®"),
    ("er", "·∫ª"),
    ("ex", "·∫Ω"),
    ("ej", "·∫π"),
    // i
    ("i", "i"),
    ("is", "√≠"),
    ("if", "√¨"),
    ("ir", "·ªâ"),
    ("ix", "ƒ©"),
    ("ij", "·ªã"),
    // o
    ("o", "o"),
    ("os", "√≥"),
    ("of", "√≤"),
    ("or", "·ªè"),
    ("ox", "√µ"),
    ("oj", "·ªç"),
    // u
    ("u", "u"),
    ("us", "√∫"),
    ("uf", "√π"),
    ("ur", "·ªß"),
    ("ux", "≈©"),
    ("uj", "·ª•"),
    // y
    ("y", "y"),
    ("ys", "√Ω"),
    ("yf", "·ª≥"),
    ("yr", "·ª∑"),
    ("yx", "·ªπ"),
    ("yj", "·ªµ"),
];

const TELEX_MODIFIED_VOWELS: &[(&str, &str)] = &[
    // √¢ (circumflex)
    ("aa", "√¢"),
    ("aas", "·∫•"),
    ("aaf", "·∫ß"),
    ("aar", "·∫©"),
    ("aax", "·∫´"),
    ("aaj", "·∫≠"),
    // √™
    ("ee", "√™"),
    ("ees", "·∫ø"),
    ("eef", "·ªÅ"),
    ("eer", "·ªÉ"),
    ("eex", "·ªÖ"),
    ("eej", "·ªá"),
    // √¥
    ("oo", "√¥"),
    ("oos", "·ªë"),
    ("oof", "·ªì"),
    ("oor", "·ªï"),
    ("oox", "·ªó"),
    ("ooj", "·ªô"),
    // ƒÉ (breve)
    ("aw", "ƒÉ"),
    ("aws", "·∫Ø"),
    ("awf", "·∫±"),
    ("awr", "·∫≥"),
    ("awx", "·∫µ"),
    ("awj", "·∫∑"),
    // ∆° (horn)
    ("ow", "∆°"),
    ("ows", "·ªõ"),
    ("owf", "·ªù"),
    ("owr", "·ªü"),
    ("owx", "·ª°"),
    ("owj", "·ª£"),
    // ∆∞ (horn)
    ("uw", "∆∞"),
    ("uws", "·ª©"),
    ("uwf", "·ª´"),
    ("uwr", "·ª≠"),
    ("uwx", "·ªØ"),
    ("uwj", "·ª±"),
    // ƒë
    ("dd", "ƒë"),
    ("DD", "ƒê"),
    ("Dd", "ƒê"),
];

const TELEX_REVERT: &[(&str, &str)] = &[
    // Mark revert
    ("ass", "as"),
    ("aff", "af"),
    ("arr", "ar"),
    ("axx", "ax"),
    ("ajj", "aj"),
    // Tone revert
    ("aaa", "aa"),
    ("eee", "ee"),
    ("ooo", "oo"),
    ("aww", "aw"),
    ("oww", "ow"),
    ("uww", "uw"),
];

const TELEX_UPPERCASE: &[(&str, &str)] = &[
    ("As", "√Å"),
    ("AS", "√Å"),
    ("Aa", "√Ç"),
    ("AA", "√Ç"),
    ("Aw", "ƒÇ"),
    ("AW", "ƒÇ"),
    ("Ow", "∆†"),
    ("Uw", "∆Ø"),
];

const TELEX_DELAYED: &[(&str, &str)] = &[
    ("tuw", "t∆∞"),
    ("tow", "t∆°"),
    ("taw", "tƒÉ"),
    ("tungw", "t∆∞ng"),
    ("tongw", "t∆°ng"),
    ("tuow", "t∆∞∆°"),
    ("truwowng", "tr∆∞∆°ng"),
];

// ============================================================
// VNI: SINGLE VOWELS WITH ALL MARKS
// ============================================================

const VNI_VOWELS: &[(&str, &str)] = &[
    // a: 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
    ("a", "a"),
    ("a1", "√°"),
    ("a2", "√†"),
    ("a3", "·∫£"),
    ("a4", "√£"),
    ("a5", "·∫°"),
    // e
    ("e", "e"),
    ("e1", "√©"),
    ("e2", "√®"),
    ("e3", "·∫ª"),
    ("e4", "·∫Ω"),
    ("e5", "·∫π"),
    // i
    ("i", "i"),
    ("i1", "√≠"),
    ("i2", "√¨"),
    ("i3", "·ªâ"),
    ("i4", "ƒ©"),
    ("i5", "·ªã"),
    // o
    ("o", "o"),
    ("o1", "√≥"),
    ("o2", "√≤"),
    ("o3", "·ªè"),
    ("o4", "√µ"),
    ("o5", "·ªç"),
    // u
    ("u", "u"),
    ("u1", "√∫"),
    ("u2", "√π"),
    ("u3", "·ªß"),
    ("u4", "≈©"),
    ("u5", "·ª•"),
    // y
    ("y", "y"),
    ("y1", "√Ω"),
    ("y2", "·ª≥"),
    ("y3", "·ª∑"),
    ("y4", "·ªπ"),
    ("y5", "·ªµ"),
];

const VNI_MODIFIED_VOWELS: &[(&str, &str)] = &[
    // √¢: 6=circumflex
    ("a6", "√¢"),
    ("a61", "·∫•"),
    ("a62", "·∫ß"),
    ("a63", "·∫©"),
    ("a64", "·∫´"),
    ("a65", "·∫≠"),
    // √™
    ("e6", "√™"),
    ("e61", "·∫ø"),
    ("e62", "·ªÅ"),
    ("e63", "·ªÉ"),
    ("e64", "·ªÖ"),
    ("e65", "·ªá"),
    // √¥
    ("o6", "√¥"),
    ("o61", "·ªë"),
    ("o62", "·ªì"),
    ("o63", "·ªï"),
    ("o64", "·ªó"),
    ("o65", "·ªô"),
    // ∆°: 7=horn
    ("o7", "∆°"),
    ("o71", "·ªõ"),
    ("o72", "·ªù"),
    ("o73", "·ªü"),
    ("o74", "·ª°"),
    ("o75", "·ª£"),
    // ∆∞
    ("u7", "∆∞"),
    ("u71", "·ª©"),
    ("u72", "·ª´"),
    ("u73", "·ª≠"),
    ("u74", "·ªØ"),
    ("u75", "·ª±"),
    // ƒÉ: 8=breve
    ("a8", "ƒÉ"),
    ("a81", "·∫Ø"),
    ("a82", "·∫±"),
    ("a83", "·∫≥"),
    ("a84", "·∫µ"),
    ("a85", "·∫∑"),
    // ƒë: 9
    ("d9", "ƒë"),
    ("D9", "ƒê"),
];

const VNI_REVERT: &[(&str, &str)] = &[
    ("a11", "a1"),
    ("a22", "a2"),
    ("a33", "a3"),
    ("a44", "a4"),
    ("a55", "a5"),
    ("a66", "a6"),
    ("e66", "e6"),
    ("o66", "o6"),
    ("o77", "o7"),
    ("u77", "u7"),
    ("a88", "a8"),
];

const VNI_UPPERCASE: &[(&str, &str)] = &[
    ("A1", "√Å"),
    ("A6", "√Ç"),
    ("O7", "∆†"),
    ("U7", "∆Ø"),
    ("A8", "ƒÇ"),
];

const VNI_DELAYED: &[(&str, &str)] = &[
    ("tu72", "t·ª´"),
    ("to61", "t·ªë"),
    ("ta81", "t·∫Ø"),
    ("d9ung1", "ƒë√∫ng"),
    ("du9ng1", "ƒë√∫ng"),
    ("dung91", "ƒë√∫ng"),
    ("dung19", "ƒë√∫ng"),
    ("D9ung1", "ƒê√∫ng"),
    ("Du9ng1", "ƒê√∫ng"),
    ("Dung91", "ƒê√∫ng"),
];

// ============================================================
// WORDS: Common Vietnamese words
// ============================================================

const TELEX_WORDS: &[(&str, &str)] = &[
    // Single vowel
    ("mej", "m·∫π"),
    ("bos", "b√≥"),
    ("cos", "c√≥"),
    ("laf", "l√†"),
    ("ddi", "ƒëi"),
    // w as ∆∞ shortcut
    ("thwr", "th·ª≠"),
    ("nhw", "nh∆∞"),
    ("tuwj", "t·ª±"),
    // Two vowels - closed syllable
    ("toans", "to√°n"),
    ("hoanf", "ho√†n"),
    ("tieens", "ti·∫øn"),
    ("muoons", "mu·ªën"),
    ("bieenr", "bi·ªÉn"),
    ("nguoonf", "ngu·ªìn"),
    ("cuoocj", "cu·ªôc"),
    ("thuoocj", "thu·ªôc"),
    // Two vowels - open syllable
    ("hoaf", "ho√†"),
    ("hoas", "ho√°"),
    ("quyf", "qu·ª≥"),
    ("quys", "qu√Ω"),
    ("mais", "m√°i"),
    ("maif", "m√†i"),
    ("ddois", "ƒë√≥i"),
    ("tuis", "t√∫i"),
    // Compound ∆∞∆°
    ("nguwowif", "ng∆∞·ªùi"),
    ("muwowif", "m∆∞·ªùi"),
    ("truwowngf", "tr∆∞·ªùng"),
    ("dduwowngf", "ƒë∆∞·ªùng"),
    ("ruwowuj", "r∆∞·ª£u"),
    ("buwowms", "b∆∞·ªõm"),
    ("nuwowcs", "n∆∞·ªõc"),
    // Compound i√™
    ("vieetj", "vi·ªát"),
    ("tieengs", "ti·∫øng"),
    ("bieenr", "bi·ªÉn"),
    ("ddieeuf", "ƒëi·ªÅu"),
    // Compound u√¥
    ("muoons", "mu·ªën"),
    ("cuoocj", "cu·ªôc"),
    ("buoonf", "bu·ªìn"),
    ("thuoocj", "thu·ªôc"),
    // Three vowels
    ("khuyeens", "khuy·∫øn"),
    ("nguyeenx", "nguy·ªÖn"),
    ("loaij", "lo·∫°i"),
    ("xoaif", "xo√†i"),
    // ƒë words
    ("ddeens", "ƒë·∫øn"),
    ("ddangf", "ƒë√†ng"),
    ("ddoongf", "ƒë·ªìng"),
    ("ddepj", "ƒë·∫πp"),
    ("ddor", "ƒë·ªè"),
    // Pronouns
    ("tooi", "t√¥i"),
    ("banj", "b·∫°n"),
    ("chij", "ch·ªã"),
    ("hoj", "h·ªç"),
    ("minhf", "m√¨nh"),
    // Verbs
    ("awn", "ƒÉn"),
    ("uoongs", "u·ªëng"),
    ("ngur", "ng·ªß"),
    ("lafm", "l√†m"),
    ("nois", "n√≥i"),
    ("bieets", "bi·∫øt"),
    ("hieeur", "hi·ªÉu"),
    ("yeeu", "y√™u"),
    ("thichs", "th√≠ch"),
    // Numbers
    ("mootj", "m·ªôt"),
    ("boons", "b·ªën"),
    ("nawm", "nƒÉm"),
    ("saus", "s√°u"),
    ("bayr", "b·∫£y"),
    ("tams", "t√°m"),
    ("chins", "ch√≠n"),
    ("trawm", "trƒÉm"),
    // Adjectives
    ("toots", "t·ªët"),
    ("xaaus", "x·∫•u"),
    ("lowns", "l·ªõn"),
    ("nhor", "nh·ªè"),
    ("daif", "d√†i"),
    ("ngawns", "ng·∫Øn"),
    ("lanhj", "l·∫°nh"),
    // Uppercase
    ("Chaof", "Ch√†o"),
    ("CHAOF", "CH√ÄO"),
    ("Vieetj", "Vi·ªát"),
    ("DDaats", "ƒê·∫•t"),
    ("DDAATS", "ƒê·∫§T"),
];

const VNI_WORDS: &[(&str, &str)] = &[
    // Pronouns
    ("to6i", "t√¥i"),
    ("ba5n", "b·∫°n"),
    ("chi5", "ch·ªã"),
    ("no1", "n√≥"),
    ("ho5", "h·ªç"),
    // Verbs
    ("la2", "l√†"),
    ("co1", "c√≥"),
    ("d9i", "ƒëi"),
    ("d9e61n", "ƒë·∫øn"),
    ("ve62", "v·ªÅ"),
    ("a8n", "ƒÉn"),
    ("uo61ng", "u·ªëng"),
    ("ngu3", "ng·ªß"),
    ("la2m", "l√†m"),
    ("no1i", "n√≥i"),
    ("bie61t", "bi·∫øt"),
    ("hie63u", "hi·ªÉu"),
    ("ye6u", "y√™u"),
    // Compound ∆∞∆°
    ("ngu7o7i2", "ng∆∞·ªùi"),
    ("mu7o7i2", "m∆∞·ªùi"),
    ("tru7o7ng2", "tr∆∞·ªùng"),
    ("d9u7o7ng2", "ƒë∆∞·ªùng"),
    ("lu7o7i4", "l∆∞·ª°i"),
    // Compound i√™
    ("vie65t", "vi·ªát"),
    ("tie61ng", "ti·∫øng"),
    ("bie63n", "bi·ªÉn"),
    ("d9ie62u", "ƒëi·ªÅu"),
    // Compound u√¥
    ("muo61n", "mu·ªën"),
    ("cuo65c", "cu·ªôc"),
    ("buo62n", "bu·ªìn"),
    ("thuo65c", "thu·ªôc"),
    // Three vowels
    ("khuye63n", "khuy·ªÉn"),
    ("nguye64n", "nguy·ªÖn"),
    ("ngoa1i", "ngo√°i"),
    ("ru7o7u5", "r∆∞·ª£u"),
    // Uppercase
    ("Cha2o", "Ch√†o"),
    ("CHA2O", "CH√ÄO"),
    ("Ngu7o7i2", "Ng∆∞·ªùi"),
    ("Vie65t", "Vi·ªát"),
    ("D9a61t", "ƒê·∫•t"),
    // Delayed tone
    ("toi6", "t√¥i"),
    ("toi61", "t·ªëi"),
    ("nguoi7", "ng∆∞∆°i"),
    ("nguoi72", "ng∆∞·ªùi"),
    ("muon6", "mu√¥n"),
    ("muon61", "mu·ªën"),
];

// ============================================================
// CONSONANT-ONLY & EDGE CASES
// ============================================================

const TELEX_EDGE: &[(&str, &str)] = &[
    // Consonant only
    ("bcd", "bcd"),
    ("xyz", "xyz"),
    // Mark without vowel
    ("bs", "bs"),
    ("ts", "ts"),
    // Consonant clusters
    ("nguyeenx", "nguy·ªÖn"),
    ("nhuwngx", "nh·ªØng"),
    ("phaatj", "ph·∫≠t"),
    ("khoongf", "kh·ªìng"),
    ("ghees", "gh·∫ø"),
    ("truwowcs", "tr∆∞·ªõc"),
    // dd‚Üíƒë edge cases
    ("ddf", "ƒëf"),
];

// ============================================================
// TEST FUNCTIONS
// ============================================================

#[test]
fn telex_single_vowels() {
    telex(TELEX_VOWELS);
}

#[test]
fn telex_modified_vowels() {
    telex(TELEX_MODIFIED_VOWELS);
}

#[test]
fn telex_revert() {
    telex(TELEX_REVERT);
}

#[test]
fn telex_uppercase() {
    telex(TELEX_UPPERCASE);
}

#[test]
fn telex_delayed_input() {
    telex(TELEX_DELAYED);
}

#[test]
fn telex_words() {
    telex(TELEX_WORDS);
}

#[test]
fn telex_edge_cases() {
    telex(TELEX_EDGE);
}

#[test]
fn vni_single_vowels() {
    vni(VNI_VOWELS);
}

#[test]
fn vni_modified_vowels() {
    vni(VNI_MODIFIED_VOWELS);
}

#[test]
fn vni_revert() {
    vni(VNI_REVERT);
}

#[test]
fn vni_uppercase() {
    vni(VNI_UPPERCASE);
}

#[test]
fn vni_delayed_input() {
    vni(VNI_DELAYED);
}

#[test]
fn vni_words() {
    vni(VNI_WORDS);
}
</file>

<file path="core/Cargo.toml">
[package]
name = "gonhanh-core"
version = "0.1.0"
edition = "2021"
authors = ["Kha Phan <nhatkha1407@gmail.com>"]
license = "GPL-3.0-or-later"
description = "G√µ Nhanh - Vietnamese input method core engine"
repository = "https://github.com/khaphanspace/gonhanh.org"

[lib]
name = "gonhanh_core"
crate-type = ["staticlib", "cdylib", "rlib"]  # Add rlib for tests

[dependencies]
# Minimal dependencies for core engine

[dev-dependencies]
rstest = "0.18"

[profile.release]
opt-level = "z"          # Optimize for size
lto = true               # Link-time optimization
codegen-units = 1        # Better optimization
strip = true             # Strip symbols
panic = "abort"          # Smaller binary
</file>

<file path="platforms/macos/AppMetadata.swift">
import Foundation
import AppKit

// MARK: - App Metadata (Centralized)
// All project metadata in one place for consistency

enum AppMetadata {
    static let name = "G√µ Nhanh"

    // App Logo - d√πng chung cho m·ªçi n∆°i
    static var logo: NSImage {
        NSImage(named: "AppLogo") ?? NSApp.applicationIconImage ?? NSImage()
    }
    static let displayName = "G√µ Nhanh"
    static let tagline = "B·ªô g√µ ti·∫øng Vi·ªát hi·ªáu su·∫•t cao"
    static let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0.0"
    static let buildNumber = Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "1"

    // Author
    static let author = "Kha Phan"
    static let authorEmail = "nhatkha1407@gmail.com"

    // Links
    static let website = "https://gonhanh.org"
    static let repository = "https://github.com/khaphanspace/gonhanh.org"
    static let issuesURL = "https://github.com/khaphanspace/gonhanh.org/issues"
    static let authorLinkedin = "https://www.linkedin.com/in/khaphanspace"

    // Legal
    static let copyright = "Copyright ¬© 2025 \(author). All rights reserved."
    static let license = "GPL-3.0-or-later"

    // Tech
    static let techStack = "Rust + SwiftUI"

    // Credits for About panel
    static var credits: String {
        """
        \(tagline)

        T√°c gi·∫£: \(author)

        Made with Rust + SwiftUI
        """
    }

    // Full about text
    static var aboutText: String {
        """
        \(displayName) v\(version)

        \(tagline)

        T√°c gi·∫£: \(author)
        Website: \(website)
        GitHub: \(repository)

        \(copyright)
        License: \(license)
        """
    }
}

// MARK: - Settings Keys (Shared)

enum SettingsKey {
    static let enabled = "gonhanh.enabled"
    static let method = "gonhanh.method"
    static let hasCompletedOnboarding = "gonhanh.onboarding.completed"
    static let permissionGranted = "gonhanh.permission.granted"
}

// MARK: - Input Mode

enum InputMode: Int, CaseIterable {
    case telex = 0
    case vni = 1

    var name: String {
        switch self {
        case .telex: return "Telex"
        case .vni: return "VNI"
        }
    }

    var shortName: String {
        switch self {
        case .telex: return "T"
        case .vni: return "V"
        }
    }

    var description: String {
        switch self {
        case .telex: return "aw, ow, w, s, f, r, x, j"
        case .vni: return "a8, o9, 1-5"
        }
    }

    var fullDescription: String {
        switch self {
        case .telex: return "Telex (\(description))"
        case .vni: return "VNI (\(description))"
        }
    }
}
</file>

<file path="platforms/macos/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>en</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundleDisplayName</key>
    <string>G√µ Nhanh</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>$(MARKETING_VERSION)</string>
    <key>CFBundleVersion</key>
    <string>$(CURRENT_PROJECT_VERSION)</string>
    <key>LSMinimumSystemVersion</key>
    <string>$(MACOSX_DEPLOYMENT_TARGET)</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSHumanReadableCopyright</key>
    <string>Copyright ¬© 2025 Kha Phan. All rights reserved.</string>
    <key>NSPrincipalClass</key>
    <string>NSApplication</string>
    <key>NSAppleEventsUsageDescription</key>
    <string>G√µ Nhanh needs access to send keyboard events for Vietnamese input.</string>
</dict>
</plist>
</file>

<file path="platforms/macos/LaunchAtLogin.swift">
import Foundation
import ServiceManagement

// MARK: - Debug Logging

private func debugLog(_ message: String) {
    #if DEBUG
    print(message)
    #endif
}

// MARK: - Launch at Login Manager

/// Protocol for launch at login functionality (enables testing)
protocol LaunchAtLoginProtocol {
    var isEnabled: Bool { get }
    func enable() throws
    func disable() throws
}

/// Manages app's launch at login state using SMAppService
class LaunchAtLoginManager: LaunchAtLoginProtocol {
    static let shared = LaunchAtLoginManager()

    private init() {}

    /// Check if launch at login is currently enabled
    var isEnabled: Bool {
        if #available(macOS 13.0, *) {
            return SMAppService.mainApp.status == .enabled
        }
        return false
    }

    /// Enable launch at login
    func enable() throws {
        if #available(macOS 13.0, *) {
            if SMAppService.mainApp.status != .enabled {
                try SMAppService.mainApp.register()
                debugLog("[LaunchAtLogin] Enabled successfully")
            }
        } else {
            debugLog("[LaunchAtLogin] Requires macOS 13.0+")
        }
    }

    /// Disable launch at login
    func disable() throws {
        if #available(macOS 13.0, *) {
            if SMAppService.mainApp.status == .enabled {
                try SMAppService.mainApp.unregister()
                debugLog("[LaunchAtLogin] Disabled successfully")
            }
        }
    }

    /// Get current status as string (for debugging)
    var statusDescription: String {
        if #available(macOS 13.0, *) {
            switch SMAppService.mainApp.status {
            case .enabled:
                return "enabled"
            case .notFound:
                return "notFound"
            case .notRegistered:
                return "notRegistered"
            case .requiresApproval:
                return "requiresApproval"
            @unknown default:
                return "unknown"
            }
        }
        return "unsupported"
    }
}

// MARK: - Mock for Testing

/// Mock implementation for unit testing
class MockLaunchAtLoginManager: LaunchAtLoginProtocol {
    private(set) var isEnabled: Bool = false
    private(set) var enableCallCount = 0
    private(set) var disableCallCount = 0
    var shouldThrowOnEnable = false
    var shouldThrowOnDisable = false

    func enable() throws {
        enableCallCount += 1
        if shouldThrowOnEnable {
            throw LaunchAtLoginError.registrationFailed
        }
        isEnabled = true
    }

    func disable() throws {
        disableCallCount += 1
        if shouldThrowOnDisable {
            throw LaunchAtLoginError.unregistrationFailed
        }
        isEnabled = false
    }

    func reset() {
        isEnabled = false
        enableCallCount = 0
        disableCallCount = 0
        shouldThrowOnEnable = false
        shouldThrowOnDisable = false
    }
}

enum LaunchAtLoginError: Error {
    case registrationFailed
    case unregistrationFailed
}

// MARK: - Settings Integration

extension LaunchAtLoginManager {
    /// Key for UserDefaults (backup/fallback)
    static let userDefaultsKey = "launchAtLoginEnabled"

    /// Sync state with UserDefaults
    func syncWithUserDefaults() {
        UserDefaults.standard.set(isEnabled, forKey: Self.userDefaultsKey)
    }

    /// Get cached state from UserDefaults (for UI before SMAppService check)
    var cachedState: Bool {
        UserDefaults.standard.bool(forKey: Self.userDefaultsKey)
    }
}
</file>

<file path="platforms/windows/GoNhanh/Views/OnboardingWindow.xaml.cs">
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using GoNhanh.Core;
using GoNhanh.Services;

namespace GoNhanh.Views;

/// <summary>
/// Onboarding window for first-time setup
/// </summary>
public partial class OnboardingWindow : Window
{
    private readonly SettingsService _settings;
    private readonly Ellipse[] _dots;

    public OnboardingWindow(SettingsService settings)
    {
        InitializeComponent();
        _settings = settings;
        _dots = new[] { Dot1, Dot2, Dot3 };
        UpdateDots();
    }

    private void NextPage_Click(object sender, RoutedEventArgs e)
    {
        if (PageTabs.SelectedIndex < PageTabs.Items.Count - 1)
        {
            PageTabs.SelectedIndex++;
            UpdateDots();
        }
    }

    private void PrevPage_Click(object sender, RoutedEventArgs e)
    {
        if (PageTabs.SelectedIndex > 0)
        {
            PageTabs.SelectedIndex--;
            UpdateDots();
        }
    }

    private void SelectTelex_Click(object sender, MouseButtonEventArgs e)
    {
        OnboardTelexRadio.IsChecked = true;
    }

    private void SelectVni_Click(object sender, MouseButtonEventArgs e)
    {
        OnboardVniRadio.IsChecked = true;
    }

    private void Finish_Click(object sender, RoutedEventArgs e)
    {
        // Save selected method
        _settings.CurrentMethod = OnboardTelexRadio.IsChecked == true
            ? Core.InputMethod.Telex
            : Core.InputMethod.VNI;
        _settings.Save();

        Close();
    }

    private void UpdateDots()
    {
        var activeBrush = (SolidColorBrush)FindResource("PrimaryBrush");
        var inactiveBrush = new SolidColorBrush(System.Windows.Media.Color.FromRgb(229, 231, 235)); // #E5E7EB

        for (int i = 0; i < _dots.Length; i++)
        {
            _dots[i].Fill = i == PageTabs.SelectedIndex ? activeBrush : inactiveBrush;
        }
    }
}
</file>

<file path="CONTRIBUTING.md">
# Contributing to G√µ Nhanh

Thank you for your interest in contributing! üéâ

## Getting Started

1. Fork the repository
2. Clone your fork: `git clone https://github.com/khaphanspace/gonhanh.org`
3. Run setup: `./scripts/setup.sh`
4. Create a branch: `git checkout -b feature/my-feature`

## Development Workflow

### For Rust Core

```bash
cd core

# Make changes to src/

# Run tests
cargo test

# Check formatting
cargo fmt --check

# Run linter
cargo clippy

# Build
cargo build --release
```

### For macOS UI

1. Open `platforms/macos/GoNhanh.xcodeproj` in Xcode
2. Make changes to Swift files
3. Test in Xcode
4. Build and run

## Coding Standards

### Rust

- Follow [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- Run `cargo fmt` before committing
- No `cargo clippy` warnings
- Add tests for new features
- Document public APIs

### Swift

- Follow [Swift Style Guide](https://google.github.io/swift/)
- Use SwiftUI best practices
- Add comments for complex logic

## Commit Messages

Follow [Conventional Commits](https://www.conventionalcommits.org/):

```
feat: add VNI support
fix: keyboard hook on Sonoma
docs: update installation guide
test: add engine tests
```

## Pull Requests

1. Update documentation if needed
2. Add tests for new features
3. Ensure all tests pass
4. Update CHANGELOG.md
5. Create PR with clear description

### PR Template

```markdown
## Description

Brief description of changes

## Type of Change

- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing

How did you test this?

## Checklist

- [ ] Tests pass
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
```

## Code Review

- Be respectful and constructive
- Focus on code, not the person
- Suggest improvements, don't demand
- Approve when ready

## Questions?

Open an issue or discussion on GitHub!
</file>

<file path="core/src/engine/buffer.rs">
//! Typing buffer

pub const MAX: usize = 32;

use crate::utils;

/// Single character in buffer
///
/// Modifiers:
/// - `tone`: vowel diacritics (^, horn, breve)
/// - `mark`: tone marks (s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng)
/// - `stroke`: consonant stroke (d ‚Üí ƒë)
#[derive(Clone, Copy, Default)]
pub struct Char {
    pub key: u16,
    pub caps: bool,
    pub tone: u8,     // 0=none, 1=circumflex(^), 2=horn/breve
    pub mark: u8,     // 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
    pub stroke: bool, // true if 'd' ‚Üí 'ƒë' (stroke through)
}

impl Char {
    pub fn new(key: u16, caps: bool) -> Self {
        Self {
            key,
            caps,
            tone: 0,
            mark: 0,
            stroke: false,
        }
    }

    pub fn has_tone(&self) -> bool {
        self.tone > 0
    }

    pub fn has_mark(&self) -> bool {
        self.mark > 0
    }
}

/// Typing buffer
pub struct Buffer {
    data: [Char; MAX],
    len: usize,
}

impl Default for Buffer {
    fn default() -> Self {
        Self::new()
    }
}

impl Buffer {
    pub fn new() -> Self {
        Self {
            data: [Char::default(); MAX],
            len: 0,
        }
    }

    pub fn push(&mut self, c: Char) {
        if self.len < MAX {
            self.data[self.len] = c;
            self.len += 1;
        }
    }

    pub fn pop(&mut self) -> Option<Char> {
        if self.len > 0 {
            self.len -= 1;
            Some(self.data[self.len])
        } else {
            None
        }
    }

    pub fn clear(&mut self) {
        self.len = 0;
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn get(&self, i: usize) -> Option<&Char> {
        if i < self.len {
            Some(&self.data[i])
        } else {
            None
        }
    }

    pub fn get_mut(&mut self, i: usize) -> Option<&mut Char> {
        if i < self.len {
            Some(&mut self.data[i])
        } else {
            None
        }
    }

    pub fn last(&self) -> Option<&Char> {
        if self.len > 0 {
            Some(&self.data[self.len - 1])
        } else {
            None
        }
    }

    /// Find indices of vowels in buffer
    pub fn find_vowels(&self) -> Vec<usize> {
        use crate::data::keys;
        (0..self.len)
            .filter(|&i| keys::is_vowel(self.data[i].key))
            .collect()
    }

    /// Find vowel position by key (from end)
    pub fn find_vowel_by_key(&self, key: u16) -> Option<usize> {
        use crate::data::keys;
        (0..self.len)
            .rev()
            .find(|&i| self.data[i].key == key && keys::is_vowel(key))
    }

    /// Iterate over chars
    pub fn iter(&self) -> std::slice::Iter<'_, Char> {
        self.data[..self.len].iter()
    }

    /// Convert buffer to lowercase string (for shortcut matching)
    pub fn to_lowercase_string(&self) -> String {
        self.data[..self.len]
            .iter()
            .filter_map(|c| utils::key_to_char(c.key, false))
            .collect()
    }

    /// Convert buffer to string preserving case (for shortcut case matching)
    pub fn to_string_preserve_case(&self) -> String {
        use crate::data::keys;
        self.data[..self.len]
            .iter()
            .filter_map(|c| {
                let ch = match c.key {
                    keys::A => 'a',
                    keys::B => 'b',
                    keys::C => 'c',
                    keys::D => 'd',
                    keys::E => 'e',
                    keys::F => 'f',
                    keys::G => 'g',
                    keys::H => 'h',
                    keys::I => 'i',
                    keys::J => 'j',
                    keys::K => 'k',
                    keys::L => 'l',
                    keys::M => 'm',
                    keys::N => 'n',
                    keys::O => 'o',
                    keys::P => 'p',
                    keys::Q => 'q',
                    keys::R => 'r',
                    keys::S => 's',
                    keys::T => 't',
                    keys::U => 'u',
                    keys::V => 'v',
                    keys::W => 'w',
                    keys::X => 'x',
                    keys::Y => 'y',
                    keys::Z => 'z',
                    _ => return None,
                };
                Some(if c.caps { ch.to_ascii_uppercase() } else { ch })
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_buffer() {
        let mut buf = Buffer::new();
        assert!(buf.is_empty());

        buf.push(Char::new(0, false));
        buf.push(Char::new(1, true));
        assert_eq!(buf.len(), 2);

        let c = buf.pop().unwrap();
        assert_eq!(c.key, 1);
        assert!(c.caps);

        buf.clear();
        assert!(buf.is_empty());
    }
}
</file>

<file path="core/src/engine/transform.rs">
//! Vietnamese Transformation
//!
//! Pattern-based transformation for Vietnamese diacritics.
//! Scans entire buffer instead of case-by-case processing.

use super::buffer::Buffer;
use crate::data::vowel::Phonology;
use crate::data::{
    chars::{mark, tone},
    keys,
};
use crate::utils;

/// Modifier type detected from key
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ModifierType {
    /// Tone diacritic: circumflex (^), horn, breve
    Tone(u8),
    /// Tone mark: s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng
    Mark(u8),
    /// Stroke: d ‚Üí ƒë
    Stroke,
    /// Remove last diacritic
    Remove,
}

/// Transformation result
#[derive(Debug)]
pub struct TransformResult {
    /// Positions that were modified
    pub modified_positions: Vec<usize>,
    /// Whether transformation was applied
    pub applied: bool,
}

impl TransformResult {
    pub fn none() -> Self {
        Self {
            modified_positions: vec![],
            applied: false,
        }
    }

    pub fn success(positions: Vec<usize>) -> Self {
        Self {
            modified_positions: positions,
            applied: true,
        }
    }

    pub fn earliest_position(&self) -> Option<usize> {
        self.modified_positions.iter().copied().min()
    }
}

/// Apply tone diacritic transformation (^, ∆°, ∆∞, ƒÉ)
///
/// Pattern-based: scans buffer for matching vowels
pub fn apply_tone(buf: &mut Buffer, key: u16, tone_value: u8, method: u8) -> TransformResult {
    let buffer_keys: Vec<u16> = buf.iter().map(|c| c.key).collect();

    // Find target vowels based on key and method
    let targets = find_tone_targets(&buffer_keys, key, tone_value, method);

    if targets.is_empty() {
        return TransformResult::none();
    }

    // Apply tone to targets
    let mut positions = vec![];
    for pos in &targets {
        if let Some(c) = buf.get_mut(*pos) {
            if c.tone == tone::NONE {
                c.tone = tone_value;
                positions.push(*pos);
            }
        }
    }

    if positions.is_empty() {
        TransformResult::none()
    } else {
        // After adding tone, reposition mark if needed
        reposition_mark_if_needed(buf);
        TransformResult::success(positions)
    }
}

/// Find which vowel positions should receive the tone modifier
fn find_tone_targets(buffer_keys: &[u16], key: u16, tone_value: u8, method: u8) -> Vec<usize> {
    let mut targets = vec![];

    // Find all vowel positions
    let vowel_positions: Vec<usize> = buffer_keys
        .iter()
        .enumerate()
        .filter(|(_, &k)| keys::is_vowel(k))
        .map(|(i, _)| i)
        .collect();

    if vowel_positions.is_empty() {
        return targets;
    }

    // Telex patterns
    if method == 0 {
        // aa, ee, oo ‚Üí circumflex
        if tone_value == tone::CIRCUMFLEX && matches!(key, keys::A | keys::E | keys::O) {
            // Find matching vowel (same key)
            for &pos in vowel_positions.iter().rev() {
                if buffer_keys[pos] == key {
                    targets.push(pos);
                    break;
                }
            }
        }
        // w ‚Üí horn/breve
        else if tone_value == tone::HORN && key == keys::W {
            targets = find_horn_targets(buffer_keys, &vowel_positions);
        }
    }
    // VNI patterns
    else {
        // 6 ‚Üí circumflex for a, e, o
        if tone_value == tone::CIRCUMFLEX && key == keys::N6 {
            for &pos in vowel_positions.iter().rev() {
                if matches!(buffer_keys[pos], keys::A | keys::E | keys::O) {
                    targets.push(pos);
                    break;
                }
            }
        }
        // 7 ‚Üí horn for o, u
        else if tone_value == tone::HORN && key == keys::N7 {
            targets = find_horn_targets(buffer_keys, &vowel_positions);
        }
        // 8 ‚Üí breve for a only
        else if tone_value == tone::HORN && key == keys::N8 {
            for &pos in vowel_positions.iter().rev() {
                if buffer_keys[pos] == keys::A {
                    targets.push(pos);
                    break;
                }
            }
        }
    }

    targets
}

/// Find targets for horn modifier (∆°, ∆∞, ∆∞∆° compound)
///
/// Special: if "uo" adjacent, apply horn to BOTH (∆∞∆° compound)
fn find_horn_targets(buffer_keys: &[u16], vowel_positions: &[usize]) -> Vec<usize> {
    let mut targets = vec![];

    // Check for uo compound first
    let len = vowel_positions.len();
    if len >= 2 {
        for i in 0..len - 1 {
            let pos1 = vowel_positions[i];
            let pos2 = vowel_positions[i + 1];

            // Must be adjacent positions
            if pos2 == pos1 + 1 {
                let k1 = buffer_keys[pos1];
                let k2 = buffer_keys[pos2];

                // uo or ou compound
                if (k1 == keys::U && k2 == keys::O) || (k1 == keys::O && k2 == keys::U) {
                    // Apply to both
                    targets.push(pos1);
                    targets.push(pos2);
                    return targets;
                }
            }
        }
    }

    // No compound found, apply to single vowel (last a, o, or u)
    for &pos in vowel_positions.iter().rev() {
        let k = buffer_keys[pos];
        if matches!(k, keys::A | keys::O | keys::U) {
            targets.push(pos);
            break;
        }
    }

    targets
}

/// Apply mark transformation (s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng)
pub fn apply_mark(buf: &mut Buffer, mark_value: u8, modern: bool) -> TransformResult {
    let vowels = utils::collect_vowels(buf);
    if vowels.is_empty() {
        return TransformResult::none();
    }

    // Find position using phonology rules
    let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
    let has_final = utils::has_final_consonant(buf, last_vowel_pos);
    let has_qu = utils::has_qu_initial(buf);
    let pos = Phonology::find_tone_position(&vowels, has_final, modern, has_qu);

    // Clear any existing mark first
    for v in &vowels {
        if let Some(c) = buf.get_mut(v.pos) {
            c.mark = mark::NONE;
        }
    }

    // Apply new mark
    if let Some(c) = buf.get_mut(pos) {
        c.mark = mark_value;
        return TransformResult::success(vec![pos]);
    }

    TransformResult::none()
}

/// Apply stroke transformation (d ‚Üí ƒë)
///
/// Scans buffer for 'd' at any position
pub fn apply_stroke(buf: &mut Buffer) -> TransformResult {
    // Find first 'd' that hasn't been stroked
    for i in 0..buf.len() {
        if let Some(c) = buf.get_mut(i) {
            if c.key == keys::D && !c.stroke {
                c.stroke = true;
                return TransformResult::success(vec![i]);
            }
        }
    }
    TransformResult::none()
}

/// Remove last diacritic (mark first, then tone)
pub fn apply_remove(buf: &mut Buffer) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    // Try to remove mark first
    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.mark > mark::NONE {
                c.mark = mark::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    // Then try to remove tone
    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.tone > tone::NONE {
                c.tone = tone::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert tone transformation
pub fn revert_tone(buf: &mut Buffer, target_key: u16) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.key == target_key && c.tone > tone::NONE {
                c.tone = tone::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert mark transformation
pub fn revert_mark(buf: &mut Buffer) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.mark > mark::NONE {
                c.mark = mark::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert stroke transformation
pub fn revert_stroke(buf: &mut Buffer) -> TransformResult {
    // Find stroked 'd' and un-stroke it
    for i in 0..buf.len() {
        if let Some(c) = buf.get_mut(i) {
            if c.key == keys::D && c.stroke {
                c.stroke = false;
                return TransformResult::success(vec![i]);
            }
        }
    }
    TransformResult::none()
}

/// Reposition mark after tone change if needed
fn reposition_mark_if_needed(buf: &mut Buffer) {
    // Find current mark
    let mark_info: Option<(usize, u8)> = buf
        .iter()
        .enumerate()
        .find(|(_, c)| c.mark > 0)
        .map(|(i, c)| (i, c.mark));

    if let Some((old_pos, mark_value)) = mark_info {
        let vowels = utils::collect_vowels(buf);
        if vowels.is_empty() {
            return;
        }

        let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
        let has_final = utils::has_final_consonant(buf, last_vowel_pos);
        let has_qu = utils::has_qu_initial(buf);
        let new_pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

        if new_pos != old_pos {
            // Clear old mark
            if let Some(c) = buf.get_mut(old_pos) {
                c.mark = 0;
            }
            // Set new mark
            if let Some(c) = buf.get_mut(new_pos) {
                c.mark = mark_value;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::super::buffer::Char;
    use super::*;

    fn setup_buffer(s: &str) -> Buffer {
        let mut buf = Buffer::new();
        for ch in s.chars() {
            let key = match ch.to_ascii_lowercase() {
                'a' => keys::A,
                'b' => keys::B,
                'c' => keys::C,
                'd' => keys::D,
                'e' => keys::E,
                'g' => keys::G,
                'h' => keys::H,
                'i' => keys::I,
                'n' => keys::N,
                'o' => keys::O,
                'u' => keys::U,
                _ => continue,
            };
            buf.push(Char::new(key, ch.is_uppercase()));
        }
        buf
    }

    #[test]
    fn test_apply_stroke() {
        let mut buf = setup_buffer("do");
        let result = apply_stroke(&mut buf);
        assert!(result.applied);
        assert!(buf.get(0).unwrap().stroke);
    }

    #[test]
    fn test_apply_stroke_anywhere() {
        // "dod" should stroke the first 'd'
        let mut buf = setup_buffer("dod");
        let result = apply_stroke(&mut buf);
        assert!(result.applied);
        assert!(buf.get(0).unwrap().stroke); // First d is stroked
    }

    #[test]
    fn test_apply_mark() {
        let mut buf = setup_buffer("an");
        let result = apply_mark(&mut buf, mark::SAC, true);
        assert!(result.applied);
        assert_eq!(buf.get(0).unwrap().mark, mark::SAC);
    }

    #[test]
    fn test_uo_compound() {
        let mut buf = setup_buffer("duoc");
        let result = apply_tone(&mut buf, keys::W, tone::HORN, 0);
        assert!(result.applied);
        // Both u and o should have horn
        assert_eq!(buf.get(1).unwrap().tone, tone::HORN); // u
        assert_eq!(buf.get(2).unwrap().tone, tone::HORN); // o
    }
}
</file>

<file path="core/src/input/vni.rs">
//! VNI Input Method
//!
//! Key mappings:
//! - Marks: 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
//! - Tones: 6=circumflex, 7=horn, 8=breve
//! - Stroke: 9
//! - Remove: 0

use super::{Method, ToneType, BREVE_TARGETS, CIRCUMFLEX_TARGETS, HORN_TARGETS_VNI};
use crate::data::keys;

pub struct Vni;

impl Method for Vni {
    fn mark(&self, key: u16) -> Option<u8> {
        match key {
            keys::N1 => Some(1), // s·∫Øc
            keys::N2 => Some(2), // huy·ªÅn
            keys::N3 => Some(3), // h·ªèi
            keys::N4 => Some(4), // ng√£
            keys::N5 => Some(5), // n·∫∑ng
            _ => None,
        }
    }

    fn tone(&self, key: u16) -> Option<ToneType> {
        match key {
            keys::N6 => Some(ToneType::Circumflex),
            keys::N7 => Some(ToneType::Horn),
            keys::N8 => Some(ToneType::Breve),
            _ => None,
        }
    }

    fn tone_targets(&self, key: u16) -> &'static [u16] {
        match key {
            keys::N6 => CIRCUMFLEX_TARGETS,
            keys::N7 => HORN_TARGETS_VNI,
            keys::N8 => BREVE_TARGETS,
            _ => &[],
        }
    }

    fn stroke(&self, key: u16) -> bool {
        key == keys::N9
    }

    fn remove(&self, key: u16) -> bool {
        key == keys::N0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_marks() {
        let v = Vni;
        assert_eq!(v.mark(keys::N1), Some(1));
        assert_eq!(v.mark(keys::N5), Some(5));
        assert_eq!(v.mark(keys::A), None);
    }

    #[test]
    fn test_tones() {
        let v = Vni;
        assert_eq!(v.tone(keys::N6), Some(ToneType::Circumflex));
        assert_eq!(v.tone(keys::N7), Some(ToneType::Horn));
        assert_eq!(v.tone(keys::N8), Some(ToneType::Breve));
    }

    #[test]
    fn test_stroke() {
        let v = Vni;
        assert!(v.stroke(keys::N9));
        assert!(!v.stroke(keys::D));
    }
}
</file>

<file path="core/tests/paragraph_test.rs">
mod common;
use common::{telex, vni};

#[test]
fn paragraph_telex() {
    // Telex patterns from typing_test.rs:
    // - √¢ = aa, √™ = ee, √¥ = oo
    // - ƒÉ = aw, ∆° = ow, ∆∞ = uw (after consonant)
    // - i√™ = iee, ∆∞∆° = uwow
    // - ƒë = dd
    // - s·∫Øc/huy·ªÅn/h·ªèi/ng√£/n·∫∑ng = s/f/r/x/j
    //
    // Note: Foreign words (Google, Docs, expect, deadline, burnout) are typed literally
    // and WILL be transformed by the engine because they contain valid Vietnamese patterns:
    // - oo ‚Üí √¥ (Google ‚Üí G√¥gle)
    // - s after vowel ‚Üí s·∫Øc (Docs ‚Üí D√≥c)
    // - x ‚Üí ng√£, second e ‚Üí circumflex (expect ‚Üí ·ªÖpct)
    // - second d triggers stroke on first d (deadline ‚Üí ƒëealine)
    // - r ‚Üí h·ªèi (burnout ‚Üí b·ªßnout)
    //
    // www behavior: w‚Üí∆∞, ww‚Üíw (revert), www‚Üíww (subsequent w added normally)
    let input = "Tooi ddax thuwr raats nhieeuf booj gox tieengs Vieetj treen macOS nhuwng toanf gawpj bug khos chiuj. Gox treen Chrome thif bij dinhs chuwx \"aaa\" thanhf \"a√¢\", gox www thif thanhf \"∆∞∆∞∆∞\", vaof Claude Code thif lawpj kys tuwj lung tung, conf Google Docs thif cuws maats daaus giuwax chuwngf. Frustrated voo cungf neen tooi quyeets ddinhj tuwj build Gox Nhanh - booj gox handle muwowjt maf ngay car nhuwngx tuwf khos nhuw: giuwowngf, khuyru tay, khuyeens khichs, chuyeenr ddooir, nguyeenj vongj, huyr hoaij, quynhf hoa, khoer khoawns, loaf xoaf, nghieeng ngar. Giowf tooi cos theer thoair mais prompt Claude Code bawngf tieengs Vieetj, soanj proposal hay update report maf khoong stress veef typo nuwax. DDungs nhuw expect, deadline gaaps maf gox sai hoaif thif burnout laf cais chawcs. Legit recommend cho anh em dev, xaif laf ghieenf luoon as! Neeus cos feedback gif thif inbox tooi qua nhatkha1407@gmail.com nha.";
    let expected = "T√¥i ƒë√£ th·ª≠ r·∫•t nhi·ªÅu b·ªô g√µ ti·∫øng Vi·ªát tr√™n macOS nh∆∞ng to√†n g·∫∑p bug kh√≥ ch·ªãu. G√µ tr√™n Chrome th√¨ b·ªã d√≠nh ch·ªØ \"aa\" th√†nh \"a√¢\", g√µ ww th√¨ th√†nh \"∆∞∆∞∆∞\", v√†o Claude Code th√¨ l·∫∑p k√Ω t·ª± lung tung, c√≤n G√¥gle D√≥c th√¨ c·ª© m·∫•t d·∫•u gi·ªØa ch·ª´ng. Frustrated v√¥ c√πng n√™n t√¥i quy·∫øt ƒë·ªãnh t·ª± build G√µ Nhanh - b·ªô g√µ handle m∆∞·ª£t m√† ngay c·∫£ nh·ªØng t·ª´ kh√≥ nh∆∞: gi·ª´∆°ng, khu·ª∑u tay, khuy·∫øn kh√≠ch, chuy·ªÉn ƒë·ªïi, nguy·ªán v·ªçng, hu·ª∑ ho·∫°i, qu·ª≥nh hoa, kho·∫ª kho·∫Øn, lo√† xo√†, nghi√™ng ng·∫£. Gi·ªù t√¥i c√≥ th·ªÉ tho·∫£i m√°i prompt Claude Code b·∫±ng ti·∫øng Vi·ªát, so·∫°n proposal hay update report m√† kh√¥ng stress v·ªÅ typo n·ªØa. ƒê√∫ng nh∆∞ ·ªÖpct, ƒëealine g·∫•p m√† g√µ sai ho√†i th√¨ b·ªßnout l√† c√°i ch·∫Øc. Legit recommend cho anh em dev, x√†i l√† ghi·ªÅn lu√¥n √°! N·∫øu c√≥ feedback g√¨ th√¨ inbox t√¥i qua nhatkha1407@gmail.com nha.";

    telex(&[(input, expected)]);
}

#[test]
fn paragraph_vni() {
    // VNI patterns:
    // - 6 = circumflex (√¢, √™, √¥), 7 = horn (∆∞, ∆°), 8 = breve (ƒÉ)
    // - 9 = stroke (ƒë)
    // - 1/2/3/4/5 = s·∫Øc/huy·ªÅn/h·ªèi/ng√£/n·∫∑ng
    //
    // Note: In VNI mode, foreign words like Google, expect, deadline, burnout are typed
    // literally and most stay unchanged because VNI uses numbers for modifiers.
    let input = "To6i d9a4 thu73 ra61t nhie62u bo65 go4 tie61ng Vie65t tre6n macOS nhu7ng toa2n ga85p bug kho1 chi5u. Go4 tre6n Chrome thi2 bi5 di1nh chu74 \"aa\" tha2nh \"a√¢\", go4 www thi2 tha2nh \"∆∞∆∞∆∞\", va2o Claude Code thi2 la85p ky1 tu75 lung tung, co2n Google Docs thi2 cu71 ma61t da61u giu74a chu72ng. Frustrated vo6 cu2ng ne6n to6i quye61t d9i5nh tu75 build Go4 Nhanh - bo65 go4 handle mu7o75t ma2 ngay ca3 nhu74ng tu72 kho1 nhu7: giu7o72ng, khuy3u tay, khuye61n khi1ch, chuye63n d9o63i, nguye65n vo5ng, huy3 hoa5i, quy2nh hoa, khoe3 khoa81n, loa2 xoa2, nghie6ng nga3. Gio72 to6i co1 the63 thoa3i ma1i prompt Claude Code ba82ng tie61ng Vie65t, soa5n proposal hay update report ma2 kho6ng stress ve62 typo nu7a4. D9u1ng nhu7 expect, deadline ga61p ma2 go4 sai hoa2i thi2 burnout la2 ca1i cha81c. Legit recommend cho anh em dev, xa2i la2 ghie62n luo6n a1! Ne61u co1 feedback gi2 thi2 inbox to6i qua nhatkha1407@gmail.com nha.";
    let expected = "T√¥i ƒë√£ th·ª≠ r·∫•t nhi·ªÅu b·ªô g√µ ti·∫øng Vi·ªát tr√™n macOS nh∆∞ng to√†n g·∫∑p bug kh√≥ ch·ªãu. G√µ tr√™n Chrome th√¨ b·ªã d√≠nh ch·ªØ \"aa\" th√†nh \"a√¢\", g√µ www th√¨ th√†nh \"∆∞∆∞∆∞\", v√†o Claude Code th√¨ l·∫∑p k√Ω t·ª± lung tung, c√≤n Google Docs th√¨ c·ª© m·∫•t d·∫•u gi·ªØa ch·ª´ng. Frustrated v√¥ c√πng n√™n t√¥i quy·∫øt ƒë·ªãnh t·ª± build G√µ Nhanh - b·ªô g√µ handle m∆∞·ª£t m√† ngay c·∫£ nh·ªØng t·ª´ kh√≥ nh∆∞: gi·ª´∆°ng, khu·ª∑u tay, khuy·∫øn kh√≠ch, chuy·ªÉn ƒë·ªïi, nguy·ªán v·ªçng, hu·ª∑ ho·∫°i, qu·ª≥nh hoa, kho·∫ª kho·∫Øn, lo√† xo√†, nghi√™ng ng·∫£. Gi·ªù t√¥i c√≥ th·ªÉ tho·∫£i m√°i prompt Claude Code b·∫±ng ti·∫øng Vi·ªát, so·∫°n proposal hay update report m√† kh√¥ng stress v·ªÅ typo n·ªØa. ƒê√∫ng nh∆∞ expect, deadline g·∫•p m√† g√µ sai ho√†i th√¨ burnout l√† c√°i ch·∫Øc. Legit recommend cho anh em dev, x√†i l√† ghi·ªÅn lu√¥n √°! N·∫øu c√≥ feedback g√¨ th√¨ inbox t√¥i qua nhatkha1407@gmail.com nha.";

    vni(&[(input, expected)]);
}
</file>

<file path="platforms/macos/AboutView.swift">
import SwiftUI

struct AboutView: View {
    @Environment(\.colorScheme) private var colorScheme

    var body: some View {
        VStack(spacing: 0) {
            header
            Divider()
            infoSection
            Divider()
            linksSection
            Divider()
            footer
        }
        .frame(width: 360)
        .background(colorScheme == .dark ? Color.black.opacity(0.2) : Color.white)
    }

    // MARK: - Header
    private var header: some View {
        VStack(spacing: 8) {
            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 80, height: 80)
                .shadow(color: .black.opacity(0.1), radius: 4, y: 2)

            Text(AppMetadata.name)
                .font(.system(size: 24, weight: .bold, design: .rounded))

            Text(AppMetadata.tagline)
                .font(.subheadline)
                .foregroundStyle(.secondary)

            // Version badge
            HStack(spacing: 12) {
                versionBadge(label: "Version", value: AppMetadata.version)
                versionBadge(label: "Build", value: AppMetadata.buildNumber)
            }
            .padding(.top, 4)
        }
        .padding(.vertical, 24)
        .padding(.horizontal, 32)
    }

    private func versionBadge(label: String, value: String) -> some View {
        HStack(spacing: 4) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(.tertiary)
            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(colorScheme == .dark ? Color.white.opacity(0.08) : Color.black.opacity(0.04))
        )
    }

    // MARK: - Info Section
    private var infoSection: some View {
        VStack(spacing: 12) {
            infoRow(icon: "person.fill", title: "Developer", value: AppMetadata.author)
            infoRow(icon: "envelope.fill", title: "Contact", value: AppMetadata.authorEmail, isLink: true, url: "mailto:\(AppMetadata.authorEmail)")
            infoRow(icon: "hammer.fill", title: "Built with", value: AppMetadata.techStack)
            infoRow(icon: "doc.text.fill", title: "License", value: AppMetadata.license)
        }
        .padding(.vertical, 16)
        .padding(.horizontal, 24)
    }

    private func infoRow(icon: String, title: String, value: String, isLink: Bool = false, url: String? = nil) -> some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 12))
                .foregroundStyle(.secondary)
                .frame(width: 20)

            Text(title)
                .font(.callout)
                .foregroundStyle(.secondary)
                .frame(width: 80, alignment: .leading)

            if isLink, let urlString = url, let linkURL = URL(string: urlString) {
                Link(value, destination: linkURL)
                    .font(.callout)
                    .fontWeight(.medium)
            } else {
                Text(value)
                    .font(.callout)
                    .fontWeight(.medium)
                    .foregroundStyle(.primary)
            }

            Spacer()
        }
    }

    // MARK: - Links Section
    private var linksSection: some View {
        HStack(spacing: 16) {
            linkButton(icon: "globe", title: "Website", url: AppMetadata.website)
            linkButton(icon: "chevron.left.forwardslash.chevron.right", title: "GitHub", url: AppMetadata.repository)
            linkButton(icon: "exclamationmark.bubble.fill", title: "Issues", url: AppMetadata.issuesURL)
            linkButton(icon: "link", title: "LinkedIn", url: AppMetadata.authorLinkedin)
        }
        .padding(.vertical, 16)
        .padding(.horizontal, 24)
    }

    private func linkButton(icon: String, title: String, url: String) -> some View {
        Link(destination: URL(string: url)!) {
            VStack(spacing: 6) {
                Image(systemName: icon)
                    .font(.system(size: 16))
                Text(title)
                    .font(.caption2)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(colorScheme == .dark ? Color.white.opacity(0.06) : Color.black.opacity(0.03))
            )
        }
        .buttonStyle(.plain)
        .foregroundStyle(.secondary)
        .onHover { hovering in
            if hovering {
                NSCursor.pointingHand.push()
            } else {
                NSCursor.pop()
            }
        }
    }

    // MARK: - Footer
    private var footer: some View {
        Text(AppMetadata.copyright)
            .font(.caption2)
            .foregroundStyle(.tertiary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(colorScheme == .dark ? Color.white.opacity(0.02) : Color.black.opacity(0.02))
    }
}

#Preview {
    AboutView()
}
</file>

<file path="platforms/macos/UpdateView.swift">
import SwiftUI

struct UpdateView: View {
    @Environment(\.colorScheme) private var colorScheme
    @ObservedObject var updateManager = UpdateManager.shared

    var body: some View {
        VStack(spacing: 0) {
            content
            Divider()
            footer
        }
        .frame(width: 360)
        .background(colorScheme == .dark ? Color.black.opacity(0.2) : Color.white)
    }

    @ViewBuilder
    private var content: some View {
        switch updateManager.state {
        case .idle:
            idleView
        case .checking:
            checkingView
        case .upToDate:
            upToDateView
        case .available(let info):
            availableView(info)
        case .downloading(let progress):
            downloadingView(progress)
        case .readyToInstall:
            readyView
        case .installing:
            installingView
        case .error(let message):
            errorView(message)
        }
    }

    // MARK: - States

    private var idleView: some View {
        VStack(spacing: 16) {
            Spacer()

            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 64, height: 64)
                .shadow(color: .black.opacity(0.1), radius: 4, y: 2)

            Text(AppMetadata.name)
                .font(.system(size: 20, weight: .bold, design: .rounded))

            versionBadge(label: "Phi√™n b·∫£n", value: AppMetadata.version)

            if let lastCheck = updateManager.lastCheckDate {
                Text("Ki·ªÉm tra l·∫ßn cu·ªëi: \(lastCheck.formatted(.relative(presentation: .named)))")
                    .font(.caption)
                    .foregroundStyle(.tertiary)
            }

            Spacer()

            Button("Ki·ªÉm tra c·∫≠p nh·∫≠t") {
                updateManager.checkForUpdatesManually()
            }
            .buttonStyle(.borderedProminent)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var checkingView: some View {
        VStack(spacing: 16) {
            Spacer()

            ProgressView()
                .scaleEffect(1.5)

            Text("ƒêang ki·ªÉm tra...")
                .font(.system(size: 18, weight: .medium, design: .rounded))

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var upToDateView: some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "checkmark", color: .green)

            Text("ƒê√£ c·∫≠p nh·∫≠t m·ªõi nh·∫•t")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            versionBadge(label: "Phi√™n b·∫£n", value: AppMetadata.version)

            Spacer()

            Button("Ki·ªÉm tra l·∫°i") {
                updateManager.checkForUpdatesManually()
            }

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private func availableView(_ info: UpdateInfo) -> some View {
        VStack(spacing: 0) {
            // Header
            VStack(spacing: 12) {
                ZStack {
                    Circle()
                        .fill(Color.accentColor.opacity(0.15))
                        .frame(width: 56, height: 56)

                    Image(systemName: "arrow.down.circle.fill")
                        .font(.system(size: 32))
                        .foregroundStyle(Color.accentColor)
                }

                Text("C√≥ phi√™n b·∫£n m·ªõi")
                    .font(.system(size: 17, weight: .semibold))

                // Version comparison
                HStack(spacing: 8) {
                    Text(AppMetadata.version)
                        .foregroundStyle(.secondary)

                    Image(systemName: "arrow.right")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundStyle(.tertiary)

                    Text(info.version)
                        .foregroundStyle(.green)
                        .fontWeight(.medium)
                }
                .font(.system(size: 13, design: .monospaced))
            }
            .padding(.top, 28)
            .padding(.bottom, 20)

            // Release notes
            let notes = info.releaseNotes.trimmingCharacters(in: .whitespacesAndNewlines)
            if !notes.isEmpty {
                ScrollView {
                    Text(notes)
                        .font(.system(size: 12))
                        .foregroundStyle(.secondary)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .lineSpacing(3)
                }
                .frame(maxHeight: 100)
                .padding(12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(colorScheme == .dark ? Color.white.opacity(0.05) : Color.black.opacity(0.03))
                )
                .padding(.horizontal, 24)
                .padding(.bottom, 20)
            }

            // Actions
            VStack(spacing: 12) {
                Button {
                    updateManager.downloadUpdate(info)
                } label: {
                    Text("C·∫≠p nh·∫≠t ngay")
                        .font(.system(size: 13, weight: .medium))
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 8)
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)

                HStack(spacing: 24) {
                    Button("ƒê·ªÉ sau") {
                        updateManager.state = .idle
                    }

                    Button("B·ªè qua phi√™n b·∫£n n√†y") {
                        updateManager.skipVersion(info.version)
                    }
                    .foregroundStyle(.tertiary)
                }
                .font(.system(size: 12))
                .buttonStyle(.plain)
                .foregroundStyle(.secondary)
            }
            .padding(.horizontal, 24)
            .padding(.bottom, 24)
        }
    }

    private func downloadingView(_ progress: Double) -> some View {
        VStack(spacing: 16) {
            Spacer()

            ZStack {
                Circle()
                    .stroke(colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.08), lineWidth: 4)
                    .frame(width: 64, height: 64)

                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(Color.accentColor, style: StrokeStyle(lineWidth: 4, lineCap: .round))
                    .frame(width: 64, height: 64)
                    .rotationEffect(.degrees(-90))

                Text("\(Int(progress * 100))%")
                    .font(.system(size: 14, weight: .bold, design: .rounded))
            }

            Text("ƒêang t·∫£i v·ªÅ...")
                .font(.system(size: 18, weight: .medium, design: .rounded))

            Spacer()

            Button("H·ªßy") {
                updateManager.cancelDownload()
            }
            .foregroundStyle(.secondary)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var readyView: some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "checkmark", color: .green)

            Text("S·∫µn s√†ng c√†i ƒë·∫∑t")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            Spacer()

            Button("C√†i ƒë·∫∑t ngay") {
                updateManager.installUpdate()
            }
            .buttonStyle(.borderedProminent)

            Button("ƒê·ªÉ sau") {
                updateManager.state = .idle
            }
            .font(.callout)
            .foregroundStyle(.secondary)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var installingView: some View {
        VStack(spacing: 16) {
            Spacer()

            ProgressView()
                .scaleEffect(1.5)

            Text("ƒêang c√†i ƒë·∫∑t...")
                .font(.system(size: 18, weight: .medium, design: .rounded))

            Text("·ª®ng d·ª•ng s·∫Ω t·ª± kh·ªüi ƒë·ªông l·∫°i")
                .font(.callout)
                .foregroundStyle(.secondary)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private func errorView(_ message: String) -> some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "exclamationmark", color: .orange)

            Text("L·ªói k·∫øt n·ªëi")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            Text(message)
                .font(.callout)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)

            Spacer()

            Button("Th·ª≠ l·∫°i") {
                updateManager.checkForUpdatesManually()
            }
            .buttonStyle(.borderedProminent)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    // MARK: - Components

    private func iconCircle(icon: String, color: Color) -> some View {
        ZStack {
            Circle()
                .fill(color.opacity(colorScheme == .dark ? 0.2 : 0.1))
                .frame(width: 64, height: 64)

            Image(systemName: icon)
                .font(.system(size: 28, weight: .medium))
                .foregroundStyle(color)
        }
    }

    private func versionBadge(label: String, value: String, highlight: Bool = false) -> some View {
        HStack(spacing: 4) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(.tertiary)
            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundStyle(highlight ? .green : .secondary)
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(colorScheme == .dark ? Color.white.opacity(0.08) : Color.black.opacity(0.04))
        )
    }

    // MARK: - Footer

    private var footer: some View {
        Link(destination: URL(string: AppMetadata.repository + "/releases")!) {
            HStack(spacing: 4) {
                Text("Xem tr√™n GitHub")
                Image(systemName: "arrow.up.right")
            }
            .font(.caption)
            .foregroundStyle(.secondary)
        }
        .buttonStyle(.plain)
        .frame(maxWidth: .infinity)
        .padding(.vertical, 12)
        .background(colorScheme == .dark ? Color.white.opacity(0.02) : Color.black.opacity(0.02))
        .onHover { hovering in
            if hovering {
                NSCursor.pointingHand.push()
            } else {
                NSCursor.pop()
            }
        }
    }
}

#Preview {
    UpdateView()
}
</file>

<file path="platforms/windows/GoNhanh/App.xaml.cs">
using System.Windows;
using GoNhanh.Core;
using GoNhanh.Services;
using GoNhanh.Views;

namespace GoNhanh;

/// <summary>
/// GoNhanh - Vietnamese Input Method for Windows
/// Main application entry point
/// Matches macOS App.swift flow
/// </summary>
public partial class App : System.Windows.Application
{
    private TrayIcon? _trayIcon;
    private KeyboardHook? _keyboardHook;
    private readonly SettingsService _settings = new();
    private System.Threading.Mutex? _mutex;

    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        // Prevent multiple instances
        if (!EnsureSingleInstance())
        {
            Shutdown();
            return;
        }

        // Initialize Rust core engine
        RustBridge.Initialize();

        // Load settings
        _settings.Load();
        ApplySettings();

        // Initialize keyboard hook
        _keyboardHook = new KeyboardHook();
        _keyboardHook.KeyPressed += OnKeyPressed;
        _keyboardHook.Start();

        // Initialize system tray
        _trayIcon = new TrayIcon();
        _trayIcon.OnExitRequested += ExitApplication;
        _trayIcon.OnMethodChanged += ChangeInputMethod;
        _trayIcon.OnEnabledChanged += ToggleEnabled;
        _trayIcon.Initialize(_settings.CurrentMethod, _settings.IsEnabled);

        // Show onboarding if first run (like macOS)
        if (_settings.IsFirstRun)
        {
            ShowOnboarding();
        }
    }

    private bool EnsureSingleInstance()
    {
        _mutex = new System.Threading.Mutex(true, "GoNhanh_SingleInstance", out bool createdNew);
        if (!createdNew)
        {
            System.Windows.MessageBox.Show(
                $"{AppMetadata.Name} ƒëang ch·∫°y.\nKi·ªÉm tra khay h·ªá th·ªëng (system tray).",
                AppMetadata.Name,
                MessageBoxButton.OK,
                MessageBoxImage.Information);
            return false;
        }
        return true;
    }

    private void ApplySettings()
    {
        RustBridge.SetMethod(_settings.CurrentMethod);
        RustBridge.SetEnabled(_settings.IsEnabled);
        RustBridge.SetModernTone(_settings.UseModernTone);
    }

    private void OnKeyPressed(object? sender, KeyPressedEventArgs e)
    {
        if (!_settings.IsEnabled) return;

        var result = RustBridge.ProcessKey(e.VirtualKeyCode, e.Shift, e.CapsLock);

        if (result.Action == ImeAction.Send && result.Count > 0)
        {
            e.Handled = true;
            TextSender.SendText(result.GetText(), result.Backspace);
        }
        else if (result.Action == ImeAction.Restore)
        {
            e.Handled = true;
            TextSender.SendText(result.GetText(), result.Backspace);
        }
    }

    private void ShowOnboarding()
    {
        var onboarding = new OnboardingWindow(_settings);
        onboarding.ShowDialog();

        // Save settings after onboarding
        _settings.IsFirstRun = false;
        _settings.Save();

        ApplySettings();
        _trayIcon?.UpdateState(_settings.CurrentMethod, _settings.IsEnabled);
    }

    private void ChangeInputMethod(InputMethod method)
    {
        _settings.CurrentMethod = method;
        _settings.Save();
        RustBridge.SetMethod(method);
    }

    private void ToggleEnabled(bool enabled)
    {
        _settings.IsEnabled = enabled;
        _settings.Save();
        RustBridge.SetEnabled(enabled);
    }

    private void ExitApplication()
    {
        _keyboardHook?.Stop();
        _keyboardHook?.Dispose();
        _trayIcon?.Dispose();
        RustBridge.Clear();
        _mutex?.Dispose();
        Shutdown();
    }

    protected override void OnExit(ExitEventArgs e)
    {
        _keyboardHook?.Dispose();
        _trayIcon?.Dispose();
        _mutex?.Dispose();
        base.OnExit(e);
    }
}
</file>

<file path="scripts/create-dmg-background.sh">
#!/bin/bash
# Create simple DMG background image for GoNhanh installer
# Clean, minimal design with dashed border for drop zone

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
OUTPUT_DIR="$SCRIPT_DIR/../platforms/macos/dmg-resources"
mkdir -p "$OUTPUT_DIR"

# DMG window dimensions
WIDTH=540
HEIGHT=360

# Icon positions (center of each icon) - vertically centered
APP_X=135
APP_Y=160
APPS_X=405
APPS_Y=160

# Dashed rectangle around Applications folder position
RECT_SIZE=145
RECT_X=$((APPS_X - RECT_SIZE/2))
RECT_Y=$((APPS_Y - RECT_SIZE/2 - 5))
RECT_X2=$((RECT_X + RECT_SIZE))
RECT_Y2=$((RECT_Y + RECT_SIZE + 20))
CORNER_RADIUS=12

# Check if ImageMagick is available
if command -v magick &> /dev/null; then
    CONVERT="magick"
elif command -v convert &> /dev/null; then
    CONVERT="convert"
else
    echo "ImageMagick is required. Install with: brew install imagemagick"
    exit 1
fi

echo "Creating DMG background image..."

# Create transparent background
$CONVERT -size ${WIDTH}x${HEIGHT} xc:transparent "$OUTPUT_DIR/bg_base.png"

# Create dashed rounded rectangle border for drop zone
$CONVERT -size ${WIDTH}x${HEIGHT} xc:transparent \
    -stroke '#c7c7cc' -strokewidth 2 -fill none \
    -draw "stroke-dasharray 8 6 roundrectangle $RECT_X,$RECT_Y $RECT_X2,$RECT_Y2 $CORNER_RADIUS,$CORNER_RADIUS" \
    "$OUTPUT_DIR/border.png" 2>/dev/null || \
$CONVERT -size ${WIDTH}x${HEIGHT} xc:transparent \
    -stroke '#c7c7cc' -strokewidth 2 -fill none \
    -draw "roundrectangle $RECT_X,$RECT_Y $RECT_X2,$RECT_Y2 $CORNER_RADIUS,$CORNER_RADIUS" \
    "$OUTPUT_DIR/border.png"

# Composite
$CONVERT "$OUTPUT_DIR/bg_base.png" \
    "$OUTPUT_DIR/border.png" -composite \
    "$OUTPUT_DIR/background.png"

# Create @2x version for Retina displays
$CONVERT "$OUTPUT_DIR/background.png" -resize 200% "$OUTPUT_DIR/background@2x.png"

# Create TIFF version
$CONVERT "$OUTPUT_DIR/background.png" "$OUTPUT_DIR/background.tiff"

# Clean up
rm -f "$OUTPUT_DIR/bg_base.png" "$OUTPUT_DIR/border.png"

echo "‚úÖ DMG background created at: $OUTPUT_DIR/background.png"
echo "   Dimensions: ${WIDTH}x${HEIGHT}"
</file>

<file path="scripts/create-dmg.sh">
#!/bin/bash
# Create beautiful DMG installer for GoNhanh
# macOS standard style with drag-to-install visual guidance

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR/.."
MACOS_DIR="$PROJECT_ROOT/platforms/macos"
DMG_RESOURCES="$MACOS_DIR/dmg-resources"

# Configuration
APP_NAME="GoNhanh"
VOL_NAME="GoNhanh"
DMG_TEMP="$MACOS_DIR/build/${APP_NAME}_temp.dmg"
DMG_FINAL="$MACOS_DIR/build/${APP_NAME}.dmg"

# Window dimensions and positions (matching background.png)
WINDOW_WIDTH=540
WINDOW_HEIGHT=360
ICON_SIZE=100
APP_X=135
APP_Y=160
APPS_X=405
APPS_Y=160

# Check arguments
APP_PATH="${1:-$MACOS_DIR/build/Release/${APP_NAME}.app}"

if [ ! -d "$APP_PATH" ]; then
    echo "Error: App not found at $APP_PATH"
    echo "Usage: $0 [path/to/GoNhanh.app]"
    exit 1
fi

echo "üì¶ Creating DMG installer for GoNhanh..."
echo "   App: $APP_PATH"

# Clean up any existing DMG
rm -f "$DMG_TEMP" "$DMG_FINAL"

# Create staging directory
STAGING_DIR=$(mktemp -d)
trap "rm -rf $STAGING_DIR" EXIT

echo "   Staging directory: $STAGING_DIR"

# Copy app to staging
cp -R "$APP_PATH" "$STAGING_DIR/"

# Create Applications symlink
ln -s /Applications "$STAGING_DIR/Applications"

# Copy background if exists
if [ -f "$DMG_RESOURCES/background.tiff" ]; then
    mkdir -p "$STAGING_DIR/.background"
    cp "$DMG_RESOURCES/background.tiff" "$STAGING_DIR/.background/background.tiff"
    BACKGROUND_FILE="background.tiff"
elif [ -f "$DMG_RESOURCES/background.png" ]; then
    mkdir -p "$STAGING_DIR/.background"
    cp "$DMG_RESOURCES/background.png" "$STAGING_DIR/.background/background.png"
    BACKGROUND_FILE="background.png"
else
    BACKGROUND_FILE=""
    echo "   Warning: No background image found"
fi

# Calculate size needed (app size + 50MB buffer)
APP_SIZE=$(du -sm "$APP_PATH" | cut -f1)
DMG_SIZE=$((APP_SIZE + 50))
echo "   DMG size: ${DMG_SIZE}MB"

# Create temporary DMG
echo "   Creating temporary DMG..."
hdiutil create -srcfolder "$STAGING_DIR" \
    -volname "$VOL_NAME" \
    -fs HFS+ \
    -fsargs "-c c=64,a=16,e=16" \
    -format UDRW \
    -size ${DMG_SIZE}m \
    "$DMG_TEMP"

# Mount the DMG
echo "   Mounting DMG..."
MOUNT_DIR=$(hdiutil attach -readwrite -noverify -noautoopen "$DMG_TEMP" | grep "/Volumes/$VOL_NAME" | awk '{print $3}')

if [ -z "$MOUNT_DIR" ]; then
    # Try alternative parsing
    MOUNT_DIR="/Volumes/$VOL_NAME"
fi

echo "   Mounted at: $MOUNT_DIR"

# Wait for mount
sleep 2

# Apply AppleScript to customize the DMG window
echo "   Customizing DMG appearance..."

if [ -n "$BACKGROUND_FILE" ]; then
    BACKGROUND_CLAUSE="set background picture of viewOptions to file \".background:$BACKGROUND_FILE\""
else
    BACKGROUND_CLAUSE=""
fi

osascript <<EOF
tell application "Finder"
    tell disk "$VOL_NAME"
        open
        set current view of container window to icon view
        set toolbar visible of container window to false
        set statusbar visible of container window to false
        set the bounds of container window to {100, 100, $((100 + WINDOW_WIDTH)), $((100 + WINDOW_HEIGHT))}
        set viewOptions to the icon view options of container window
        set arrangement of viewOptions to not arranged
        set icon size of viewOptions to $ICON_SIZE
        $BACKGROUND_CLAUSE
        set position of item "${APP_NAME}.app" of container window to {$APP_X, $APP_Y}
        set position of item "Applications" of container window to {$APPS_X, $APPS_Y}
        close
        open
        update without registering applications
        delay 2
    end tell
end tell
EOF

# Sync and unmount
echo "   Finalizing..."
sync
sleep 3
hdiutil detach "$MOUNT_DIR" -quiet 2>/dev/null || hdiutil detach "$MOUNT_DIR" -force 2>/dev/null || true
sleep 2

# Convert to compressed DMG
echo "   Compressing DMG..."
hdiutil convert "$DMG_TEMP" \
    -format UDZO \
    -imagekey zlib-level=9 \
    -o "$DMG_FINAL"

# Clean up temp DMG
rm -f "$DMG_TEMP"

# Get final size
FINAL_SIZE=$(du -h "$DMG_FINAL" | cut -f1)

echo ""
echo "‚úÖ DMG created successfully!"
echo "   Output: $DMG_FINAL"
echo "   Size: $FINAL_SIZE"
echo ""
echo "To test the DMG:"
echo "   open $DMG_FINAL"
</file>

<file path="package.json">
{
  "name": "gonhanh",
  "version": "1.0.0",
  "description": "G√µ Nhanh - High-performance Vietnamese input method engine",
  "author": "Kha Phan <nhatkha1407@gmail.com>",
  "scripts": {
    "semantic-release": "semantic-release"
  },
  "devDependencies": {
    "semantic-release": "^23.0.0"
  },
  "release": {
    "branches": [
      "main"
    ],
    "plugins": [
      "@semantic-release/commit-analyzer",
      "@semantic-release/release-notes-generator",
      "@semantic-release/github"
    ]
  }
}
</file>

<file path="core/src/engine/syllable.rs">
//! Vietnamese Syllable Parser
//!
//! Parses buffer into syllable structure: (C‚ÇÅ)(G)V(C‚ÇÇ)
//! - C‚ÇÅ: Initial consonant (ph·ª• √¢m ƒë·∫ßu)
//! - G: Glide/Medial (√¢m ƒë·ªám)
//! - V: Vowel nucleus (nguy√™n √¢m ch√≠nh) - REQUIRED
//! - C‚ÇÇ: Final consonant (√¢m cu·ªëi)

use crate::data::constants;
use crate::data::keys;

/// Parsed syllable structure
#[derive(Debug, Clone, Default)]
pub struct Syllable {
    /// Initial consonant indices in buffer
    pub initial: Vec<usize>,
    /// Glide/medial index (o in "hoa", u in "qua")
    pub glide: Option<usize>,
    /// Vowel nucleus indices
    pub vowel: Vec<usize>,
    /// Final consonant indices
    pub final_c: Vec<usize>,
}

impl Syllable {
    pub fn is_empty(&self) -> bool {
        self.vowel.is_empty()
    }

    pub fn has_initial(&self) -> bool {
        !self.initial.is_empty()
    }

    pub fn has_final(&self) -> bool {
        !self.final_c.is_empty()
    }

    pub fn vowel_count(&self) -> usize {
        self.vowel.len()
    }
}

/// Valid final consonants (√¢m cu·ªëi)
const FINALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
];

/// Parse buffer keys into syllable structure
///
/// Uses longest-match-first algorithm:
/// 1. Match initial consonant (3 ‚Üí 2 ‚Üí 1 chars)
/// 2. Check for glide (o/u before main vowel)
/// 3. Match vowel nucleus
/// 4. Remainder is final consonant
///
/// Note: This parser is lenient - it will parse invalid initials
/// and let validation reject them later.
pub fn parse(buffer_keys: &[u16]) -> Syllable {
    let mut syllable = Syllable::default();
    let len = buffer_keys.len();

    if len == 0 {
        return syllable;
    }

    // Step 1: Find first vowel position, with special handling for "gi", "qu"
    let first_vowel_pos = buffer_keys.iter().position(|&k| keys::is_vowel(k));

    let vowel_start = match first_vowel_pos {
        Some(pos) => {
            // Special case: "gi" + vowel ‚Üí gi is initial, not g alone
            // Check if we have g + i + another_vowel pattern
            if pos > 0 && pos + 1 < len {
                let prev = buffer_keys[pos - 1];
                let curr = buffer_keys[pos];
                let next = buffer_keys[pos + 1];

                // gi + vowel (gi√†u, gi·∫øng, etc.)
                if prev == keys::G && curr == keys::I && keys::is_vowel(next) {
                    // Include 'i' in initial, not as vowel
                    for i in 0..=pos {
                        syllable.initial.push(i);
                    }
                    pos + 1 // vowels start after 'i'
                }
                // qu + vowel (qua, qu√™, etc.) - qu is initial
                else if prev == keys::Q && curr == keys::U && keys::is_vowel(next) {
                    // Include 'u' in initial, not as vowel
                    for i in 0..=pos {
                        syllable.initial.push(i);
                    }
                    pos + 1
                } else {
                    // Normal: everything before first vowel is initial
                    for i in 0..pos {
                        syllable.initial.push(i);
                    }
                    pos
                }
            } else {
                // Normal: everything before first vowel is initial
                for i in 0..pos {
                    syllable.initial.push(i);
                }
                pos
            }
        }
        None => {
            // No vowel found - invalid syllable
            return syllable;
        }
    };

    // Step 2: Find vowels and glide
    let mut vowel_end = vowel_start;

    // Find all consecutive vowels
    while vowel_end < len && keys::is_vowel(buffer_keys[vowel_end]) {
        vowel_end += 1;
    }

    if vowel_end == vowel_start {
        // No vowel found - invalid syllable (shouldn't happen here)
        return syllable;
    }

    // Check for glide pattern
    let vowel_count = vowel_end - vowel_start;
    if vowel_count >= 2 {
        let first_vowel = buffer_keys[vowel_start];
        let second_vowel = buffer_keys[vowel_start + 1];

        // Check if it's a glide pattern
        let is_glide = is_glide_pattern(first_vowel, second_vowel, &syllable);

        if is_glide {
            syllable.glide = Some(vowel_start);
            for i in (vowel_start + 1)..vowel_end {
                syllable.vowel.push(i);
            }
        } else {
            for i in vowel_start..vowel_end {
                syllable.vowel.push(i);
            }
        }
    } else {
        // Single vowel
        syllable.vowel.push(vowel_start);
    }

    // Step 3: Match final consonant
    if vowel_end < len {
        match_final(buffer_keys, vowel_end, &mut syllable);
    }

    syllable
}

/// Match final consonant
fn match_final(keys: &[u16], start: usize, syllable: &mut Syllable) {
    let len = keys.len();
    let remaining = len - start;

    // Try 2-char finals
    if remaining >= 2 {
        for pattern in FINALS_2 {
            if keys[start] == pattern[0] && keys[start + 1] == pattern[1] {
                syllable.final_c = vec![start, start + 1];
                return;
            }
        }
    }

    // Try 1-char finals
    if remaining >= 1 && constants::VALID_FINALS_1.contains(&keys[start]) {
        syllable.final_c = vec![start];
    }
}

/// Check if first vowel is a glide (√¢m ƒë·ªám)
///
/// Glide patterns:
/// - o + (a, ƒÉ, e) ‚Üí oa, oƒÉ, oe
/// - u + (a, √¢, √™, y) after "qu" ‚Üí qua, qu√¢, qu√™, quy
fn is_glide_pattern(first: u16, second: u16, syllable: &Syllable) -> bool {
    // Check if initial is "qu" - then u is part of initial, not glide
    let is_qu = syllable.initial.len() == 2;
    if is_qu {
        // qu already includes u, no separate glide
        return false;
    }

    match first {
        keys::O => {
            // o + (a, e) ‚Üí glide
            matches!(second, keys::A | keys::E)
        }
        keys::U => {
            // u + (a, √¢, √™, y) when NOT after qu
            // Actually u is glide in: uy, ua (non-qu context handled differently)
            matches!(second, keys::Y | keys::E)
        }
        _ => false,
    }
}

/// Check if buffer represents a potentially valid Vietnamese syllable structure
///
/// This is a quick structural check, not full phonological validation
pub fn is_valid_structure(buffer_keys: &[u16]) -> bool {
    if buffer_keys.is_empty() {
        return false;
    }

    let syllable = parse(buffer_keys);

    // Must have at least one vowel
    if syllable.is_empty() {
        return false;
    }

    // Basic structure check passed
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::keys_from_str;

    #[test]
    fn parse_simple_syllable() {
        let s = parse(&keys_from_str("ba"));
        assert_eq!(s.initial.len(), 1);
        assert_eq!(s.vowel.len(), 1);
        assert!(s.final_c.is_empty());
    }

    #[test]
    fn parse_ngh_initial() {
        let s = parse(&keys_from_str("nghieng"));
        assert_eq!(s.initial.len(), 3);
        assert_eq!(s.vowel.len(), 2);
        assert_eq!(s.final_c.len(), 2);
    }

    #[test]
    fn parse_qu_initial() {
        let s = parse(&keys_from_str("qua"));
        assert_eq!(s.initial.len(), 2);
        assert_eq!(s.vowel.len(), 1);
        assert!(s.glide.is_none());
    }

    #[test]
    fn parse_hoa_with_glide() {
        let s = parse(&keys_from_str("hoa"));
        assert_eq!(s.initial.len(), 1);
        assert!(s.glide.is_some());
        assert_eq!(s.vowel.len(), 1);
    }

    #[test]
    fn parse_gi_initial() {
        let s = parse(&keys_from_str("giau"));
        assert_eq!(s.initial.len(), 2);
        assert_eq!(s.vowel.len(), 2);
    }

    #[test]
    fn parse_duoc() {
        let s = parse(&keys_from_str("duoc"));
        assert_eq!(s.initial.len(), 1);
        assert_eq!(s.vowel.len(), 2);
        assert_eq!(s.final_c.len(), 1);
    }

    #[test]
    fn parse_vowel_only() {
        let s = parse(&keys_from_str("a"));
        assert!(s.initial.is_empty());
        assert_eq!(s.vowel.len(), 1);
    }

    #[test]
    fn invalid_no_vowel() {
        let s = parse(&keys_from_str("bcd"));
        assert!(s.is_empty());
    }

    #[test]
    fn test_is_valid_structure() {
        assert!(is_valid_structure(&keys_from_str("ba")));
        assert!(is_valid_structure(&keys_from_str("nghieng")));
        assert!(is_valid_structure(&keys_from_str("a")));
        assert!(!is_valid_structure(&keys_from_str("bcd")));
        assert!(!is_valid_structure(&keys_from_str("")));
    }
}
</file>

<file path="core/src/engine/validation.rs">
//! Vietnamese Syllable Validation
//!
//! Rule-based validation for Vietnamese syllables.
//! Each rule is a simple function that returns Some(error) if invalid, None if OK.

use super::syllable::{parse, Syllable};
use crate::data::constants;
use crate::data::keys;

/// Validation result
#[derive(Debug, Clone, PartialEq)]
pub enum ValidationResult {
    Valid,
    InvalidInitial,
    InvalidFinal,
    InvalidSpelling,
    NoVowel,
}

impl ValidationResult {
    pub fn is_valid(&self) -> bool {
        matches!(self, ValidationResult::Valid)
    }
}

// =============================================================================
// VALIDATION RULES - Each rule is a simple check function
// =============================================================================

/// Rule type: takes buffer keys and parsed syllable, returns error or None
type Rule = fn(&[u16], &Syllable) -> Option<ValidationResult>;

/// All validation rules in order of priority
const RULES: &[Rule] = &[
    rule_has_vowel,
    rule_valid_initial,
    rule_all_chars_parsed,
    rule_spelling,
    rule_valid_final,
];

// =============================================================================
// RULE IMPLEMENTATIONS
// =============================================================================

/// Rule 1: Must have at least one vowel
fn rule_has_vowel(_keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.is_empty() {
        return Some(ValidationResult::NoVowel);
    }
    None
}

/// Rule 2: Initial consonant must be valid Vietnamese
fn rule_valid_initial(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.initial.is_empty() {
        return None; // No initial = starts with vowel, OK
    }

    let initial: Vec<u16> = syllable.initial.iter().map(|&i| keys[i]).collect();

    let is_valid = match initial.len() {
        1 => constants::VALID_INITIALS_1.contains(&initial[0]),
        2 => constants::VALID_INITIALS_2
            .iter()
            .any(|p| p[0] == initial[0] && p[1] == initial[1]),
        3 => initial[0] == keys::N && initial[1] == keys::G && initial[2] == keys::H,
        _ => false,
    };

    if !is_valid {
        return Some(ValidationResult::InvalidInitial);
    }
    None
}

/// Rule 3: All characters must be parsed into syllable structure
fn rule_all_chars_parsed(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    let parsed = syllable.initial.len()
        + syllable.glide.map_or(0, |_| 1)
        + syllable.vowel.len()
        + syllable.final_c.len();

    if parsed != keys.len() {
        return Some(ValidationResult::InvalidFinal);
    }
    None
}

/// Rule 4: Vietnamese spelling rules (c/k, g/gh, ng/ngh)
fn rule_spelling(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.initial.is_empty() || syllable.vowel.is_empty() {
        return None;
    }

    let initial: Vec<u16> = syllable.initial.iter().map(|&i| keys[i]).collect();
    let first_vowel = keys[syllable.glide.unwrap_or(syllable.vowel[0])];

    // Check all spelling rules
    for &(consonant, vowels, _msg) in constants::SPELLING_RULES {
        if initial == consonant && vowels.contains(&first_vowel) {
            return Some(ValidationResult::InvalidSpelling);
        }
    }

    None
}

/// Rule 5: Final consonant must be valid
fn rule_valid_final(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.final_c.is_empty() {
        return None;
    }

    let final_c: Vec<u16> = syllable.final_c.iter().map(|&i| keys[i]).collect();

    let is_valid = match final_c.len() {
        1 => constants::VALID_FINALS_1.contains(&final_c[0]),
        2 => constants::VALID_FINALS_2
            .iter()
            .any(|p| p[0] == final_c[0] && p[1] == final_c[1]),
        _ => false,
    };

    if !is_valid {
        return Some(ValidationResult::InvalidFinal);
    }
    None
}

// =============================================================================
// PUBLIC API
// =============================================================================

/// Validate buffer as Vietnamese syllable - runs all rules
pub fn validate(buffer_keys: &[u16]) -> ValidationResult {
    if buffer_keys.is_empty() {
        return ValidationResult::NoVowel;
    }

    let syllable = parse(buffer_keys);

    // Run all rules in order
    for rule in RULES {
        if let Some(error) = rule(buffer_keys, &syllable) {
            return error;
        }
    }

    ValidationResult::Valid
}

/// Quick check if buffer could be valid Vietnamese
pub fn is_valid(buffer_keys: &[u16]) -> bool {
    validate(buffer_keys).is_valid()
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::keys_from_str;

    /// Valid Vietnamese syllables
    const VALID: &[&str] = &[
        "ba", "ca", "an", "em", "gi", "gia", "giau", "ke", "ki", "ky", "nghe", "nghi", "nghieng",
        "truong", "nguoi", "duoc",
    ];

    /// Invalid: no vowel
    const INVALID_NO_VOWEL: &[&str] = &["bcd", "bcdfgh"];

    /// Invalid: bad initial
    const INVALID_INITIAL: &[&str] = &["clau", "john", "bla", "string", "chrome"];

    /// Invalid: spelling violations
    const INVALID_SPELLING: &[&str] = &["ci", "ce", "cy", "ka", "ko", "ku", "ngi", "nge", "ge"];

    /// Invalid: foreign words
    const INVALID_FOREIGN: &[&str] = &["exp", "expect", "test", "claudeco", "claus"];

    fn assert_all_valid(words: &[&str]) {
        for w in words {
            assert!(is_valid(&keys_from_str(w)), "'{}' should be valid", w);
        }
    }

    fn assert_all_invalid(words: &[&str]) {
        for w in words {
            assert!(!is_valid(&keys_from_str(w)), "'{}' should be invalid", w);
        }
    }

    #[test]
    fn test_valid() {
        assert_all_valid(VALID);
    }

    #[test]
    fn test_invalid_no_vowel() {
        assert_all_invalid(INVALID_NO_VOWEL);
    }

    #[test]
    fn test_invalid_initial() {
        assert_all_invalid(INVALID_INITIAL);
    }

    #[test]
    fn test_invalid_spelling() {
        assert_all_invalid(INVALID_SPELLING);
    }

    #[test]
    fn test_invalid_foreign() {
        assert_all_invalid(INVALID_FOREIGN);
    }
}
</file>

<file path="core/src/utils.rs">
//! Shared utilities for Vietnamese IME processing
//!
//! Contains common functions used across engine modules to avoid duplication.
//! Also includes test utilities under #[cfg(test)].

use crate::data::{
    chars::tone,
    keys,
    vowel::{Modifier, Vowel},
};
use crate::engine::buffer::Buffer;

/// Convert key code to character
pub fn key_to_char(key: u16, caps: bool) -> Option<char> {
    let ch = match key {
        keys::A => 'a',
        keys::B => 'b',
        keys::C => 'c',
        keys::D => 'd',
        keys::E => 'e',
        keys::F => 'f',
        keys::G => 'g',
        keys::H => 'h',
        keys::I => 'i',
        keys::J => 'j',
        keys::K => 'k',
        keys::L => 'l',
        keys::M => 'm',
        keys::N => 'n',
        keys::O => 'o',
        keys::P => 'p',
        keys::Q => 'q',
        keys::R => 'r',
        keys::S => 's',
        keys::T => 't',
        keys::U => 'u',
        keys::V => 'v',
        keys::W => 'w',
        keys::X => 'x',
        keys::Y => 'y',
        keys::Z => 'z',
        keys::N0 => return Some('0'),
        keys::N1 => return Some('1'),
        keys::N2 => return Some('2'),
        keys::N3 => return Some('3'),
        keys::N4 => return Some('4'),
        keys::N5 => return Some('5'),
        keys::N6 => return Some('6'),
        keys::N7 => return Some('7'),
        keys::N8 => return Some('8'),
        keys::N9 => return Some('9'),
        _ => return None,
    };
    Some(if caps { ch.to_ascii_uppercase() } else { ch })
}

/// Collect vowels from buffer with phonological info
pub fn collect_vowels(buf: &Buffer) -> Vec<Vowel> {
    buf.iter()
        .enumerate()
        .filter(|(_, c)| keys::is_vowel(c.key))
        .map(|(pos, c)| {
            let modifier = match c.tone {
                tone::CIRCUMFLEX => Modifier::Circumflex,
                tone::HORN => Modifier::Horn,
                _ => Modifier::None,
            };
            Vowel::new(c.key, modifier, pos)
        })
        .collect()
}

/// Check if there's a consonant after position
pub fn has_final_consonant(buf: &Buffer, after_pos: usize) -> bool {
    (after_pos + 1..buf.len()).any(|i| {
        buf.get(i)
            .map(|c| keys::is_consonant(c.key))
            .unwrap_or(false)
    })
}

/// Check if 'q' precedes 'u' in buffer
pub fn has_qu_initial(buf: &Buffer) -> bool {
    for (i, c) in buf.iter().enumerate() {
        if c.key == keys::U && i > 0 {
            if let Some(prev) = buf.get(i - 1) {
                return prev.key == keys::Q;
            }
        }
    }
    false
}

mod test_utils {
    //! Shared test utilities for inline tests
    //!
    //! Provides common helpers for testing Vietnamese IME engine.
    //! Used by `#[cfg(test)]` modules throughout the crate.

    use crate::data::keys;
    use crate::engine::{Action, Engine};

    // ============================================================
    // KEY MAPPING
    // ============================================================

    /// Convert character to key code
    pub fn char_to_key(c: char) -> u16 {
        match c.to_ascii_lowercase() {
            'a' => keys::A,
            'b' => keys::B,
            'c' => keys::C,
            'd' => keys::D,
            'e' => keys::E,
            'f' => keys::F,
            'g' => keys::G,
            'h' => keys::H,
            'i' => keys::I,
            'j' => keys::J,
            'k' => keys::K,
            'l' => keys::L,
            'm' => keys::M,
            'n' => keys::N,
            'o' => keys::O,
            'p' => keys::P,
            'q' => keys::Q,
            'r' => keys::R,
            's' => keys::S,
            't' => keys::T,
            'u' => keys::U,
            'v' => keys::V,
            'w' => keys::W,
            'x' => keys::X,
            'y' => keys::Y,
            'z' => keys::Z,
            '0' => keys::N0,
            '1' => keys::N1,
            '2' => keys::N2,
            '3' => keys::N3,
            '4' => keys::N4,
            '5' => keys::N5,
            '6' => keys::N6,
            '7' => keys::N7,
            '8' => keys::N8,
            '9' => keys::N9,
            '.' => keys::DOT,
            ',' => keys::COMMA,
            ';' => keys::SEMICOLON,
            ':' => keys::SEMICOLON, // Approximate
            '\'' => keys::QUOTE,
            '"' => keys::QUOTE,
            '-' => keys::MINUS,
            '=' => keys::EQUAL,
            '[' => keys::LBRACKET,
            ']' => keys::RBRACKET,
            '\\' => keys::BACKSLASH,
            '/' => keys::SLASH,
            '`' => keys::BACKQUOTE,
            '<' => keys::DELETE,
            ' ' => keys::SPACE,
            _ => 255, // Unknown/Other
        }
    }

    /// Convert string to key codes
    pub fn keys_from_str(s: &str) -> Vec<u16> {
        s.chars().map(char_to_key).filter(|&k| k != 255).collect()
    }

    // ============================================================
    // TYPING SIMULATION
    // ============================================================

    /// Simulate typing, returns screen output
    pub fn type_word(e: &mut Engine, input: &str) -> String {
        let mut screen = String::new();
        for c in input.chars() {
            let key = char_to_key(c);
            let is_caps = c.is_uppercase();

            if key == keys::DELETE {
                screen.pop();
                e.on_key(key, false, false);
                continue;
            }

            if key == keys::SPACE {
                screen.push(' ');
                e.on_key(key, false, false);
                continue;
            }

            let r = e.on_key(key, is_caps, false);
            if r.action == Action::Send as u8 {
                for _ in 0..r.backspace {
                    screen.pop();
                }
                for i in 0..r.count as usize {
                    if let Some(ch) = char::from_u32(r.chars[i]) {
                        screen.push(ch);
                    }
                }
            } else {
                // Pass through if not handled (mimic editor receiving char)
                screen.push(c);
            }
        }
        screen
    }

    // ============================================================
    // TEST RUNNERS
    // ============================================================

    /// Run Telex test cases
    pub fn telex(cases: &[(&str, &str)]) {
        for (input, expected) in cases {
            let mut e = Engine::new();
            let result = type_word(&mut e, input);
            assert_eq!(result, *expected, "[Telex] '{}' ‚Üí '{}'", input, result);
        }
    }

    /// Run VNI test cases
    pub fn vni(cases: &[(&str, &str)]) {
        for (input, expected) in cases {
            let mut e = Engine::new();
            e.set_method(1);
            let result = type_word(&mut e, input);
            assert_eq!(result, *expected, "[VNI] '{}' ‚Üí '{}'", input, result);
        }
    }
}

// Re-export test utilities for use in other test modules
pub use test_utils::*;
</file>

<file path="platforms/windows/GoNhanh/GoNhanh.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
    <UseWindowsForms>true</UseWindowsForms>
    <ApplicationIcon>Resources\Icons\app.ico</ApplicationIcon>

    <!-- App Info -->
    <AssemblyName>GoNhanh</AssemblyName>
    <RootNamespace>GoNhanh</RootNamespace>
    <Version>1.0.0</Version>
    <Company>Kha Phan</Company>
    <Product>G√µ Nhanh - Vietnamese Input Method</Product>
    <Description>G√µ Nhanh - Vietnamese input method engine for Windows</Description>
    <Copyright>Copyright (c) 2024 Kha Phan. GPL-3.0-or-later</Copyright>

    <!-- Build Settings -->
    <PlatformTarget>x64</PlatformTarget>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>false</SelfContained>
    <PublishSingleFile>true</PublishSingleFile>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
  </PropertyGroup>

  <!-- Native DLL -->
  <ItemGroup>
    <ContentWithTargetPath Include="Native\gonhanh_core.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <TargetPath>gonhanh_core.dll</TargetPath>
    </ContentWithTargetPath>
  </ItemGroup>

  <!-- Resources -->
  <ItemGroup>
    <Resource Include="Resources\Icons\*.ico" />
    <Resource Include="Resources\Icons\*.png" />
  </ItemGroup>

</Project>
</file>

<file path="scripts/build-windows.sh">
#!/bin/bash
set -e

# GoNhanh Windows Build Script
# Run on Windows with Git Bash or via CI/CD

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Navigate to project root
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check if running on Windows
is_windows() {
    [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "$WINDIR" ]]
}

# Parse arguments
CLEAN_INSTALL=false
for arg in "$@"; do
    case $arg in
        --clean)
            CLEAN_INSTALL=true
            shift
            ;;
        --help|-h)
            echo "Usage: build-windows.sh [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --clean    Remove existing build artifacts before building"
            echo "  --help     Show this help message"
            exit 0
            ;;
    esac
done

# Clean build artifacts
if [ "$CLEAN_INSTALL" = true ]; then
    echo "Cleaning build artifacts..."

    if is_windows; then
        # Kill running GoNhanh processes
        if tasklist 2>/dev/null | grep -qi "GoNhanh.exe"; then
            echo "  Stopping GoNhanh.exe..."
            taskkill //F //IM "GoNhanh.exe" 2>/dev/null || true
            sleep 1
        fi
    fi

    rm -rf "$PROJECT_ROOT/platforms/windows/GoNhanh/bin" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/platforms/windows/GoNhanh/obj" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/platforms/windows/publish" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/core/target" 2>/dev/null || true
    echo "  Done"
    echo ""
fi

# Get version from git tag
GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
VERSION=${GIT_TAG#v}

echo "Building GoNhanh for Windows"
echo "Version: $VERSION"
echo ""

# Check platform
if ! is_windows; then
    echo "Skipped: Not running on Windows"
    echo ""
    echo "This script requires Windows (Git Bash)."
    echo "Use GitHub Actions for CI/CD builds."
    exit 0
fi

# Build Rust core
echo "[1/3] Building Rust core..."
cd "$PROJECT_ROOT/core"
cargo build --release --target x86_64-pc-windows-msvc

mkdir -p "$PROJECT_ROOT/platforms/windows/GoNhanh/Native"
cp "target/x86_64-pc-windows-msvc/release/gonhanh_core.dll" \
   "$PROJECT_ROOT/platforms/windows/GoNhanh/Native/gonhanh_core.dll"
echo "  Output: gonhanh_core.dll"

# Build WPF app
echo "[2/3] Building WPF app..."
cd "$PROJECT_ROOT/platforms/windows/GoNhanh"

if ! command -v dotnet &> /dev/null; then
    echo "Error: .NET SDK not found"
    echo "Install from: https://dotnet.microsoft.com/download"
    exit 1
fi

dotnet publish -c Release -r win-x64 --self-contained false \
    -p:Version="$VERSION" \
    -p:FileVersion="$VERSION" \
    -p:AssemblyVersion="${VERSION%%.*}.0.0.0" \
    -o ../publish \
    -v quiet

echo "  Output: platforms/windows/publish/"

# Create ZIP package
echo "[3/3] Creating package..."
cd "$PROJECT_ROOT/platforms/windows"
ZIP_NAME="GoNhanh-${VERSION}-win-x64.zip"
rm -f "$ZIP_NAME" 2>/dev/null || true

if command -v zip &> /dev/null; then
    zip -rq "$ZIP_NAME" publish/*
elif command -v 7z &> /dev/null; then
    7z a -bso0 "$ZIP_NAME" publish/*
else
    echo "  Warning: zip/7z not found, skipping package"
    ZIP_NAME=""
fi

if [ -n "$ZIP_NAME" ]; then
    echo "  Output: $ZIP_NAME"
fi

echo ""
echo "Build complete!"
</file>

<file path="core/src/lib.rs">
//! G√µ Nhanh Vietnamese IME Core
//!
//! Simple Vietnamese input method engine supporting Telex and VNI.
//!
//! # FFI Usage
//!
//! ```c
//! // Initialize once at app start
//! ime_init();
//! ime_method(0);  // 0=Telex, 1=VNI
//!
//! // Process each keystroke
//! ImeResult* r = ime_key(keycode, is_shift, is_ctrl);
//! if (r && r->action == 1) {
//!     // Send r->backspace deletes, then r->chars
//! }
//! ime_free(r);
//!
//! // Clean up on word boundary
//! ime_clear();
//! ```

pub mod data;
pub mod engine;
pub mod input;
pub mod updater;
pub mod utils;

use engine::{Engine, Result};
use std::sync::Mutex;

// Global engine instance (thread-safe via Mutex)
static ENGINE: Mutex<Option<Engine>> = Mutex::new(None);

// ============================================================
// FFI Interface
// ============================================================

/// Initialize the IME engine.
///
/// Must be called exactly once before any other `ime_*` functions.
/// Thread-safe: uses internal mutex.
///
/// # Panics
/// Panics if mutex is poisoned (only if previous call panicked).
#[no_mangle]
pub extern "C" fn ime_init() {
    let mut guard = ENGINE.lock().unwrap();
    *guard = Some(Engine::new());
}

/// Process a key event and return the result.
///
/// # Arguments
/// * `key` - macOS virtual keycode (0-127 for standard keys)
/// * `caps` - true if CapsLock is pressed (for uppercase letters)
/// * `ctrl` - true if Cmd/Ctrl/Alt is pressed (bypasses IME)
///
/// # Returns
/// * Pointer to `Result` struct (caller must free with `ime_free`)
/// * `null` if engine not initialized
///
/// # Result struct
/// * `action`: 0=None (pass through), 1=Send (replace text), 2=Restore
/// * `backspace`: number of characters to delete
/// * `chars`: UTF-32 codepoints to insert
/// * `count`: number of valid chars
///
/// # Note
/// For VNI mode with Shift+number keys (to type @, #, $ etc.),
/// use `ime_key_ext` with the shift parameter.
#[no_mangle]
pub extern "C" fn ime_key(key: u16, caps: bool, ctrl: bool) -> *mut Result {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        let r = e.on_key(key, caps, ctrl);
        Box::into_raw(Box::new(r))
    } else {
        std::ptr::null_mut()
    }
}

/// Process a key event with extended parameters.
///
/// # Arguments
/// * `key` - macOS virtual keycode (0-127 for standard keys)
/// * `caps` - true if CapsLock is pressed (for uppercase letters)
/// * `ctrl` - true if Cmd/Ctrl/Alt is pressed (bypasses IME)
/// * `shift` - true if Shift key is pressed (for symbols like @, #, $)
///
/// # Returns
/// * Pointer to `Result` struct (caller must free with `ime_free`)
/// * `null` if engine not initialized
///
/// # VNI Shift+number behavior
/// In VNI mode, when `shift=true` and key is a number (0-9), the engine
/// will NOT apply VNI marks/tones. This allows typing symbols:
/// - Shift+2 ‚Üí @ (not huy·ªÅn mark)
/// - Shift+3 ‚Üí # (not h·ªèi mark)
/// - etc.
#[no_mangle]
pub extern "C" fn ime_key_ext(key: u16, caps: bool, ctrl: bool, shift: bool) -> *mut Result {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        let r = e.on_key_ext(key, caps, ctrl, shift);
        Box::into_raw(Box::new(r))
    } else {
        std::ptr::null_mut()
    }
}

/// Set the input method.
///
/// # Arguments
/// * `method` - 0 for Telex, 1 for VNI
///
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_method(method: u8) {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.set_method(method);
    }
}

/// Enable or disable the engine.
///
/// When disabled, `ime_key` returns action=0 (pass through).
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_enabled(enabled: bool) {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.set_enabled(enabled);
    }
}

/// Clear the input buffer.
///
/// Call on word boundaries (space, punctuation, mouse click, focus change).
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_clear() {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.clear();
    }
}

/// Free a result pointer returned by `ime_key`.
///
/// # Safety
/// * `r` must be a pointer returned by `ime_key`, or null
/// * Must be called exactly once per non-null `ime_key` return
/// * Do not use `r` after calling this function
#[no_mangle]
pub unsafe extern "C" fn ime_free(r: *mut Result) {
    if !r.is_null() {
        drop(Box::from_raw(r));
    }
}

// ============================================================
// Tests
// ============================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data::keys;

    #[test]
    fn test_ffi_flow() {
        ime_init();
        ime_method(0); // Telex

        // Type 'a' + 's' -> √°
        let r1 = ime_key(keys::A, false, false);
        assert!(!r1.is_null());
        unsafe { ime_free(r1) };

        let r2 = ime_key(keys::S, false, false);
        assert!(!r2.is_null());
        unsafe {
            assert_eq!((*r2).chars[0], '√°' as u32);
            ime_free(r2);
        }

        ime_clear();
    }
}
</file>

<file path="core/tests/common/mod.rs">
//! Common test utilities - Re-exports from core + integration test helpers
//!
//! Core functions are shared from `gonhanh_core::test_utils`.
//! This module adds additional helpers for integration tests.

#![allow(dead_code)]
#![allow(unused_imports)]

// Re-export core test utilities
pub use gonhanh_core::utils::{telex, type_word, vni};

use gonhanh_core::engine::{Action, Engine};

// ============================================================
// TEST RUNNERS - Extended helpers for integration tests
// ============================================================

/// Input method type
#[derive(Clone, Copy, Debug)]
pub enum Method {
    Telex,
    Vni,
}

/// Run test cases with method
pub fn run(method: Method, cases: &[(&str, &str)]) {
    match method {
        Method::Telex => telex(cases),
        Method::Vni => vni(cases),
    }
}

/// Run same cases for both methods (with different inputs)
pub fn both(telex_cases: &[(&str, &str)], vni_cases: &[(&str, &str)]) {
    telex(telex_cases);
    vni(vni_cases);
}

// ============================================================
// ENGINE STATE HELPERS
// ============================================================

pub fn engine_telex() -> Engine {
    Engine::new()
}

pub fn engine_vni() -> Engine {
    let mut e = Engine::new();
    e.set_method(1);
    e
}

// ============================================================
// ASSERTION HELPERS
// ============================================================

/// Assert engine action
pub fn assert_action(e: &mut Engine, key: u16, caps: bool, ctrl: bool, expected: Action) {
    let r = e.on_key(key, caps, ctrl);
    assert_eq!(
        r.action, expected as u8,
        "Expected {:?} for key {}",
        expected, key
    );
}

/// Assert pass-through (no transformation)
pub fn assert_passthrough(e: &mut Engine, key: u16) {
    assert_action(e, key, false, false, Action::None);
}

/// Assert transformation happens
pub fn assert_transforms(e: &mut Engine, key: u16) {
    assert_action(e, key, false, false, Action::Send);
}
</file>

<file path="platforms/macos/MenuBar.swift">
import Cocoa
import SwiftUI

// MARK: - SwiftUI Toggle Wrapper

class ToggleState: ObservableObject {
    @Published var isOn: Bool
    var onToggle: (() -> Void)?

    init(isOn: Bool) {
        self.isOn = isOn
    }
}

struct ToggleWrapperView: View {
    @ObservedObject var state: ToggleState

    var body: some View {
        Toggle("", isOn: $state.isOn)
            .toggleStyle(.switch)
            .tint(.green)
            .onChange(of: state.isOn) { _ in
                state.onToggle?()
            }
            .labelsHidden()
    }
}

// MARK: - Menu Bar Controller

class MenuBarController {
    private var statusItem: NSStatusItem!
    private var onboardingWindow: NSWindow?
    private var aboutWindow: NSWindow?
    private var updateWindow: NSWindow?
    private var toggleState: ToggleState?

    private var isEnabled = true
    private var currentMethod: InputMode = .telex

    init() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

        NotificationCenter.default.addObserver(
            self,
            selector: #selector(onboardingDidComplete),
            name: .onboardingCompleted,
            object: nil
        )

        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleToggleVietnamese),
            name: .toggleVietnamese,
            object: nil
        )

        setupMenu()
        updateStatusButton()

        if UserDefaults.standard.bool(forKey: SettingsKey.hasCompletedOnboarding) && AXIsProcessTrusted() {
            loadSettings()
            startEngine()
        } else {
            showOnboarding()
        }
    }

    @objc private func handleToggleVietnamese() {
        isEnabled.toggle()
        UserDefaults.standard.set(isEnabled, forKey: SettingsKey.enabled)
        RustBridge.setEnabled(isEnabled)
        updateStatusButton()
        updateMenu()
    }

    // MARK: - Setup

    private func loadSettings() {
        isEnabled = UserDefaults.standard.object(forKey: SettingsKey.enabled) as? Bool ?? true
        currentMethod = InputMode(rawValue: UserDefaults.standard.integer(forKey: SettingsKey.method)) ?? .telex
    }

    private func startEngine() {
        RustBridge.initialize()
        KeyboardHookManager.shared.start()
        RustBridge.setEnabled(isEnabled)
        RustBridge.setMethod(currentMethod.rawValue)

        // Check for updates in background after a short delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            UpdateManager.shared.checkForUpdatesSilently()
        }
    }

    @objc private func onboardingDidComplete() {
        loadSettings()
        updateStatusButton()
        updateMenu()
        startEngine()
        enableLaunchAtLogin()
    }

    // MARK: - Status Button

    private func updateStatusButton() {
        guard let button = statusItem.button else { return }
        button.title = ""
        button.image = createStatusIcon(text: isEnabled ? "V" : "E")
    }

    private func createStatusIcon(text: String) -> NSImage {
        let width: CGFloat = 22
        let height: CGFloat = 16
        let image = NSImage(size: NSSize(width: width, height: height))

        image.lockFocus()

        // Background tr·∫Øng bo g√≥c nh·∫π
        let rect = NSRect(x: 0, y: 0, width: width, height: height)
        let path = NSBezierPath(roundedRect: rect, xRadius: 3, yRadius: 3)
        NSColor.white.setFill()
        path.fill()

        // Text transparent (d√πng .clear v·ªõi blend mode)
        let font = NSFont.systemFont(ofSize: 13, weight: .bold)
        let attrs: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: NSColor.black
        ]
        let textSize = text.size(withAttributes: attrs)
        let textRect = NSRect(
            x: (width - textSize.width) / 2,
            y: (height - textSize.height) / 2,
            width: textSize.width,
            height: textSize.height
        )

        // V·∫Ω text v·ªõi blend mode ƒë·ªÉ t·∫°o transparent
        NSGraphicsContext.current?.compositingOperation = .destinationOut
        text.draw(in: textRect, withAttributes: attrs)

        image.unlockFocus()
        image.isTemplate = false
        return image
    }

    // MARK: - Menu

    private func setupMenu() {
        let menu = NSMenu()

        // Header with toggle
        let header = NSMenuItem()
        header.view = createHeaderView()
        header.tag = 1
        menu.addItem(header)
        menu.addItem(.separator())

        // Input methods
        let telex = NSMenuItem(title: "Telex", action: #selector(selectTelex), keyEquivalent: "1")
        telex.keyEquivalentModifierMask = .command
        telex.target = self
        telex.tag = 10
        menu.addItem(telex)

        let vni = NSMenuItem(title: "VNI", action: #selector(selectVNI), keyEquivalent: "2")
        vni.keyEquivalentModifierMask = .command
        vni.target = self
        vni.tag = 11
        menu.addItem(vni)
        menu.addItem(.separator())

        // About & Help
        let about = NSMenuItem(title: "Gi·ªõi thi·ªáu \(AppMetadata.name)", action: #selector(showAbout), keyEquivalent: "")
        about.target = self
        menu.addItem(about)

        let checkUpdate = NSMenuItem(title: "Ki·ªÉm tra c·∫≠p nh·∫≠t...", action: #selector(checkForUpdates), keyEquivalent: "u")
        checkUpdate.keyEquivalentModifierMask = .command
        checkUpdate.target = self
        menu.addItem(checkUpdate)

        let help = NSMenuItem(title: "G√≥p √Ω & B√°o l·ªói", action: #selector(openHelp), keyEquivalent: "")
        help.target = self
        menu.addItem(help)
        menu.addItem(.separator())

        // Quit
        let quit = NSMenuItem(title: "Tho√°t", action: #selector(NSApp.terminate), keyEquivalent: "q")
        menu.addItem(quit)

        statusItem.menu = menu
        updateMenu()
    }

    private func createHeaderView() -> NSView {
        let view = NSView(frame: NSRect(x: 0, y: 0, width: 220, height: 36))

        // App name
        let name = NSTextField(labelWithString: AppMetadata.name)
        name.font = .systemFont(ofSize: 13, weight: .bold)
        name.frame = NSRect(x: 14, y: 10, width: 120, height: 16)
        view.addSubview(name)

        // Toggle using SwiftUI for custom tint color
        if toggleState == nil {
            toggleState = ToggleState(isOn: isEnabled)
            toggleState?.onToggle = { [weak self] in self?.handleToggle() }
        }
        toggleState?.isOn = isEnabled
        let toggleView = ToggleWrapperView(state: toggleState!)
        let hostingView = NSHostingView(rootView: toggleView)
        hostingView.frame = NSRect(x: 162, y: 4, width: 50, height: 28)
        view.addSubview(hostingView)

        return view
    }

    private func updateMenu() {
        guard let menu = statusItem.menu else { return }
        menu.item(withTag: 1)?.view = createHeaderView()
        menu.item(withTag: 10)?.state = currentMethod == .telex ? .on : .off
        menu.item(withTag: 11)?.state = currentMethod == .vni ? .on : .off
    }

    // MARK: - Actions

    private func handleToggle() {
        isEnabled = toggleState?.isOn ?? !isEnabled
        UserDefaults.standard.set(isEnabled, forKey: SettingsKey.enabled)
        RustBridge.setEnabled(isEnabled)
        updateStatusButton()
        // Update method checkmarks only, toggle animates itself
        guard let menu = statusItem.menu else { return }
        menu.item(withTag: 10)?.state = currentMethod == .telex ? .on : .off
        menu.item(withTag: 11)?.state = currentMethod == .vni ? .on : .off
    }

    @objc private func selectTelex() { setMethod(.telex) }
    @objc private func selectVNI() { setMethod(.vni) }

    private func setMethod(_ mode: InputMode) {
        currentMethod = mode
        UserDefaults.standard.set(mode.rawValue, forKey: SettingsKey.method)
        RustBridge.setMethod(mode.rawValue)
        updateStatusButton()
        updateMenu()
    }

    private func enableLaunchAtLogin() {
        do {
            try LaunchAtLoginManager.shared.enable()
        } catch {
            print("[LaunchAtLogin] Error: \(error)")
        }
    }

    private func showOnboarding() {
        if onboardingWindow == nil {
            let view = OnboardingView()
            let controller = NSHostingController(rootView: view)
            onboardingWindow = NSWindow(contentViewController: controller)
            onboardingWindow?.title = AppMetadata.name
            onboardingWindow?.styleMask = [.titled, .closable]
            onboardingWindow?.setContentSize(controller.view.fittingSize)
            onboardingWindow?.center()
        }
        onboardingWindow?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }

    @objc private func showAbout() {
        if aboutWindow == nil {
            let controller = NSHostingController(rootView: AboutView())
            let window = NSWindow(contentViewController: controller)
            window.title = "Gi·ªõi thi·ªáu \(AppMetadata.name)"
            window.styleMask = [.titled, .closable]
            window.setContentSize(controller.view.fittingSize)
            window.center()
            window.isReleasedWhenClosed = false
            aboutWindow = window
        }
        NSApp.activate(ignoringOtherApps: true)
        aboutWindow?.makeKeyAndOrderFront(nil)
    }

    @objc private func openHelp() {
        NSWorkspace.shared.open(URL(string: AppMetadata.issuesURL)!)
    }

    @objc private func checkForUpdates() {
        if updateWindow == nil {
            let controller = NSHostingController(rootView: UpdateView())
            let window = NSWindow(contentViewController: controller)
            window.title = "Ki·ªÉm tra c·∫≠p nh·∫≠t"
            window.styleMask = [.titled, .closable]
            window.setContentSize(controller.view.fittingSize)
            window.center()
            window.isReleasedWhenClosed = false
            updateWindow = window
        }
        NSApp.activate(ignoringOtherApps: true)
        updateWindow?.makeKeyAndOrderFront(nil)

        // Trigger update check when window opens
        UpdateManager.shared.checkForUpdatesManually()
    }
}
</file>

<file path="platforms/macos/UpdateManager.swift">
import Foundation
import AppKit

// MARK: - Update State

enum UpdateState {
    case idle
    case checking
    case available(UpdateInfo)
    case upToDate
    case downloading(progress: Double)
    case readyToInstall(dmgPath: URL)
    case installing
    case error(String)
}

// MARK: - Update Manager

class UpdateManager: NSObject, ObservableObject {
    static let shared = UpdateManager()

    @Published var state: UpdateState = .idle
    @Published var lastCheckDate: Date?

    private var downloadTask: URLSessionDownloadTask?
    private var downloadedDMGPath: URL?

    private let autoCheckInterval: TimeInterval = 24 * 60 * 60  // 24 hours
    private let autoCheckKey = "gonhanh.update.lastCheck"
    private let skipVersionKey = "gonhanh.update.skipVersion"

    private override init() {
        super.init()
        lastCheckDate = UserDefaults.standard.object(forKey: autoCheckKey) as? Date
    }

    // MARK: - Public API

    /// Check for updates manually (UI will show in UpdateView)
    func checkForUpdatesManually() {
        checkForUpdates(silent: false)
    }

    /// Check for updates silently (background check)
    func checkForUpdatesSilently() {
        if let lastCheck = lastCheckDate,
           Date().timeIntervalSince(lastCheck) < autoCheckInterval {
            return
        }
        checkForUpdates(silent: true)
    }

    /// Download the update
    func downloadUpdate(_ info: UpdateInfo) {
        state = .downloading(progress: 0)

        let session = URLSession(configuration: .default, delegate: self, delegateQueue: .main)
        downloadTask = session.downloadTask(with: info.downloadURL)
        downloadTask?.resume()
    }

    /// Install the downloaded update (auto-install)
    func installUpdate() {
        guard case .readyToInstall(let dmgPath) = state else { return }

        state = .installing

        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            let result = self?.performAutoInstall(dmgPath: dmgPath)

            DispatchQueue.main.async {
                if let error = result {
                    self?.state = .error(error)
                }
            }
        }
    }

    /// Perform the actual auto-install process
    private func performAutoInstall(dmgPath: URL) -> String? {
        // 1. Mount DMG
        let mountPoint = "/Volumes/GoNhanh"

        let mountResult = shell("hdiutil attach '\(dmgPath.path)' -nobrowse -quiet -mountpoint '\(mountPoint)'")
        if mountResult.status != 0 {
            return "Kh√¥ng th·ªÉ m·ªü file c√†i ƒë·∫∑t. Vui l√≤ng th·ª≠ t·∫£i l·∫°i."
        }

        defer {
            // Always unmount
            shell("hdiutil detach '\(mountPoint)' -quiet -force")
        }

        // 2. Find .app in mounted volume
        let appName = "GoNhanh.app"
        let sourceApp = "\(mountPoint)/\(appName)"
        let destApp = "/Applications/\(appName)"

        guard FileManager.default.fileExists(atPath: sourceApp) else {
            return "File c√†i ƒë·∫∑t b·ªã l·ªói. Vui l√≤ng th·ª≠ t·∫£i l·∫°i."
        }

        // 3. Remove old app and copy new one
        let copyResult = shell("""
            rm -rf '\(destApp)' && cp -R '\(sourceApp)' '\(destApp)'
            """)

        if copyResult.status != 0 {
            return "Kh√¥ng c√≥ quy·ªÅn c√†i v√†o Applications. H√£y di chuy·ªÉn app v√†o th∆∞ m·ª•c kh√°c."
        }

        // 4. Restart app
        DispatchQueue.main.async {
            let newAppURL = URL(fileURLWithPath: destApp)
            NSWorkspace.shared.openApplication(at: newAppURL, configuration: .init())

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                NSApp.terminate(nil)
            }
        }

        return nil
    }

    @discardableResult
    private func shell(_ command: String) -> (output: String, status: Int32) {
        let process = Process()
        let pipe = Pipe()

        process.executableURL = URL(fileURLWithPath: "/bin/bash")
        process.arguments = ["-c", command]
        process.standardOutput = pipe
        process.standardError = pipe

        try? process.run()
        process.waitUntilExit()

        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: data, encoding: .utf8) ?? ""

        return (output.trimmingCharacters(in: .whitespacesAndNewlines), process.terminationStatus)
    }

    /// Skip this version
    func skipVersion(_ version: String) {
        UserDefaults.standard.set(version, forKey: skipVersionKey)
        state = .idle
    }

    /// Cancel ongoing download
    func cancelDownload() {
        downloadTask?.cancel()
        downloadTask = nil
        state = .idle
    }

    // MARK: - Private Methods

    private func checkForUpdates(silent: Bool) {
        if !silent {
            state = .checking
        }

        UpdateChecker.shared.checkForUpdates { [weak self] result in
            guard let self = self else { return }

            // Save check date
            self.lastCheckDate = Date()
            UserDefaults.standard.set(self.lastCheckDate, forKey: self.autoCheckKey)

            switch result {
            case .available(let info):
                // Check if user skipped this version
                let skippedVersion = UserDefaults.standard.string(forKey: self.skipVersionKey)
                if silent && skippedVersion == info.version {
                    self.state = .idle
                    return
                }

                self.state = .available(info)

                // Only show notification for background check
                if silent {
                    self.showUpdateNotification(info)
                }

            case .upToDate:
                self.state = .upToDate

            case .error(let message):
                self.state = .error(message)
            }
        }
    }

    // MARK: - Notification (for background check only)

    private func showUpdateNotification(_ info: UpdateInfo) {
        let notification = NSUserNotification()
        notification.title = "GoNhanh - C√≥ phi√™n b·∫£n m·ªõi"
        notification.informativeText = "Phi√™n b·∫£n \(info.version) ƒë√£ s·∫µn s√†ng ƒë·ªÉ t·∫£i v·ªÅ."
        notification.soundName = NSUserNotificationDefaultSoundName
        notification.hasActionButton = true
        notification.actionButtonTitle = "Xem"

        NSUserNotificationCenter.default.deliver(notification)
    }
}

// MARK: - URLSession Download Delegate

extension UpdateManager: URLSessionDownloadDelegate {
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
        let destinationURL = downloadsURL.appendingPathComponent("GoNhanh.dmg")

        do {
            // Remove old file if exists
            if FileManager.default.fileExists(atPath: destinationURL.path) {
                try FileManager.default.removeItem(at: destinationURL)
            }

            // Copy instead of move to avoid cross-volume errors
            try FileManager.default.copyItem(at: location, to: destinationURL)

            downloadedDMGPath = destinationURL
            state = .readyToInstall(dmgPath: destinationURL)

        } catch {
            state = .error("Kh√¥ng th·ªÉ l∆∞u file: \(error.localizedDescription)")
        }
    }

    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        let progress = Double(totalBytesWritten) / Double(totalBytesExpectedToWrite)
        state = .downloading(progress: progress)
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if let error = error {
            if (error as NSError).code == NSURLErrorCancelled {
                state = .idle
            } else {
                state = .error("T·∫£i v·ªÅ th·∫•t b·∫°i: \(error.localizedDescription)")
            }
        }
    }
}
</file>

<file path="platforms/macos/RustBridge.swift">
import Foundation
import Carbon
import AppKit

// MARK: - Debug Logging

/// Smart debug logging - only active when /tmp/gonhanh_debug.log exists
/// Enable: touch /tmp/gonhanh_debug.log
/// Disable: rm /tmp/gonhanh_debug.log
private enum Log {
    private static let logPath = "/tmp/gonhanh_debug.log"
    private static var isEnabled: Bool { FileManager.default.fileExists(atPath: logPath) }

    private static func write(_ msg: String) {
        guard isEnabled, let handle = FileHandle(forWritingAtPath: logPath) else { return }
        let ts = String(format: "%02d:%02d:%02d.%03d",
                        Calendar.current.component(.hour, from: Date()),
                        Calendar.current.component(.minute, from: Date()),
                        Calendar.current.component(.second, from: Date()),
                        Calendar.current.component(.nanosecond, from: Date()) / 1_000_000)
        handle.seekToEndOfFile()
        handle.write("[\(ts)] \(msg)\n".data(using: .utf8)!)
        handle.closeFile()
    }

    // Concise log methods
    static func key(_ code: UInt16, _ result: String) { write("K:\(code) ‚Üí \(result)") }
    static func transform(_ bs: Int, _ chars: String) { write("T: ‚Üê\(bs) \"\(chars)\"") }
    static func send(_ method: String, _ bs: Int, _ chars: String) { write("S:\(method) ‚Üê\(bs) \"\(chars)\"") }
    static func method(_ name: String) { write("M: \(name)") }
    static func ax(_ role: String?, _ app: String) { write("AX: \(role ?? "?") @\(app.split(separator: ".").last ?? "")") }
    static func event(_ msg: String) { write("E: \(msg)") }
    static func info(_ msg: String) { write("I: \(msg)") }
    static func skip() { write("K: skip (self)") }
}

// MARK: - FFI (Rust Bridge)

/// FFI Result struct - must match Rust #[repr(C)]
private struct ImeResult {
    var chars: (UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32)
    var action: UInt8      // 0=None, 1=Send, 2=Restore
    var backspace: UInt8
    var count: UInt8
    var _pad: UInt8
}

@_silgen_name("ime_init") private func ime_init()
@_silgen_name("ime_key_ext") private func ime_key_ext(_ key: UInt16, _ caps: Bool, _ ctrl: Bool, _ shift: Bool) -> UnsafeMutablePointer<ImeResult>?
@_silgen_name("ime_method") private func ime_method(_ method: UInt8)
@_silgen_name("ime_enabled") private func ime_enabled(_ enabled: Bool)
@_silgen_name("ime_clear") private func ime_clear()
@_silgen_name("ime_free") private func ime_free(_ result: UnsafeMutablePointer<ImeResult>?)

// MARK: - RustBridge (Public API)

class RustBridge {
    private static var isInitialized = false

    static func initialize() {
        guard !isInitialized else { return }
        ime_init()
        isInitialized = true
        Log.info("Engine initialized")
    }

    /// Process key ‚Üí (backspaceCount, newChars) or nil
    static func processKey(keyCode: UInt16, caps: Bool, ctrl: Bool, shift: Bool = false) -> (Int, [Character])? {
        guard isInitialized, let ptr = ime_key_ext(keyCode, caps, ctrl, shift) else { return nil }
        defer { ime_free(ptr) }

        let r = ptr.pointee
        guard r.action == 1 else { return nil }  // 1 = Send

        let chars = withUnsafePointer(to: r.chars) { p in
            p.withMemoryRebound(to: UInt32.self, capacity: 32) { bound in
                (0..<Int(r.count)).compactMap { Unicode.Scalar(bound[$0]).map(Character.init) }
            }
        }
        return (Int(r.backspace), chars)
    }

    static func setMethod(_ method: Int) {
        ime_method(UInt8(method))
        Log.info("Method: \(method == 0 ? "Telex" : "VNI")")
    }

    static func setEnabled(_ enabled: Bool) {
        ime_enabled(enabled)
        Log.info("Enabled: \(enabled)")
    }

    static func clearBuffer() { ime_clear() }
}

// MARK: - Keyboard Hook Manager

class KeyboardHookManager {
    static let shared = KeyboardHookManager()

    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var isRunning = false

    private init() {}

    func start() {
        guard !isRunning else { return }

        guard AXIsProcessTrusted() else {
            let opts = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true] as CFDictionary
            AXIsProcessTrustedWithOptions(opts)
            Log.info("Requesting accessibility permission")
            return
        }

        RustBridge.initialize()

        let mask: CGEventMask = 1 << CGEventType.keyDown.rawValue
        let tap = CGEvent.tapCreate(tap: .cghidEventTap, place: .headInsertEventTap,
                                    options: .defaultTap, eventsOfInterest: mask,
                                    callback: keyboardCallback, userInfo: nil)
            ?? CGEvent.tapCreate(tap: .cgSessionEventTap, place: .headInsertEventTap,
                                 options: .defaultTap, eventsOfInterest: mask,
                                 callback: keyboardCallback, userInfo: nil)

        guard let tap = tap else {
            showAccessibilityAlert()
            return
        }

        eventTap = tap
        runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0)
        if let source = runLoopSource {
            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, .commonModes)
            CGEvent.tapEnable(tap: tap, enable: true)
            isRunning = true
            Log.info("Hook started")
        }
    }

    func stop() {
        guard isRunning else { return }
        if let tap = eventTap { CGEvent.tapEnable(tap: tap, enable: false) }
        if let src = runLoopSource { CFRunLoopRemoveSource(CFRunLoopGetCurrent(), src, .commonModes) }
        eventTap = nil
        runLoopSource = nil
        isRunning = false
        Log.info("Hook stopped")
    }

    func getTap() -> CFMachPort? { eventTap }

    private func showAccessibilityAlert() {
        DispatchQueue.main.async {
            let alert = NSAlert()
            alert.messageText = "C·∫ßn quy·ªÅn Accessibility"
            alert.informativeText = "GoNhanh c·∫ßn quy·ªÅn Accessibility ƒë·ªÉ g√µ ti·∫øng Vi·ªát.\n\n1. M·ªü System Settings > Privacy & Security > Accessibility\n2. B·∫≠t GoNhanh\n3. Kh·ªüi ƒë·ªông l·∫°i app"
            alert.alertStyle = .warning
            alert.addButton(withTitle: "M·ªü System Settings")
            alert.addButton(withTitle: "H·ªßy")
            if alert.runModal() == .alertFirstButtonReturn {
                NSWorkspace.shared.open(URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")!)
            }
        }
    }
}

// MARK: - Keyboard Callback

private let kEventMarker: Int64 = 0x474E4820  // "GNH " - marks self-generated events

private func keyboardCallback(
    proxy: CGEventTapProxy, type: CGEventType, event: CGEvent, refcon: UnsafeMutableRawPointer?
) -> Unmanaged<CGEvent>? {

    // Re-enable if disabled
    if type == .tapDisabledByTimeout || type == .tapDisabledByUserInput {
        if let tap = KeyboardHookManager.shared.getTap() { CGEvent.tapEnable(tap: tap, enable: true) }
        Log.event("tap re-enabled")
        return Unmanaged.passUnretained(event)
    }

    guard type == .keyDown else { return Unmanaged.passUnretained(event) }

    // Skip self-generated events
    if event.getIntegerValueField(.eventSourceUserData) == kEventMarker {
        Log.skip()
        return Unmanaged.passUnretained(event)
    }

    let keyCode = UInt16(event.getIntegerValueField(.keyboardEventKeycode))
    let flags = event.flags

    // Ctrl+Space = toggle Vietnamese
    if keyCode == 0x31 && flags.contains(.maskControl) && !flags.contains(.maskCommand) {
        DispatchQueue.main.async { NotificationCenter.default.post(name: .toggleVietnamese, object: nil) }
        return nil
    }

    let shift = flags.contains(.maskShift)
    let caps = shift || flags.contains(.maskAlphaShift)
    let ctrl = flags.contains(.maskCommand) || flags.contains(.maskControl) || flags.contains(.maskAlternate)

    if let (bs, chars) = RustBridge.processKey(keyCode: keyCode, caps: caps, ctrl: ctrl, shift: shift) {
        let str = String(chars)
        Log.transform(bs, str)
        sendReplacement(backspace: bs, chars: chars)
        return nil
    }

    Log.key(keyCode, "pass")
    return Unmanaged.passUnretained(event)
}

// MARK: - Text Replacement

private enum Method { case fast, slow, selection }

private func detectMethod() -> Method {
    guard let app = NSWorkspace.shared.frontmostApplication,
          let bundleId = app.bundleIdentifier else { return .fast }

    // Try to get AX role
    let systemWide = AXUIElementCreateSystemWide()
    var focused: CFTypeRef?
    var role: String?

    if AXUIElementCopyAttributeValue(systemWide, kAXFocusedUIElementAttribute as CFString, &focused) == .success,
       let el = focused {
        var roleVal: CFTypeRef?
        AXUIElementCopyAttributeValue(el as! AXUIElement, kAXRoleAttribute as CFString, &roleVal)
        role = roleVal as? String
    }

    let shortId = bundleId.split(separator: ".").last.map(String.init) ?? bundleId
    Log.ax(role, shortId)

    // Selection method for autocomplete contexts
    if role == "AXComboBox" { Log.method("sel:combo"); return .selection }

    let browsers = ["com.google.Chrome", "com.apple.Safari", "company.thebrowser.Browser"]
    if browsers.contains(bundleId) && role == "AXTextField" { Log.method("sel:browser"); return .selection }

    if role == "AXTextField" && bundleId.hasPrefix("com.jetbrains") { Log.method("sel:jb"); return .selection }
    if bundleId == "com.microsoft.Excel" { Log.method("sel:excel"); return .selection }
    if bundleId == "com.microsoft.Word" { Log.method("sel:word"); return .selection }

    // Slow method for terminal apps
    let terminals = ["com.microsoft.VSCode", "com.todesktop.230313mzl4w4u92", "com.apple.Terminal",
                     "com.googlecode.iterm2", "io.alacritty", "com.github.wez.wezterm",
                     "com.google.antigravity", "dev.warp.Warp-Stable"]
    if terminals.contains(bundleId) { Log.method("slow:term"); return .slow }

    Log.method("fast")
    return .fast
}

private func sendReplacement(backspace bs: Int, chars: [Character]) {
    let method = detectMethod()
    let str = String(chars)

    switch method {
    case .selection: sendWithSelection(bs: bs, str: str)
    case .slow:      sendWithBackspace(bs: bs, str: str, delayMs: (1500, 3000, 2000))
    case .fast:      sendWithBackspace(bs: bs, str: str, delayMs: (200, 800, 500))
    }
}

private func sendWithBackspace(bs: Int, str: String, delayMs: (UInt32, UInt32, UInt32)) {
    guard let src = CGEventSource(stateID: .privateState) else { return }

    // Send backspaces
    for _ in 0..<bs {
        guard let dn = CGEvent(keyboardEventSource: src, virtualKey: 0x33, keyDown: true),
              let up = CGEvent(keyboardEventSource: src, virtualKey: 0x33, keyDown: false) else { continue }
        dn.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
        up.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
        dn.post(tap: .cgSessionEventTap)
        up.post(tap: .cgSessionEventTap)
        usleep(delayMs.0)
    }

    if bs > 0 { usleep(delayMs.1) }

    // Send unicode
    let utf16 = Array(str.utf16)
    guard let dn = CGEvent(keyboardEventSource: src, virtualKey: 0, keyDown: true),
          let up = CGEvent(keyboardEventSource: src, virtualKey: 0, keyDown: false) else { return }
    dn.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
    up.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
    dn.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    up.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    dn.post(tap: .cgSessionEventTap)
    up.post(tap: .cgSessionEventTap)
    usleep(delayMs.2)

    Log.send("bs", bs, str)
}

private func sendWithSelection(bs: Int, str: String) {
    guard let src = CGEventSource(stateID: .privateState) else { return }

    // Select with Shift+Left
    for _ in 0..<bs {
        guard let dn = CGEvent(keyboardEventSource: src, virtualKey: 0x7B, keyDown: true),
              let up = CGEvent(keyboardEventSource: src, virtualKey: 0x7B, keyDown: false) else { continue }
        dn.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
        up.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
        dn.flags = .maskShift
        up.flags = .maskShift
        dn.post(tap: .cgSessionEventTap)
        up.post(tap: .cgSessionEventTap)
    }

    // Replace selection
    let utf16 = Array(str.utf16)
    guard let dn = CGEvent(keyboardEventSource: src, virtualKey: 0, keyDown: true),
          let up = CGEvent(keyboardEventSource: src, virtualKey: 0, keyDown: false) else { return }
    dn.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
    up.setIntegerValueField(.eventSourceUserData, value: kEventMarker)
    dn.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    up.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    dn.post(tap: .cgSessionEventTap)
    up.post(tap: .cgSessionEventTap)

    Log.send("sel", bs, str)
}

// MARK: - Notifications

extension Notification.Name {
    static let toggleVietnamese = Notification.Name("toggleVietnamese")
}
</file>

<file path="core/tests/integration_test.rs">
//! Integration Tests - Engine state, settings, method switching

mod common;
use common::{assert_action, assert_passthrough, telex, type_word};
use gonhanh_core::data::keys;
use gonhanh_core::engine::{Action, Engine};

// ============================================================
// ENGINE STATE: Enable/Disable
// ============================================================

#[test]
fn disabled_engine_passes_through() {
    let mut e = Engine::new();
    e.set_enabled(false);

    assert_passthrough(&mut e, keys::A);
    assert_passthrough(&mut e, keys::S);
}

#[test]
fn re_enable_engine_works() {
    let mut e = Engine::new();
    e.set_enabled(false);
    e.set_enabled(true);

    let result = type_word(&mut e, "as");
    assert_eq!(result, "√°");
}

// ============================================================
// CTRL/CMD: Modifier key handling
// ============================================================

#[test]
fn ctrl_key_passes_through() {
    let mut e = Engine::new();

    // Ctrl+A should pass through
    assert_action(&mut e, keys::A, false, true, Action::None);

    // Buffer cleared, 's' alone passes through
    assert_passthrough(&mut e, keys::S);
}

#[test]
fn ctrl_clears_buffer() {
    let mut e = Engine::new();

    e.on_key(keys::A, false, false);
    e.on_key(keys::C, false, true); // Ctrl+C clears buffer
    assert_passthrough(&mut e, keys::S);
}

// ============================================================
// METHOD SWITCHING: Telex <-> VNI
// ============================================================

#[test]
fn method_switch_preserves_buffer() {
    let mut e = Engine::new();

    e.on_key(keys::A, false, false);
    e.set_method(1); // Switch to VNI

    // VNI tone '1' works on previous 'a'
    let r = e.on_key(keys::N1, false, false);
    assert_eq!(r.action, Action::Send as u8);
}

#[test]
fn invalid_method_defaults_to_telex() {
    let mut e = Engine::new();
    e.set_method(99); // Invalid

    let result = type_word(&mut e, "as");
    assert_eq!(result, "√°");
}

#[test]
fn switch_telex_to_vni_and_back() {
    let mut e = Engine::new();

    // Telex mode
    let result = type_word(&mut e, "as");
    assert_eq!(result, "√°");

    // Switch to VNI
    e.set_method(1);
    e.clear();
    let result = type_word(&mut e, "a1");
    assert_eq!(result, "√°");

    // Back to Telex
    e.set_method(0);
    e.clear();
    let result = type_word(&mut e, "af");
    assert_eq!(result, "√†");
}

// ============================================================
// UNKNOWN KEYS
// ============================================================

#[test]
fn unknown_key_passes_through() {
    let mut e = Engine::new();
    assert_passthrough(&mut e, 255);
}

#[test]
fn space_clears_buffer() {
    let mut e = Engine::new();

    e.on_key(keys::A, false, false);
    e.on_key(keys::SPACE, false, false);
    assert_passthrough(&mut e, keys::S);
}

// ============================================================
// EMPTY BUFFER: Tone/mark without vowel
// ============================================================

#[test]
fn tone_without_vowel_passes_through() {
    let mut e = Engine::new();

    assert_passthrough(&mut e, keys::S);
    assert_passthrough(&mut e, keys::F);
}

#[test]
fn telex_w_as_vowel_standalone() {
    // In Telex mode, standalone "w" ‚Üí "∆∞" (valid Vietnamese)
    let mut e = Engine::new();
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 1); // Action::Send
    assert_eq!(result.count, 1);
    assert_eq!(result.chars[0], '∆∞' as u32);
}

#[test]
fn telex_w_as_vowel_after_valid_consonant() {
    // "nhw" ‚Üí "nh∆∞" (valid: nh + ∆∞)
    let mut e = Engine::new();
    e.on_key(keys::N, false, false);
    e.on_key(keys::H, false, false);
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 1);
    assert_eq!(result.chars[0], '∆∞' as u32);
}

#[test]
fn telex_w_passthrough_after_invalid_consonant() {
    // "kw" ‚Üí "kw" (invalid: k cannot precede ∆∞)
    let mut e = Engine::new();
    e.on_key(keys::K, false, false);
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 0); // passthrough
}

#[test]
fn telex_ww_reverts() {
    // "ww" ‚Üí revert to "w" (shortcut skipped)
    // User typing pattern: w‚Üí∆∞, ww‚Üíw, www‚Üíww
    let mut e = Engine::new();

    // First w ‚Üí ∆∞
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 1);
    assert_eq!(result.chars[0], '∆∞' as u32);

    // Second w ‚Üí revert to "w" (single w, shortcut skipped)
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 1);
    assert_eq!(result.backspace, 1); // delete "∆∞"
    assert_eq!(result.count, 1); // output "w"
    assert_eq!(result.chars[0], 'w' as u32);

    // Third w ‚Üí just adds w (shortcut was skipped, not retried)
    let result = e.on_key(keys::W, false, false);
    assert_eq!(result.action, 0); // Pass through (normal letter)
}

#[test]
fn vni_w_passes_through() {
    // In VNI mode, "w" should pass through
    let mut e = Engine::new();
    e.set_method(1); // VNI
    assert_passthrough(&mut e, keys::W);
}

#[test]
fn word_boundary_shortcut_vn() {
    // Default shortcuts are currently disabled
    // This test verifies that "vn" + space just passes through
    let mut e = Engine::new();

    // Type "vn"
    e.on_key(keys::V, false, false);
    e.on_key(keys::N, false, false);

    // Space - no shortcut expansion (shortcuts disabled)
    let result = e.on_key(keys::SPACE, false, false);
    assert_eq!(result.action, 0); // Action::None (passthrough)
}

#[test]
fn vni_tone_without_vowel_passes_through() {
    let mut e = Engine::new();
    e.set_method(1);
    assert_passthrough(&mut e, keys::N1);
}

// ============================================================
// BACKSPACE HANDLING
// ============================================================

#[test]
fn backspace_on_empty_buffer() {
    let mut e = Engine::new();
    assert_passthrough(&mut e, keys::DELETE);
}

#[test]
fn multiple_backspace_clears_all() {
    let mut e = Engine::new();

    e.on_key(keys::A, false, false);
    e.on_key(keys::B, false, false);
    e.on_key(keys::DELETE, false, false);
    e.on_key(keys::DELETE, false, false);

    assert_passthrough(&mut e, keys::S);
}

// ============================================================
// CONSONANT-ONLY WORDS
// ============================================================

#[test]
fn consonant_only_no_conversion() {
    let mut e = Engine::new();
    let result = type_word(&mut e, "bcd");
    assert_eq!(result, "bcd");
}

#[test]
fn tone_after_consonant_only() {
    let mut e = Engine::new();
    let result = type_word(&mut e, "bcs");
    assert_eq!(result, "bcs");
}

// ============================================================
// CLEAR BUFFER
// ============================================================

#[test]
fn clear_resets_state() {
    let mut e = Engine::new();

    e.on_key(keys::A, false, false);
    e.clear();
    assert_passthrough(&mut e, keys::S);
}

// ============================================================
// ORTHOGRAPHY: Modern style (ho√†, not h√≤a)
// ============================================================

#[test]
fn modern_orthography_hoa() {
    let mut e = Engine::new();
    let result = type_word(&mut e, "hoaf");
    assert_eq!(result, "ho√†"); // Modern: tone on last vowel
}

const MODERN_ORTHO_CASES: &[(&str, &str)] = &[
    ("hoaf", "ho√†"),
    ("hoas", "ho√°"),
    ("hoar", "ho·∫£"),
    ("hoax", "ho√£"),
    ("hoaj", "ho·∫°"),
];

#[test]
fn modern_orthography_full() {
    for (input, expected) in MODERN_ORTHO_CASES {
        let mut e = Engine::new();
        let result = type_word(&mut e, input);
        assert_eq!(result, *expected, "Modern: {} ‚Üí {}", input, result);
    }
}

// ============================================================
// REVERT BEHAVIOR
// ============================================================

#[test]
fn double_tone_reverts() {
    telex(&[("ass", "as")]);
}

#[test]
fn double_mark_reverts() {
    telex(&[("aaa", "aa")]);
}

#[test]
fn triple_same_key_behavior() {
    let mut e = Engine::new();
    // a ‚Üí a, aa ‚Üí √¢, aaa ‚Üí aa, aaaa ‚Üí a√¢
    let result = type_word(&mut e, "aaaa");
    assert_eq!(result, "a√¢");
}

// ============================================================
// STRESS TEST: Long input sequences
// ============================================================

#[test]
fn long_input_sequence() {
    let mut e = Engine::new();

    // Type a very long Vietnamese sentence
    let input = "vieetj nam laf mootj quoocs gia ddepj vaf giauf truyeenf thoongs vawn hoas";
    let expected = "vi·ªát nam l√† m·ªôt qu·ªëc gia ƒë·∫πp v√† gi√†u truy·ªÅn th·ªëng vƒÉn ho√°";

    let result = type_word(&mut e, input);
    assert_eq!(result, expected);
}

#[test]
fn repeated_typing_sessions() {
    let mut e = Engine::new();

    // Multiple words, clearing between
    let result1 = type_word(&mut e, "xin");
    e.clear();
    let result2 = type_word(&mut e, "chaof");

    assert_eq!(result1, "xin");
    assert_eq!(result2, "ch√†o");
}

// ============================================================
// EDGE: Special sequences
// ============================================================

#[test]
fn only_modifiers() {
    let mut e = Engine::new();

    // Only modifier keys, no vowels
    let result = type_word(&mut e, "sssss");
    assert_eq!(result, "sssss");
}

#[test]
fn alternating_vowel_modifier() {
    let mut e = Engine::new();

    // a‚Üí√°‚Üías‚Üí√°‚Üías... (alternating)
    let result = type_word(&mut e, "asasas");
    // as‚Üí√°, as‚Üí√°, as‚Üí√° = √°√° (actually depends on engine buffer)
    // Each pair resets: a+s=√°, then new a+s=√°, etc
    // But with single engine instance, buffer accumulates
    assert!(!result.is_empty());
}

// ============================================================
// FOREIGN WORDS: Should NOT transform
// ============================================================

#[test]
fn foreign_word_claudeco_not_transformed() {
    let mut e = Engine::new();
    // "claudeco" has invalid initial "cl" ‚Üí stroke should NOT apply
    let result = type_word(&mut e, "claudecod");
    // Should remain as normal "d", not "ƒë"
    assert!(
        !result.contains('ƒë'),
        "claudeco+d should not become ƒë, got: {}",
        result
    );
}

#[test]
fn foreign_word_no_tone() {
    let mut e = Engine::new();
    // "expect" is invalid ‚Üí tone modifiers should not apply
    let result = type_word(&mut e, "expects");
    assert!(
        !result.contains('√©'),
        "expect+s should not add tone, got: {}",
        result
    );
}

#[test]
fn foreign_word_exp_no_circumflex() {
    let mut e = Engine::new();
    // "exp" is invalid ‚Üí circumflex should not apply when typing 'e'
    let result = type_word(&mut e, "expe");
    assert!(
        !result.contains('√™'),
        "exp+e should not become e√™p, got: {}",
        result
    );
}

#[test]
fn foreign_word_exxpe_no_transform() {
    let mut e = Engine::new();
    // When typing "exxpe":
    // - 'e' ‚Üí buffer="e"
    // - 'x' ‚Üí mark applied ‚Üí screen="·∫Ω"
    // - 'x' ‚Üí revert (same key) ‚Üí screen="ex", buffer="ex"
    // - 'p' ‚Üí screen="exp", buffer="exp" (invalid Vietnamese)
    // - 'e' ‚Üí buffer="expe" invalid ‚Üí no circumflex applied, just adds 'e'
    // Result: "expe" (the first x was consumed/reverted)
    let result = type_word(&mut e, "exxpe");
    assert_eq!(
        result, "expe",
        "exxpe should become expe (first x consumed by mark/revert), got: {}",
        result
    );
}

// ============================================================
// VNI: SHIFT+NUMBER PASSTHROUGH (for symbols like @, #, $)
// ============================================================

#[test]
fn vni_shift_2_passes_through_for_at_symbol() {
    // VNI: "hi" + Shift+2 should NOT apply huy·ªÅn mark
    // User wants to type "hi@", not "h√¨"
    let mut e = Engine::new();
    e.set_method(1); // VNI

    // Type "hi"
    e.on_key(keys::H, false, false);
    e.on_key(keys::I, false, false);

    // Shift+2 (for @) - should pass through, not apply mark
    let r = e.on_key_ext(keys::N2, true, false, true); // caps=true, ctrl=false, shift=true
    assert_eq!(
        r.action,
        Action::None as u8,
        "Shift+2 should pass through in VNI"
    );
}

#[test]
fn vni_shift_numbers_all_pass_through() {
    // All Shift+number combinations should pass through in VNI
    let mut e = Engine::new();
    e.set_method(1); // VNI

    // Type a vowel first
    e.on_key(keys::A, false, false);

    // All number keys with shift should pass through
    let number_keys = [
        keys::N1,
        keys::N2,
        keys::N3,
        keys::N4,
        keys::N5,
        keys::N6,
        keys::N7,
        keys::N8,
        keys::N9,
        keys::N0,
    ];

    for &key in &number_keys {
        let r = e.on_key_ext(key, true, false, true); // shift=true
        assert_eq!(
            r.action,
            Action::None as u8,
            "Shift+{} should pass through in VNI",
            key
        );
    }
}

#[test]
fn vni_without_shift_still_applies_marks() {
    // VNI: Without shift, number keys should still apply marks
    let mut e = Engine::new();
    e.set_method(1); // VNI

    // Type "a" + "2" (no shift) = √†
    e.on_key(keys::A, false, false);
    let r = e.on_key_ext(keys::N2, false, false, false); // shift=false

    assert_eq!(
        r.action,
        Action::Send as u8,
        "VNI mark should apply without shift"
    );
    assert_eq!(r.chars[0], '√†' as u32, "a2 should produce √†");
}

#[test]
fn telex_shift_not_affected() {
    // Telex mode should not be affected by the shift parameter
    // (Telex doesn't use number keys for marks)
    let mut e = Engine::new();
    e.set_method(0); // Telex

    // Type "a" + Shift+2 - should just pass through (2 is not a Telex modifier)
    e.on_key(keys::A, false, false);
    let r = e.on_key_ext(keys::N2, true, false, true);
    assert_eq!(
        r.action,
        Action::None as u8,
        "Telex should ignore number keys"
    );
}
</file>

<file path="core/src/engine/shortcut.rs">
//! Shortcut Table - Abbreviation expansion
//!
//! Allows users to define shortcuts like "vn" ‚Üí "Vi·ªát Nam"
//! Shortcuts can be specific to input methods (Telex/VNI) or apply to all.

use std::collections::HashMap;

/// Input method that shortcut applies to
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum InputMethod {
    /// Apply to all input methods
    #[default]
    All,
    /// Apply only to Telex
    Telex,
    /// Apply only to VNI
    Vni,
}

/// Trigger condition for shortcut
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TriggerCondition {
    /// Trigger immediately when buffer matches
    Immediate,
    /// Trigger when word boundary (space, punctuation) is pressed
    OnWordBoundary,
}

/// Case handling mode
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CaseMode {
    /// Keep replacement exactly as defined
    Exact,
    /// Match case of trigger: "VN" ‚Üí "VI·ªÜT NAM", "vn" ‚Üí "Vi·ªát Nam"
    MatchCase,
}

/// A single shortcut entry
#[derive(Debug, Clone)]
pub struct Shortcut {
    /// Trigger string (lowercase for matching)
    pub trigger: String,
    /// Replacement text
    pub replacement: String,
    /// When to trigger
    pub condition: TriggerCondition,
    /// How to handle case
    pub case_mode: CaseMode,
    /// Whether this shortcut is enabled
    pub enabled: bool,
    /// Which input method this shortcut applies to
    pub input_method: InputMethod,
}

impl Shortcut {
    /// Create a new shortcut with word boundary trigger (applies to all input methods)
    pub fn new(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::OnWordBoundary,
            case_mode: CaseMode::MatchCase,
            enabled: true,
            input_method: InputMethod::All,
        }
    }

    /// Create an immediate trigger shortcut (applies to all input methods)
    pub fn immediate(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::All,
        }
    }

    /// Create a Telex-specific shortcut with immediate trigger
    pub fn telex(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::Telex,
        }
    }

    /// Create a VNI-specific shortcut with immediate trigger
    pub fn vni(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::Vni,
        }
    }

    /// Set the input method for this shortcut
    pub fn for_method(mut self, method: InputMethod) -> Self {
        self.input_method = method;
        self
    }

    /// Check if shortcut applies to given input method
    ///
    /// - If shortcut is for `All`: matches any method
    /// - If shortcut is for `Telex`: matches `Telex` or `All` query
    /// - If shortcut is for `Vni`: matches `Vni` or `All` query
    pub fn applies_to(&self, query_method: InputMethod) -> bool {
        match self.input_method {
            // Shortcut for All ‚Üí matches any query
            InputMethod::All => true,
            // Shortcut for specific method ‚Üí matches if query is same method OR query is All
            InputMethod::Telex => {
                query_method == InputMethod::Telex || query_method == InputMethod::All
            }
            InputMethod::Vni => {
                query_method == InputMethod::Vni || query_method == InputMethod::All
            }
        }
    }
}

/// Shortcut match result
#[derive(Debug)]
pub struct ShortcutMatch {
    /// Number of characters to backspace
    pub backspace_count: usize,
    /// Replacement text to output
    pub output: String,
    /// Whether to include the trigger key in output
    pub include_trigger_key: bool,
}

/// Shortcut table manager
#[derive(Debug, Default)]
pub struct ShortcutTable {
    /// Shortcuts indexed by trigger (lowercase)
    shortcuts: HashMap<String, Shortcut>,
    /// Sorted triggers by length (longest first) for matching
    sorted_triggers: Vec<String>,
}

impl ShortcutTable {
    pub fn new() -> Self {
        Self {
            shortcuts: HashMap::new(),
            sorted_triggers: vec![],
        }
    }

    /// Create with default Vietnamese shortcuts (common abbreviations)
    ///
    /// Note: "w" ‚Üí "∆∞" is NOT a shortcut, it's handled by the engine
    /// as a vowel key with Vietnamese validation.
    ///
    /// Currently disabled - returns empty table
    pub fn with_defaults() -> Self {
        // Temporarily disabled default shortcuts
        Self::new()

        // Original defaults (uncomment to re-enable):
        // let mut table = Self::new();
        // table.add(Shortcut::new("vn", "Vi·ªát Nam"));
        // table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));
        // table.add(Shortcut::new("hn", "H√† N·ªôi"));
        // table.add(Shortcut::new("dc", "ƒë∆∞·ª£c"));
        // table.add(Shortcut::new("ko", "kh√¥ng"));
        // table
    }

    /// Create with Telex defaults only
    pub fn with_telex_defaults() -> Self {
        // No Telex-specific shortcuts
        // "w" ‚Üí "∆∞" is handled by the engine, not shortcuts
        Self::new()
    }

    /// Create with VNI defaults only
    pub fn with_vni_defaults() -> Self {
        Self::new()
    }

    /// Create with all defaults (common abbreviations)
    pub fn with_all_defaults() -> Self {
        let mut table = Self::new();

        // Common abbreviations (apply to all input methods)
        table.add(Shortcut::new("vn", "Vi·ªát Nam"));
        table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));
        table.add(Shortcut::new("hn", "H√† N·ªôi"));
        table.add(Shortcut::new("dc", "ƒë∆∞·ª£c"));
        table.add(Shortcut::new("ko", "kh√¥ng"));

        table
    }

    /// Add a shortcut
    pub fn add(&mut self, shortcut: Shortcut) {
        let trigger = shortcut.trigger.clone();
        self.shortcuts.insert(trigger.clone(), shortcut);
        self.rebuild_sorted_triggers();
    }

    /// Remove a shortcut
    pub fn remove(&mut self, trigger: &str) -> Option<Shortcut> {
        let result = self.shortcuts.remove(&trigger.to_lowercase());
        if result.is_some() {
            self.rebuild_sorted_triggers();
        }
        result
    }

    /// Check if buffer matches any shortcut (for any input method)
    ///
    /// Returns (trigger, shortcut) if match found
    pub fn lookup(&self, buffer: &str) -> Option<(&str, &Shortcut)> {
        self.lookup_for_method(buffer, InputMethod::All)
    }

    /// Check if buffer matches any shortcut for specific input method
    ///
    /// Returns (trigger, shortcut) if match found
    pub fn lookup_for_method(
        &self,
        buffer: &str,
        method: InputMethod,
    ) -> Option<(&str, &Shortcut)> {
        let buffer_lower = buffer.to_lowercase();

        // Longest-match-first
        for trigger in &self.sorted_triggers {
            if buffer_lower == *trigger {
                if let Some(shortcut) = self.shortcuts.get(trigger) {
                    if shortcut.enabled && shortcut.applies_to(method) {
                        return Some((trigger, shortcut));
                    }
                }
            }
        }
        None
    }

    /// Try to match buffer with trigger key (for any input method)
    ///
    /// # Arguments
    /// * `buffer` - Current buffer content (as string)
    /// * `key_char` - The key that was just pressed
    /// * `is_word_boundary` - Whether key_char is a word boundary
    ///
    /// # Returns
    /// ShortcutMatch if a shortcut should be triggered
    pub fn try_match(
        &self,
        buffer: &str,
        key_char: Option<char>,
        is_word_boundary: bool,
    ) -> Option<ShortcutMatch> {
        self.try_match_for_method(buffer, key_char, is_word_boundary, InputMethod::All)
    }

    /// Try to match buffer with trigger key for specific input method
    ///
    /// # Arguments
    /// * `buffer` - Current buffer content (as string)
    /// * `key_char` - The key that was just pressed
    /// * `is_word_boundary` - Whether key_char is a word boundary
    /// * `method` - The current input method (Telex/VNI)
    ///
    /// # Returns
    /// ShortcutMatch if a shortcut should be triggered
    pub fn try_match_for_method(
        &self,
        buffer: &str,
        key_char: Option<char>,
        is_word_boundary: bool,
        method: InputMethod,
    ) -> Option<ShortcutMatch> {
        let (trigger, shortcut) = self.lookup_for_method(buffer, method)?;

        match shortcut.condition {
            TriggerCondition::Immediate => {
                let output = self.apply_case(buffer, &shortcut.replacement, shortcut.case_mode);
                Some(ShortcutMatch {
                    backspace_count: trigger.len(),
                    output,
                    include_trigger_key: false,
                })
            }
            TriggerCondition::OnWordBoundary => {
                if is_word_boundary {
                    let mut output =
                        self.apply_case(buffer, &shortcut.replacement, shortcut.case_mode);
                    // Append the trigger key (space, etc.)
                    if let Some(ch) = key_char {
                        output.push(ch);
                    }
                    Some(ShortcutMatch {
                        backspace_count: trigger.len(),
                        output,
                        include_trigger_key: true,
                    })
                } else {
                    None
                }
            }
        }
    }

    /// Apply case transformation based on mode
    fn apply_case(&self, trigger: &str, replacement: &str, mode: CaseMode) -> String {
        match mode {
            CaseMode::Exact => replacement.to_string(),
            CaseMode::MatchCase => {
                if trigger.chars().all(|c| c.is_uppercase()) {
                    // All uppercase ‚Üí replacement all uppercase
                    replacement.to_uppercase()
                } else if trigger
                    .chars()
                    .next()
                    .map(|c| c.is_uppercase())
                    .unwrap_or(false)
                {
                    // First char uppercase ‚Üí capitalize replacement
                    let mut chars = replacement.chars();
                    match chars.next() {
                        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                        None => String::new(),
                    }
                } else {
                    // Lowercase ‚Üí keep replacement as-is
                    replacement.to_string()
                }
            }
        }
    }

    /// Rebuild sorted triggers list (longest first)
    fn rebuild_sorted_triggers(&mut self) {
        self.sorted_triggers = self.shortcuts.keys().cloned().collect();
        self.sorted_triggers
            .sort_by_key(|s| std::cmp::Reverse(s.len()));
    }

    /// Check if shortcut table is empty
    pub fn is_empty(&self) -> bool {
        self.shortcuts.is_empty()
    }

    /// Get number of shortcuts
    pub fn len(&self) -> usize {
        self.shortcuts.len()
    }

    /// Clear all shortcuts
    pub fn clear(&mut self) {
        self.shortcuts.clear();
        self.sorted_triggers.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Helper: Create table with one word-boundary shortcut
    fn table_with_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::new(trigger, replacement));
        table
    }

    // Helper: Create table with one immediate shortcut
    fn table_with_immediate(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::immediate(trigger, replacement));
        table
    }

    // Helper: Create table with Telex-specific shortcut
    fn table_with_telex_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::telex(trigger, replacement));
        table
    }

    // Helper: Create table with VNI-specific shortcut
    fn table_with_vni_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::vni(trigger, replacement));
        table
    }

    // Helper: Assert shortcut matches and check output/backspace
    fn assert_shortcut_match(
        table: &ShortcutTable,
        buffer: &str,
        key_char: Option<char>,
        is_boundary: bool,
        expected_output: &str,
        expected_backspace: usize,
        method: InputMethod,
    ) {
        let result = table.try_match_for_method(buffer, key_char, is_boundary, method);
        assert!(
            result.is_some(),
            "Shortcut should match for buffer: {}",
            buffer
        );
        let m = result.unwrap();
        assert_eq!(m.output, expected_output);
        assert_eq!(m.backspace_count, expected_backspace);
    }

    // Helper: Assert no shortcut match
    fn assert_no_match(
        table: &ShortcutTable,
        buffer: &str,
        key_char: Option<char>,
        is_boundary: bool,
        method: InputMethod,
    ) {
        let result = table.try_match_for_method(buffer, key_char, is_boundary, method);
        assert!(
            result.is_none(),
            "Shortcut should NOT match for buffer: {}",
            buffer
        );
    }

    #[test]
    fn test_basic_shortcut() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_case_matching() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Lowercase
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );

        // Uppercase
        assert_shortcut_match(
            &table,
            "VN",
            Some(' '),
            true,
            "VI·ªÜT NAM ",
            2,
            InputMethod::All,
        );

        // Title case
        assert_shortcut_match(
            &table,
            "Vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_immediate_shortcut() {
        let table = table_with_immediate("w", "∆∞");

        // Immediate triggers without word boundary
        let result = table.try_match("w", None, false);
        assert!(result.is_some());
        let m = result.unwrap();
        assert_eq!(m.output, "∆∞");
        assert!(!m.include_trigger_key);
    }

    #[test]
    fn test_word_boundary_required() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Without word boundary - should not match
        assert_no_match(&table, "vn", Some('a'), false, InputMethod::All);

        // With word boundary - should match
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_longest_match() {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::new("h", "h·ªç"));
        table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));

        // "hcm" should match the longer shortcut
        let (trigger, _) = table.lookup("hcm").unwrap();
        assert_eq!(trigger, "hcm");
    }

    #[test]
    fn test_disabled_shortcut() {
        let mut table = ShortcutTable::new();
        let mut shortcut = Shortcut::new("vn", "Vi·ªát Nam");
        shortcut.enabled = false;
        table.add(shortcut);

        let result = table.lookup("vn");
        assert!(result.is_none());
    }

    #[test]
    fn test_telex_specific_shortcut() {
        let table = table_with_telex_shortcut("w", "∆∞");

        // Should match for Telex
        assert_shortcut_match(&table, "w", None, false, "∆∞", 1, InputMethod::Telex);

        // Should NOT match for VNI
        assert_no_match(&table, "w", None, false, InputMethod::Vni);

        // Should match for All (fallback)
        assert_shortcut_match(&table, "w", None, false, "∆∞", 1, InputMethod::All);
    }

    #[test]
    fn test_vni_specific_shortcut() {
        let table = table_with_vni_shortcut("7", "∆°");

        // Should match for VNI
        assert_shortcut_match(&table, "7", None, false, "∆°", 1, InputMethod::Vni);

        // Should NOT match for Telex
        assert_no_match(&table, "7", None, false, InputMethod::Telex);
    }

    #[test]
    fn test_all_input_method_shortcut() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Should match for Telex
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::Telex,
        );

        // Should match for VNI
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::Vni,
        );

        // Should match for All
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_with_defaults_has_common_shortcuts() {
        let table = ShortcutTable::with_defaults();

        // Default shortcuts are currently disabled - table should be empty
        assert!(table.is_empty());

        // "vn" ‚Üí "Vi·ªát Nam" should NOT exist (disabled)
        let result = table.lookup_for_method("vn", InputMethod::All);
        assert!(result.is_none());

        // "w" is NOT a shortcut (handled by engine)
        let result = table.lookup_for_method("w", InputMethod::Telex);
        assert!(result.is_none());
    }

    #[test]
    fn test_shortcut_for_method_builder() {
        let shortcut = Shortcut::new("test", "Test").for_method(InputMethod::Telex);
        assert_eq!(shortcut.input_method, InputMethod::Telex);

        let shortcut = Shortcut::immediate("x", "y").for_method(InputMethod::Vni);
        assert_eq!(shortcut.input_method, InputMethod::Vni);
    }

    #[test]
    fn test_applies_to() {
        let all_shortcut = Shortcut::new("vn", "Vi·ªát Nam");
        assert!(all_shortcut.applies_to(InputMethod::All));
        assert!(all_shortcut.applies_to(InputMethod::Telex));
        assert!(all_shortcut.applies_to(InputMethod::Vni));

        let telex_shortcut = Shortcut::telex("test", "Test");
        assert!(telex_shortcut.applies_to(InputMethod::All));
        assert!(telex_shortcut.applies_to(InputMethod::Telex));
        assert!(!telex_shortcut.applies_to(InputMethod::Vni));

        let vni_shortcut = Shortcut::vni("7", "∆°");
        assert!(vni_shortcut.applies_to(InputMethod::All));
        assert!(!vni_shortcut.applies_to(InputMethod::Telex));
        assert!(vni_shortcut.applies_to(InputMethod::Vni));
    }
}
</file>

<file path="scripts/generate-release-notes.sh">
#!/bin/bash
# Generate release notes using AI (opencode CLI)
# Usage: ./generate-release-notes.sh [version] [from-ref]
# Examples:
#   ./generate-release-notes.sh                    # from last local tag to HEAD
#   ./generate-release-notes.sh v1.0.18            # from last local tag to HEAD
#   ./generate-release-notes.sh v1.0.18 v1.0.17   # from v1.0.17 to HEAD

VERSION="${1:-next}"
FROM_REF="$2"

# Determine starting point - prefer local tag (GitHub release may not exist yet)
if [ -z "$FROM_REF" ]; then
    # Get most recent tag from local git
    FROM_REF=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
fi

# Fallback: get from GitHub release
if [ -z "$FROM_REF" ]; then
    FROM_REF=$(gh release view --json tagName -q .tagName 2>/dev/null || echo "")
fi

# Final fallback: last 20 commits
if [ -z "$FROM_REF" ]; then
    FROM_REF="HEAD~20"
fi

echo "üìù Generating release notes: $FROM_REF ‚Üí HEAD" >&2

# Get commit list
COMMITS=$(git log "$FROM_REF"..HEAD --pretty=format:"- %s (%h)" 2>/dev/null)

# Get diff summary (files changed + stats)
DIFF_STAT=$(git diff "$FROM_REF"..HEAD --stat 2>/dev/null)

# Get detailed diff (limited to avoid being too long)
DIFF_CONTENT=$(git diff "$FROM_REF"..HEAD --no-color 2>/dev/null | head -500)

if [ -z "$COMMITS" ] && [ -z "$DIFF_STAT" ]; then
    echo "No changes found from $FROM_REF to HEAD" >&2
    exit 1
fi

echo "üìä Found $(echo "$COMMITS" | wc -l | tr -d ' ') commits" >&2

opencode run --format json "T·∫°o release notes cho version $VERSION c·ªßa 'G√µ Nhanh' (Vietnamese IME for macOS).
Quy t·∫Øc:
- Ph√¢n t√≠ch code changes ƒë·ªÉ hi·ªÉu thay ƒë·ªïi th·ª±c s·ª±, kh√¥ng ch·ªâ d·ª±a v√†o commit message
- Nh√≥m theo: üêõ S·ª≠a l·ªói, ‚ö° C·∫£i thi·ªán, üîß Kh√°c (b·ªè section r·ªóng)
- M·ªói item: 1 d√≤ng, s√∫c t√≠ch, m√¥ t·∫£ user-facing changes
- Vi·∫øt ti·∫øng Vi·ªát (c√≥ th·ªÉ d√πng keywords ti·∫øng Anh nh∆∞ build, config, API...)
- Ch·ªâ output markdown, kh√¥ng gi·∫£i th√≠ch th√™m" 2>/dev/null | jq -r 'select(.type == "text") | .part.text

## Commits:
$COMMITS

## Files changed:
$DIFF_STAT

## Code changes (snippet):
$DIFF_CONTENT
'
</file>

<file path="Makefile">
.PHONY: help all test format build clean setup install dmg release release-minor release-major

# Auto-versioning
TAG := $(shell git describe --tags --abbrev=0 2>/dev/null || echo v0.0.0)
VER := $(subst v,,$(TAG))
NEXT_PATCH := $(shell echo $(VER) | awk -F. '{print $$1"."$$2"."$$3+1}')
NEXT_MINOR := $(shell echo $(VER) | awk -F. '{print $$1"."$$2+1".0"}')
NEXT_MAJOR := $(shell echo $(VER) | awk -F. '{print $$1+1".0.0"}')

# Default target
.DEFAULT_GOAL := help

help: ## Show this help
	@echo "‚ö° G√µ Nhanh - Vietnamese Input Method Engine"
	@echo ""
	@echo "Usage: make [target]"
	@echo ""
	@echo "\033[1;34mDevelopment:\033[0m"
	@grep -E '^(test|format|build|clean):.*?## ' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[1;32m%-12s\033[0m %s\n", $$1, $$2}'
	@echo ""
	@echo "\033[1;33mSetup & Install:\033[0m"
	@grep -E '^(setup|install):.*?## ' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[1;32m%-12s\033[0m %s\n", $$1, $$2}'
	@echo ""
	@echo "\033[1;31mRelease:\033[0m"
	@grep -E '^(release|release-minor|release-major|all):.*?## ' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[1;32m%-15s\033[0m %s\n", $$1, $$2}'

all: test build ## Run test + build

test: ## Run tests
	@cd core && cargo test

format: ## Format & lint
	@cd core && cargo fmt && cargo clippy -- -D warnings

build: format ## Build core + macos app
	@./scripts/build-core.sh
	@./scripts/build-macos.sh
	@./scripts/build-windows.sh

clean: ## Clean build artifacts
	@cd core && cargo clean
	@rm -rf platforms/macos/build

setup: ## Setup dev environment
	@./scripts/setup.sh

install: build ## Install app to /Applications
	@cp -r platforms/macos/build/Release/GoNhanh.app /Applications/

dmg: build ## Create DMG installer
	@./scripts/create-dmg-background.sh
	@./scripts/create-dmg.sh

release: ## Patch release (1.0.9 ‚Üí 1.0.10)
	@echo "$(TAG) ‚Üí v$(NEXT_PATCH)"
	@git add -A && git commit -m "release: v$(NEXT_PATCH)" --allow-empty
	@./scripts/generate-release-notes.sh v$(NEXT_PATCH) > /tmp/release_notes.md
	@git tag -a v$(NEXT_PATCH) -F /tmp/release_notes.md
	@git push origin main v$(NEXT_PATCH)
	@echo "‚Üí https://github.com/khaphanspace/gonhanh.org/releases"

release-minor: ## Minor release (1.0.9 ‚Üí 1.1.0)
	@echo "$(TAG) ‚Üí v$(NEXT_MINOR)"
	@git add -A && git commit -m "release: v$(NEXT_MINOR)" --allow-empty
	@./scripts/generate-release-notes.sh v$(NEXT_MINOR) > /tmp/release_notes.md
	@git tag -a v$(NEXT_MINOR) -F /tmp/release_notes.md
	@git push origin main v$(NEXT_MINOR)
	@echo "‚Üí https://github.com/khaphanspace/gonhanh.org/releases"

release-major: ## Major release (1.0.9 ‚Üí 2.0.0)
	@echo "$(TAG) ‚Üí v$(NEXT_MAJOR)"
	@git add -A && git commit -m "release: v$(NEXT_MAJOR)" --allow-empty
	@./scripts/generate-release-notes.sh v$(NEXT_MAJOR) > /tmp/release_notes.md
	@git tag -a v$(NEXT_MAJOR) -F /tmp/release_notes.md
	@git push origin main v$(NEXT_MAJOR)
	@echo "‚Üí https://github.com/khaphanspace/gonhanh.org/releases"
</file>

<file path="README.md">
<p align="center">
  <img src="assets/logo.png" alt="G√µ Nhanh Logo" width="128" height="128">
</p>

<h1 align="center">G√µ Nhanh</h1>

<p align="center">
  <img src="https://img.shields.io/github/downloads/khaphanspace/gonhanh.org/total?label=Downloads" />
  <img src="https://img.shields.io/github/v/release/khaphanspace/gonhanh.org?label=Latest%20Release" />
  <img src="https://img.shields.io/github/last-commit/khaphanspace/gonhanh.org" />
</p>
<p align="center">
  <img src="https://img.shields.io/badge/Core-Rust-000000?logo=rust&logoColor=white" />
  <img src="https://img.shields.io/badge/UI-SwiftUI-F05138?logo=swift&logoColor=white" />
  <img src="https://img.shields.io/badge/Platform-macOS-000000?logo=apple&logoColor=white" />
  <img src="https://img.shields.io/badge/License-GPL--3.0-blue.svg" alt="License: GPL-3.0">
  <img src="https://github.com/khaphanspace/gonhanh.org/actions/workflows/ci.yml/badge.svg" alt="CI">
</p>

<p align="center"><strong>G√µ Nhanh</strong> - B·ªô g√µ ti·∫øng Vi·ªát hi·ªán ƒë·∫°i, hi·ªáu su·∫•t cao d√†nh cho macOS. <br>
K·∫øt h·ª£p s·ª©c m·∫°nh c·ªßa <strong>Rust</strong> (Core Engine) v√† <strong>SwiftUI</strong> (Native UI) ƒë·ªÉ mang l·∫°i tr·∫£i nghi·ªám g√µ ph√≠m m∆∞·ª£t m√†, ·ªïn ƒë·ªãnh v√† b·∫£o m·∫≠t.</p>

## üì• C√†i ƒë·∫∑t

| N·ªÅn t·∫£ng    | Tr·∫°ng th√°i  |                                                   T·∫£i xu·ªëng                                                   | H∆∞·ªõng d·∫´n                               |
| :---------- | :---------: | :-----------------------------------------------------------------------------------------------------------: | :-------------------------------------- |
| **macOS**   | ‚úÖ S·∫µn s√†ng | [üì• **T·∫£i v·ªÅ GoNhanh.dmg**](https://github.com/khaphanspace/gonhanh.org/releases/latest/download/GoNhanh.dmg) | [Xem h∆∞·ªõng d·∫´n](docs/install-macos.md)  |
| **Windows** | üóìÔ∏è Planned  |                                                       ‚Äî                                                       | [Xem l·ªô tr√¨nh](docs/install-windows.md) |
| **Linux**   | üóìÔ∏è Planned  |                                                       ‚Äî                                                       | [Xem l·ªô tr√¨nh](docs/install-linux.md)   |

## üöÄ T√≠nh nƒÉng n·ªïi b·∫≠t

G√µ Nhanh h∆∞·ªõng t·ªõi s·ª± **Chu·∫©n h√≥a - Hi·ªáu su·∫•t - Ti·ªán d·ª•ng**:

- **Core Engine (Rust)**: X·ª≠ l√Ω d·∫•u th√¥ng minh, ƒë·ªô tr·ªÖ < 1ms, b·ªô nh·ªõ c·ª±c th·∫•p (~5MB).
- **Native UI (SwiftUI)**: Giao di·ªán t·ªëi gi·∫£n tr√™n Menu Bar, h·ªó tr·ª£ Light/Dark mode.
- **Hook c·∫•p th·∫•p**: T∆∞∆°ng th√≠ch t·ªët v·ªõi Terminal, IDE (VS Code, IntelliJ) v√† c√°c ·ª©ng d·ª•ng ƒë·ªì h·ªça.
- **Smart Defaults**: C√†i l√† d√πng, kh√¥ng c·∫ßn c·∫•u h√¨nh ph·ª©c t·∫°p.

### T√≠nh nƒÉng chi ti·∫øt

#### üß† Core Engine

- **Ki·ªÉu g√µ**: H·ªó tr·ª£ ƒë·∫ßy ƒë·ªß **Telex** v√† **VNI**.
- **X·ª≠ l√Ω d·∫•u th√¥ng minh**:
  - T·ª± ƒë·ªông ƒë·∫∑t d·∫•u ƒë√∫ng v·ªã tr√≠ ng·ªØ √¢m (Smart Tone Placement).
  - T√πy ch·ªçn ki·ªÉu b·ªè d·∫•u: C·ªï ƒëi·ªÉn (`o√†`) ho·∫∑c Hi·ªán ƒë·∫°i (`√≤a`).
  - Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa √¢m ti·∫øt (Phonology Check) ƒë·ªÉ tr√°nh g√µ sai.
- **Hi·ªáu su·∫•t t·ªëi th∆∞·ª£ng**: ƒê·ªô tr·ªÖ x·ª≠ l√Ω < 1ms, b·ªô nh·ªõ s·ª≠ d·ª•ng c·ª±c th·∫•p (~5MB), kh√¥ng g√¢y n√≥ng m√°y.

#### üñ•Ô∏è Native App (macOS)

- **T·ªëi gi·∫£n**: ·ª®ng d·ª•ng ch·∫°y tr√™n Menu Bar, kh√¥ng chi·∫øm Dock, kh√¥ng l√†m phi·ªÅn.
- **Giao di·ªán hi·ªán ƒë·∫°i**: Vi·∫øt b·∫±ng **SwiftUI**, t·ª± ƒë·ªông th√≠ch ·ª©ng Light/Dark mode.
- **Ti·ªán √≠ch**:
  - Ph√≠m t·∫Øt chuy·ªÉn ƒë·ªïi Anh/Vi·ªát to√†n c·ª•c.
  - T·ª± ƒë·ªông kh·ªüi ƒë·ªông c√πng h·ªá th·ªëng.
  - C∆° ch·∫ø Hook b√†n ph√≠m c·∫•p th·∫•p (CGEventTap) ƒë·∫£m b·∫£o ƒë·ªô ·ªïn ƒë·ªãnh cao tr√™n m·ªçi ·ª©ng d·ª•ng (Terminal, Claude, IDE...).

### Cam k·∫øt "Ba Kh√¥ng"

- üö´ **Kh√¥ng thu ph√≠**: Mi·ªÖn ph√≠ tr·ªçn ƒë·ªùi, kh√¥ng c√≥ b·∫£n "Premium".
- üö´ **Kh√¥ng r√°c**: Kh√¥ng qu·∫£ng c√°o, kh√¥ng popup, kh√¥ng t√≠nh nƒÉng th·ª´a th√£i.
- üö´ **Kh√¥ng theo d√µi**: Offline 100%, kh√¥ng thu th·∫≠p d·ªØ li·ªáu, m√£ ngu·ªìn minh b·∫°ch.

## ƒê·ªông l·ª±c

T√¥i (**Kha Phan**) b·∫Øt ƒë·∫ßu d·ª± √°n n√†y v√¨ c√°c b·ªô g√µ hi·ªán t·∫°i th∆∞·ªùng xuy√™n g·∫∑p l·ªói khi t√¥i l√†m vi·ªác v·ªõi **Claude Code**.

T·ª´ nhu c·∫ßu gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ c√° nh√¢n, G√µ Nhanh ƒë∆∞·ª£c ph√°t tri·ªÉn th√†nh m·ªôt s·∫£n ph·∫©m ho√†n thi·ªán d√†nh t·∫∑ng c·ªông ƒë·ªìng. ƒê√¢y c≈©ng l√† s·ª± ti·∫øp n·ªëi v√† k·∫ø th·ª´a t·ª´ **UniKey**, **OpenKey** v√† **EVKey**.

## So s√°nh

|                |      G√µ Nhanh      |        EVKey        |    OpenKey     |    GoTiengViet    |     UniKey     |
| :------------- | :----------------: | :-----------------: | :------------: | :---------------: | :------------: |
| **Tr·∫°ng th√°i** | üü¢ **Ph√°t tri·ªÉn**  | üî¥ Ng·ª´ng ph√°t tri·ªÉn |   üü° B·∫£o tr√¨   | üü° Ng·ª´ng c·∫≠p nh·∫≠t |   üü¢ ·ªîn ƒë·ªãnh   |
| macOS          |         ‚úÖ         |         ‚úÖ          |       ‚úÖ       |        ‚úÖ         |       ‚ùå       |
| Windows        |     üóìÔ∏è Planned     |         ‚úÖ          |       ‚úÖ       |        ‚úÖ         |       ‚úÖ       |
| Linux          |     üóìÔ∏è Planned     |         ‚ùå          |       ‚úÖ       |        ‚ùå         |  ‚úÖ (Engine)   |
| **M√£ ngu·ªìn**   | ‚úÖ **Open Source** |   ‚úÖ Open Source    | ‚úÖ Open Source |     üö´ Closed     | ‚úÖ Core Engine |
| C√¥ng ngh·ªá      | **Rust + Native**  |      C++ + Qt       |    C++ + Qt    |    Obj-C / C++    |      C++       |
| B·∫£ng m√£        |    **Unicode**     |     ƒêa b·∫£ng m√£      |   ƒêa b·∫£ng m√£   |    ƒêa b·∫£ng m√£     |   ƒêa b·∫£ng m√£   |
| Chi ph√≠        |    ‚úÖ Mi·ªÖn ph√≠     |     ‚úÖ Mi·ªÖn ph√≠     |  ‚úÖ Mi·ªÖn ph√≠   |   Mi·ªÖn ph√≠/Pro    |  ‚úÖ Mi·ªÖn ph√≠   |
| NƒÉm ra m·∫Øt     |        2025        |        2018         |      2019      |       2008        |      1999      |

N·∫øu c·∫ßn chuy·ªÉn m√£ hay d√πng b·∫£ng m√£ c≈©, d√πng UniKey/EVKey/OpenKey.

### T·∫°i sao ch·ªçn G√µ Nhanh?

| V·∫•n ƒë·ªÅ                                     |    B·ªô g√µ kh√°c / M·∫∑c ƒë·ªãnh     |         G√µ Nhanh         |
| :----------------------------------------- | :--------------------------: | :----------------------: |
| **D√≠nh ch·ªØ Chrome/Edge** (`aa` ‚Üí `a√¢`)     | ‚ö†Ô∏è T·∫Øt autocomplete th·ªß c√¥ng |      ‚úÖ T·ª± ƒë·ªông fix      |
| **L·∫∑p ch·ªØ Google Docs** (`ƒë∆∞·ª£c` ‚Üí `ƒëƒë∆∞·ª£c`) |  ‚ö†Ô∏è B·∫≠t "S·ª≠a l·ªói" th·ªß c√¥ng   |      ‚úÖ T·ª± ƒë·ªông fix      |
| **M·∫•t d·∫•u Excel** (`tr∆∞·ªùng` ‚Üí `tr∆∞∆°ng`)    |       ‚ö†Ô∏è Kh√¥ng ·ªïn ƒë·ªãnh       |      ‚úÖ T·ª± ƒë·ªông fix      |
| **Nh·∫£y ch·ªØ Terminal/CLI**                  |     ‚ùå Kh√¥ng h·ªó tr·ª£ t·ªët      |    ‚úÖ Smart detection    |
| **H·ªôp ƒëen che ch·ªØ (macOS)**                |    ‚ùå Che m·∫•t n·ªôi dung g√µ    |     ‚úÖ Edit-in-place     |
| **G·∫°ch ch√¢n kh√≥ ch·ªãu (macOS)**             |       ‚ùå Lu√¥n hi·ªÉn th·ªã       |    ‚úÖ Kh√¥ng g·∫°ch ch√¢n    |
| **L·ªói l·∫∑p ch·ªØ Discord (Windows)**          |     ‚ùå Th∆∞·ªùng xuy√™n g·∫∑p      |  ‚úÖ Fix tri·ªát ƒë·ªÉ (plan)  |
| **Xung ƒë·ªôt ph√≠m t·∫Øt IDE**                  |     ‚ö†Ô∏è C·∫ßn map l·∫°i ph√≠m      |    ‚úÖ Hook th√¥ng minh    |
| **Ch·ªçn b·∫£ng m√£**                           |  ‚ö†Ô∏è Nhi·ªÅu l·ª±a ch·ªçn g√¢y r·ªëi   |   ‚úÖ M·∫∑c ƒë·ªãnh Unicode    |
| **Ch·ªçn ki·ªÉu g√µ**                           |    ‚ö†Ô∏è Telex/VNI/VIQR/...     |    ‚úÖ Telex ho·∫∑c VNI     |
| **C·∫•u h√¨nh ph·ª©c t·∫°p**                      |       ‚ö†Ô∏è 10+ t√πy ch·ªçn        |      ‚úÖ C√†i l√† d√πng      |
| **Ch·∫°y quy·ªÅn Admin (Windows)**             |     ‚ö†Ô∏è C·∫ßn b·∫≠t th·ªß c√¥ng      |   üóìÔ∏è T·ª± ƒë·ªông (planned)   |
| **Quy·ªÅn Accessibility (macOS)**            |    ‚ö†Ô∏è H∆∞·ªõng d·∫´n ph·ª©c t·∫°p     |    ‚úÖ Prompt t·ª± ƒë·ªông     |
| **G√µ trong Password field**                |  ‚ùå B·ªã ch·∫∑n (Secure Input)   | ‚úÖ Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng |
| **Kh·ªüi ƒë·ªông c√πng h·ªá th·ªëng**                |     ‚ö†Ô∏è C·∫•u h√¨nh th·ªß c√¥ng     |     ‚úÖ M·∫∑c ƒë·ªãnh b·∫≠t      |
| **C·∫≠p nh·∫≠t phi√™n b·∫£n**                     |      ‚ö†Ô∏è T·∫£i v·ªÅ th·ªß c√¥ng      | üóìÔ∏è Auto-update (planned) |

Chi ti·∫øt c√°c l·ªói th∆∞·ªùng g·∫∑p ·ªü c√°c b·ªô g√µ kh√°c: [docs/common-issues.md](docs/common-issues.md)

## C√°ch ho·∫°t ƒë·ªông

Engine d·ª±a tr√™n ng·ªØ √¢m h·ªçc ti·∫øng Vi·ªát thay v√¨ b·∫£ng tra c·ª©u:

```
√Çm ti·∫øt = [Ph·ª• √¢m ƒë·∫ßu] + [√Çm ƒë·ªám] + Nguy√™n √¢m ch√≠nh + [√Çm cu·ªëi] + Thanh ƒëi·ªáu
```

Thu·∫≠t to√°n ƒë·∫∑t d·∫•u theo quy t·∫Øc ng·ªØ √¢m. H·ªó tr·ª£ c·∫£ ki·ªÉu c≈© (`ho√†`) v√† ki·ªÉu m·ªõi (`h√≤a`).

Chi ti·∫øt: [docs/vietnamese-language-system.md](docs/vietnamese-language-system.md)

## Ki·∫øn tr√∫c

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               Platform UI Layer (Native)               ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ    ‚îÇ    macOS     ‚îÇ  ‚îÇ   Windows    ‚îÇ  ‚îÇ   Linux    ‚îÇ  ‚îÇ
‚îÇ    ‚îÇ   SwiftUI    ‚îÇ  ‚îÇ  WPF (Plan)  ‚îÇ  ‚îÇ IBus/Fcitx ‚îÇ  ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ           FFI Bridge (C ABI)      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Rust Core Library                      ‚îÇ
‚îÇ      (Engine, Logic, State, Phonology Rules)           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Input Processing Pipeline (Telex / VNI)         ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

- **Platform UI**: Native code (Swift/C#/C++) s·ª≠ d·ª•ng **Low-level Hook (CGEventTap)** ƒë·ªÉ b·∫Øt s·ª± ki·ªán ph√≠m t·∫ßng h·ªá th·ªëng, ƒë·∫£m b·∫£o ƒë·ªô tr·ªÖ < 1ms v√† t∆∞∆°ng th√≠ch m·ªçi ·ª©ng d·ª•ng.
- **Rust Core**: Logic x·ª≠ l√Ω ti·∫øng Vi·ªát d·ª±a tr√™n **thu·∫≠t to√°n ng·ªØ √¢m** (Phonology Engine) thay v√¨ tra b·∫£ng, gi√∫p x·ª≠ l√Ω d·∫•u th√¥ng minh v√† ch·ªâ t·ªën ~5MB b·ªô nh·ªõ.
- **FFI**: Giao ti·∫øp gi·ªØa UI v√† Core th√¥ng qua C ABI, ƒë·∫£m b·∫£o t√≠nh t∆∞∆°ng th√≠ch v√† t·ªëc ƒë·ªô t·ªëi ƒëa.

## T√†i li·ªáu

| T√†i li·ªáu                                                                 | M√¥ t·∫£                                                          |
| ------------------------------------------------------------------------ | -------------------------------------------------------------- |
| [H·ªá th·ªëng ch·ªØ vi·∫øt & Ph∆∞∆°ng ph√°p g√µ](docs/vietnamese-language-system.md) | C∆° s·ªü l√Ω thuy·∫øt ng·ªØ √¢m v√† quy t·∫Øc ƒë·∫∑t d·∫•u.                     |
| [System Architecture](docs/system-architecture.md)                       | Ki·∫øn tr√∫c h·ªá th·ªëng, FFI, v√† lu·ªìng d·ªØ li·ªáu.                     |
| [Development Guide](docs/development.md)                                 | H∆∞·ªõng d·∫´n build, test, v√† ƒë√≥ng g√≥p m√£ ngu·ªìn.                   |
| [C√°c l·ªói th∆∞·ªùng g·∫∑p](docs/common-issues.md)                              | T·ªïng h·ª£p l·ªói b·ªô g√µ (Chrome, Word, Terminal) v√† c√°ch kh·∫Øc ph·ª•c. |

## Star History

[![Star History Chart](https://api.star-history.com/svg?repos=khaphanspace/gonhanh.org&type=Timeline&legend=bottom-right)](https://www.star-history.com/#khaphanspace/gonhanh.org&type=Timeline&legend=bottom-right)

## License

Copyright ¬© 2025 G√µ Nhanh Contributors. [GNU GPLv3](LICENSE).
</file>

<file path="core/src/engine/mod.rs">
//! Vietnamese IME Engine
//!
//! Core engine for Vietnamese input method processing.
//! Uses pattern-based transformation with validation-first approach.
//!
//! ## Architecture
//!
//! 1. **Validation First**: Check if buffer is valid Vietnamese before transforming
//! 2. **Pattern-Based**: Scan entire buffer for patterns instead of case-by-case
//! 3. **Shortcut Support**: User-defined abbreviations with priority
//! 4. **Longest-Match-First**: For diacritic placement

pub mod buffer;
pub mod shortcut;
pub mod syllable;
pub mod transform;
pub mod validation;

use crate::data::{
    chars::{self, mark, tone},
    keys,
    vowel::{Phonology, Vowel},
};
use crate::input::{self, ToneType};
use crate::utils;
use buffer::{Buffer, Char, MAX};
use shortcut::{InputMethod, ShortcutTable};
use validation::is_valid;

/// Engine action result
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Action {
    None = 0,
    Send = 1,
    Restore = 2,
}

/// Result for FFI
#[repr(C)]
pub struct Result {
    pub chars: [u32; MAX],
    pub action: u8,
    pub backspace: u8,
    pub count: u8,
    pub _pad: u8,
}

impl Result {
    pub fn none() -> Self {
        Self {
            chars: [0; MAX],
            action: Action::None as u8,
            backspace: 0,
            count: 0,
            _pad: 0,
        }
    }

    pub fn send(backspace: u8, chars: &[char]) -> Self {
        let mut result = Self {
            chars: [0; MAX],
            action: Action::Send as u8,
            backspace,
            count: chars.len().min(MAX) as u8,
            _pad: 0,
        };
        for (i, &c) in chars.iter().take(MAX).enumerate() {
            result.chars[i] = c as u32;
        }
        result
    }
}

/// Transform type for revert tracking
#[derive(Clone, Copy, Debug, PartialEq)]
enum Transform {
    Mark(u16, u8),
    Tone(u16, u8),
    Stroke(u16),
    /// W as vowel ∆∞ (for revert: ww ‚Üí w)
    WAsVowel,
    /// W shortcut was explicitly skipped (prevent re-transformation)
    WShortcutSkipped,
}

/// Main Vietnamese IME engine
pub struct Engine {
    buf: Buffer,
    method: u8,
    enabled: bool,
    last_transform: Option<Transform>,
    shortcuts: ShortcutTable,
}

impl Default for Engine {
    fn default() -> Self {
        Self::new()
    }
}

impl Engine {
    pub fn new() -> Self {
        Self {
            buf: Buffer::new(),
            method: 0,
            enabled: true,
            last_transform: None,
            shortcuts: ShortcutTable::with_defaults(),
        }
    }

    pub fn set_method(&mut self, method: u8) {
        self.method = method;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
        if !enabled {
            self.buf.clear();
        }
    }

    pub fn shortcuts_mut(&mut self) -> &mut ShortcutTable {
        &mut self.shortcuts
    }

    /// Get current input method as InputMethod enum
    fn current_input_method(&self) -> InputMethod {
        match self.method {
            0 => InputMethod::Telex,
            1 => InputMethod::Vni,
            _ => InputMethod::All,
        }
    }

    /// Handle key event - main entry point
    ///
    /// # Arguments
    /// * `key` - macOS virtual keycode
    /// * `caps` - true if Caps Lock is active (for uppercase letters)
    /// * `ctrl` - true if Cmd/Ctrl/Alt is pressed (bypasses IME)
    pub fn on_key(&mut self, key: u16, caps: bool, ctrl: bool) -> Result {
        self.on_key_ext(key, caps, ctrl, false)
    }

    /// Handle key event with extended parameters
    ///
    /// # Arguments
    /// * `key` - macOS virtual keycode
    /// * `caps` - true if Caps Lock is active (for uppercase letters)
    /// * `ctrl` - true if Cmd/Ctrl/Alt is pressed (bypasses IME)
    /// * `shift` - true if Shift key is pressed (for symbols like @, #, $)
    pub fn on_key_ext(&mut self, key: u16, caps: bool, ctrl: bool, shift: bool) -> Result {
        if !self.enabled || ctrl {
            self.buf.clear();
            self.last_transform = None;
            return Result::none();
        }

        // Check for word boundary shortcuts BEFORE clearing buffer
        if keys::is_break(key) {
            let result = self.try_word_boundary_shortcut();
            self.buf.clear();
            self.last_transform = None;
            return result;
        }

        if key == keys::DELETE {
            self.buf.pop();
            self.last_transform = None;
            return Result::none();
        }

        self.process(key, caps, shift)
    }

    /// Main processing pipeline - pattern-based
    fn process(&mut self, key: u16, caps: bool, shift: bool) -> Result {
        let m = input::get(self.method);

        // In VNI mode, if Shift is pressed with a number key, skip all modifiers
        // User wants the symbol (@ for Shift+2, # for Shift+3, etc.), not VNI marks
        let skip_vni_modifiers = self.method == 1 && shift && keys::is_number(key);

        // Check modifiers by scanning buffer for patterns

        // 1. Stroke modifier (d ‚Üí ƒë)
        if !skip_vni_modifiers && m.stroke(key) {
            if let Some(result) = self.try_stroke(key) {
                return result;
            }
        }

        // 2. Tone modifier (circumflex, horn, breve)
        if !skip_vni_modifiers {
            if let Some(tone_type) = m.tone(key) {
                let targets = m.tone_targets(key);
                if let Some(result) = self.try_tone(key, caps, tone_type, targets) {
                    return result;
                }
            }
        }

        // 3. Mark modifier
        if !skip_vni_modifiers {
            if let Some(mark_val) = m.mark(key) {
                if let Some(result) = self.try_mark(key, caps, mark_val) {
                    return result;
                }
            }
        }

        // 4. Remove modifier
        if !skip_vni_modifiers && m.remove(key) {
            self.last_transform = None;
            return self.handle_remove();
        }

        // 5. In Telex: "w" as vowel "∆∞" when valid Vietnamese context
        // Examples: "w" ‚Üí "∆∞", "nhw" ‚Üí "nh∆∞", but "kw" ‚Üí "kw" (invalid)
        if self.method == 0 && key == keys::W {
            if let Some(result) = self.try_w_as_vowel(caps) {
                return result;
            }
        }

        // Not a modifier - normal letter
        self.handle_normal_letter(key, caps)
    }

    /// Try word boundary shortcuts (triggered by space, punctuation, etc.)
    fn try_word_boundary_shortcut(&mut self) -> Result {
        if self.buf.is_empty() {
            return Result::none();
        }

        let buffer_str = self.buf.to_string_preserve_case();
        let input_method = self.current_input_method();

        // Check for word boundary shortcut match
        if let Some(m) =
            self.shortcuts
                .try_match_for_method(&buffer_str, Some(' '), true, input_method)
        {
            let output: Vec<char> = m.output.chars().collect();
            return Result::send(m.backspace_count as u8, &output);
        }

        Result::none()
    }

    /// Try "w" as vowel "∆∞" in Telex mode
    ///
    /// Rules:
    /// - "w" alone ‚Üí "∆∞"
    /// - "nhw" ‚Üí "nh∆∞" (valid consonant + ∆∞)
    /// - "kw" ‚Üí "kw" (invalid, k cannot precede ∆∞)
    /// - "ww" ‚Üí revert to "w" (shortcut skipped)
    /// - "www" ‚Üí "ww" (subsequent w just adds normally)
    fn try_w_as_vowel(&mut self, caps: bool) -> Option<Result> {
        // If shortcut was previously skipped, don't try again
        if matches!(self.last_transform, Some(Transform::WShortcutSkipped)) {
            return None;
        }

        // Check revert: ww ‚Üí w (skip shortcut)
        if let Some(Transform::WAsVowel) = self.last_transform {
            self.last_transform = Some(Transform::WShortcutSkipped);
            // Fix buffer: remove the U(horn) that was added, replace with W
            self.buf.pop();
            self.buf.push(Char::new(keys::W, caps));
            // Revert: backspace "∆∞", output single "w"
            let w = if caps { 'W' } else { 'w' };
            return Some(Result::send(1, &[w]));
        }

        // Try adding U (∆∞ base) to buffer and validate
        self.buf.push(Char::new(keys::U, caps));

        // Set horn tone to make it ∆∞
        if let Some(c) = self.buf.get_mut(self.buf.len() - 1) {
            c.tone = tone::HORN;
        }

        // Validate: is this valid Vietnamese?
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if is_valid(&buffer_keys) {
            self.last_transform = Some(Transform::WAsVowel);

            // W shortcut adds ∆∞ without replacing anything on screen
            // (the raw 'w' key was never output, so no backspace needed)
            let vowel_char = chars::to_char(keys::U, caps, tone::HORN, 0).unwrap();
            return Some(Result::send(0, &[vowel_char]));
        }

        // Invalid - remove the U we added
        self.buf.pop();
        None
    }

    /// Try to apply stroke transformation by scanning buffer
    fn try_stroke(&mut self, key: u16) -> Option<Result> {
        // Scan buffer for un-stroked 'd'
        let d_pos = self
            .buf
            .iter()
            .enumerate()
            .find(|(_, c)| c.key == keys::D && !c.stroke)
            .map(|(i, _)| i);

        if let Some(pos) = d_pos {
            // Check revert: if last transform was stroke on same key at same position
            if let Some(Transform::Stroke(last_key)) = self.last_transform {
                if last_key == key {
                    return Some(self.revert_stroke(key, pos));
                }
            }

            // Validate buffer before applying stroke
            // Only validate if buffer has vowels (complete syllable)
            // Allow stroke on initial consonant before vowel is typed (e.g., "dd" ‚Üí "ƒë" then "ƒëi")
            let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
            let has_vowel = buffer_keys.iter().any(|&k| keys::is_vowel(k));
            if has_vowel && !is_valid(&buffer_keys) {
                return None;
            }

            // Mark as stroked
            if let Some(c) = self.buf.get_mut(pos) {
                c.stroke = true;
            }

            self.last_transform = Some(Transform::Stroke(key));
            return Some(self.rebuild_from(pos));
        }

        None
    }

    /// Try to apply tone transformation by scanning buffer for targets
    fn try_tone(
        &mut self,
        key: u16,
        caps: bool,
        tone_type: ToneType,
        targets: &[u16],
    ) -> Option<Result> {
        if self.buf.is_empty() {
            return None;
        }

        // Check revert first
        if let Some(Transform::Tone(last_key, _)) = self.last_transform {
            if last_key == key {
                return Some(self.revert_tone(key, caps));
            }
        }

        // Validate buffer
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if !is_valid(&buffer_keys) {
            return None;
        }

        let tone_val = tone_type.value();

        // Scan buffer for eligible target vowels (without existing tone)
        let mut target_positions = Vec::new();

        // Special case: uo compound for horn
        if tone_type == ToneType::Horn && self.has_uo_compound() {
            for (i, c) in self.buf.iter().enumerate() {
                if (c.key == keys::U || c.key == keys::O) && c.tone == tone::NONE {
                    target_positions.push(i);
                }
            }
        }

        // Normal case: find last matching target
        if target_positions.is_empty() {
            for (i, c) in self.buf.iter().enumerate().rev() {
                if targets.contains(&c.key) && c.tone == tone::NONE {
                    target_positions.push(i);
                    break;
                }
            }
        }

        if target_positions.is_empty() {
            return None;
        }

        // Apply tone
        let mut earliest_pos = usize::MAX;
        for &pos in &target_positions {
            if let Some(c) = self.buf.get_mut(pos) {
                c.tone = tone_val;
                earliest_pos = earliest_pos.min(pos);
            }
        }

        self.last_transform = Some(Transform::Tone(key, tone_val));

        // Reposition mark if needed
        let mark_moved_from = self.reposition_mark_if_needed();
        let mut rebuild_pos = earliest_pos;
        if let Some(old_pos) = mark_moved_from {
            rebuild_pos = rebuild_pos.min(old_pos);
        }

        Some(self.rebuild_from(rebuild_pos))
    }

    /// Try to apply mark transformation
    fn try_mark(&mut self, key: u16, caps: bool, mark_val: u8) -> Option<Result> {
        if self.buf.is_empty() {
            return None;
        }

        // Check revert first
        if let Some(Transform::Mark(last_key, _)) = self.last_transform {
            if last_key == key {
                return Some(self.revert_mark(key, caps));
            }
        }

        // Validate buffer
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if !is_valid(&buffer_keys) {
            return None;
        }

        let vowels = self.collect_vowels();
        if vowels.is_empty() {
            return None;
        }

        // Find mark position using phonology rules
        let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
        let has_final = self.has_final_consonant(last_vowel_pos);
        let has_qu = self.has_qu_initial();
        let pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

        if let Some(c) = self.buf.get_mut(pos) {
            c.mark = mark_val;
            self.last_transform = Some(Transform::Mark(key, mark_val));
            return Some(self.rebuild_from(pos));
        }

        None
    }

    /// Check for uo compound in buffer
    fn has_uo_compound(&self) -> bool {
        let mut prev_key: Option<u16> = None;
        for c in self.buf.iter() {
            if keys::is_vowel(c.key) {
                if let Some(pk) = prev_key {
                    if (pk == keys::U && c.key == keys::O) || (pk == keys::O && c.key == keys::U) {
                        return true;
                    }
                }
                prev_key = Some(c.key);
            } else {
                prev_key = None;
            }
        }
        false
    }

    /// Reposition mark after tone change
    fn reposition_mark_if_needed(&mut self) -> Option<usize> {
        let mark_info: Option<(usize, u8)> = self
            .buf
            .iter()
            .enumerate()
            .find(|(_, c)| c.mark > 0)
            .map(|(i, c)| (i, c.mark));

        if let Some((old_pos, mark_value)) = mark_info {
            let vowels = self.collect_vowels();
            if vowels.is_empty() {
                return None;
            }

            let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
            let has_final = self.has_final_consonant(last_vowel_pos);
            let has_qu = self.has_qu_initial();
            let new_pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

            if new_pos != old_pos {
                if let Some(c) = self.buf.get_mut(old_pos) {
                    c.mark = 0;
                }
                if let Some(c) = self.buf.get_mut(new_pos) {
                    c.mark = mark_value;
                }
                return Some(old_pos);
            }
        }
        None
    }

    /// Common revert logic: clear modifier, add key to buffer, rebuild output
    fn revert_and_rebuild(&mut self, pos: usize, key: u16, caps: bool) -> Result {
        // Calculate backspace BEFORE adding key (based on old buffer state)
        let backspace = (self.buf.len() - pos) as u8;

        // Add the reverted key to buffer so validation sees the full sequence
        self.buf.push(Char::new(key, caps));

        // Build output from position (includes new key)
        let output: Vec<char> = (pos..self.buf.len())
            .filter_map(|i| self.buf.get(i))
            .filter_map(|c| utils::key_to_char(c.key, c.caps))
            .collect();

        Result::send(backspace, &output)
    }

    /// Revert tone transformation
    fn revert_tone(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;

        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.tone > tone::NONE {
                    c.tone = tone::NONE;
                    return self.revert_and_rebuild(pos, key, caps);
                }
            }
        }
        Result::none()
    }

    /// Revert mark transformation
    fn revert_mark(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;

        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.mark > mark::NONE {
                    c.mark = mark::NONE;
                    return self.revert_and_rebuild(pos, key, caps);
                }
            }
        }
        Result::none()
    }

    /// Revert stroke transformation at specific position
    fn revert_stroke(&mut self, key: u16, pos: usize) -> Result {
        self.last_transform = None;

        if let Some(c) = self.buf.get_mut(pos) {
            if c.key == keys::D && !c.stroke {
                // Un-stroked d found at pos - this means we need to add another d
                let caps = c.caps;
                self.buf.push(Char::new(key, caps));
                return self.rebuild_from(pos);
            }
        }
        Result::none()
    }

    /// Handle remove modifier
    fn handle_remove(&mut self) -> Result {
        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.mark > mark::NONE {
                    c.mark = mark::NONE;
                    return self.rebuild_from(pos);
                }
                if c.tone > tone::NONE {
                    c.tone = tone::NONE;
                    return self.rebuild_from(pos);
                }
            }
        }
        Result::none()
    }

    /// Handle normal letter input
    fn handle_normal_letter(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;
        if keys::is_letter(key) {
            self.buf.push(Char::new(key, caps));
        } else {
            self.buf.clear();
        }
        Result::none()
    }

    /// Collect vowels from buffer
    fn collect_vowels(&self) -> Vec<Vowel> {
        utils::collect_vowels(&self.buf)
    }

    /// Check for final consonant after position
    fn has_final_consonant(&self, after_pos: usize) -> bool {
        utils::has_final_consonant(&self.buf, after_pos)
    }

    /// Check for qu initial
    fn has_qu_initial(&self) -> bool {
        utils::has_qu_initial(&self.buf)
    }

    /// Rebuild output from position
    fn rebuild_from(&self, from: usize) -> Result {
        let mut output = Vec::with_capacity(self.buf.len() - from);
        let mut backspace = 0u8;

        for i in from..self.buf.len() {
            if let Some(c) = self.buf.get(i) {
                backspace += 1;

                if c.key == keys::D && c.stroke {
                    output.push(chars::get_d(c.caps));
                } else if let Some(ch) = chars::to_char(c.key, c.caps, c.tone, c.mark) {
                    output.push(ch);
                } else if let Some(ch) = utils::key_to_char(c.key, c.caps) {
                    output.push(ch);
                }
            }
        }

        if output.is_empty() {
            Result::none()
        } else {
            Result::send(backspace, &output)
        }
    }

    /// Clear buffer
    pub fn clear(&mut self) {
        self.buf.clear();
        self.last_transform = None;
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::{telex, vni};

    const TELEX_BASIC: &[(&str, &str)] = &[
        ("as", "√°"),
        ("af", "√†"),
        ("ar", "·∫£"),
        ("ax", "√£"),
        ("aj", "·∫°"),
        ("aa", "√¢"),
        ("aw", "ƒÉ"),
        ("ee", "√™"),
        ("oo", "√¥"),
        ("ow", "∆°"),
        ("uw", "∆∞"),
        ("dd", "ƒë"),
    ];

    const VNI_BASIC: &[(&str, &str)] = &[
        ("a1", "√°"),
        ("a2", "√†"),
        ("a3", "·∫£"),
        ("a4", "√£"),
        ("a5", "·∫°"),
        ("a6", "√¢"),
        ("a8", "ƒÉ"),
        ("e6", "√™"),
        ("o6", "√¥"),
        ("o7", "∆°"),
        ("u7", "∆∞"),
        ("d9", "ƒë"),
    ];

    const TELEX_COMPOUND: &[(&str, &str)] =
        &[("duocw", "d∆∞∆°c"), ("nguoiw", "ng∆∞∆°i"), ("tuoiws", "t∆∞·ªõi")];

    #[test]
    fn test_telex_basic() {
        telex(TELEX_BASIC);
    }

    #[test]
    fn test_vni_basic() {
        vni(VNI_BASIC);
    }

    #[test]
    fn test_telex_compound() {
        telex(TELEX_COMPOUND);
    }
}
</file>

</files>
